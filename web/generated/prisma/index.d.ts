
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    comments: CommentPayload<ExtArgs>[]
    userDocumentPermissions: UserDocumentPermissionPayload<ExtArgs>[]
    userNotePermission: UserNotePermissionPayload<ExtArgs>[]
    statUnit: DailyStatUnitPayload<ExtArgs>[]
    scratchpadEntry: ScratchpadEntryPayload<ExtArgs>[]
    userDocumentAttributes: UserDocumentAttributesPayload<ExtArgs>[]
    dailyChallengeResponse: DailyChallengeResponsePayload<ExtArgs>[]
    dailyChallengeResponseLikes: DailyChallengeResponseLikesPayload<ExtArgs>[]
    dailyChallengePromptSuggestion: DailyChallengePromptSuggestionPayload<ExtArgs>[]
    followedBy: FollowsPayload<ExtArgs>[]
    following: FollowsPayload<ExtArgs>[]
    PublishedDocument: PublishedDocumentPayload<ExtArgs>[]
    publishedDocumentLikes: PublishedDocumentPayload<ExtArgs>[]
    writingSessions: WritingSessionPayload<ExtArgs>[]
    writingSessionLikes: WritingSessionPayload<ExtArgs>[]
    userEnhancedDocumentPermissions: UserEnhancedDocumentPermissionsPayload<ExtArgs>[]
    threadAttributes: ThreadAttributesPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    userID: string
    username: string | null
    appDrawerNoteIDs: string[]
    firstName: string | null
    lastName: string | null
    email: string
    longestStreak: number
    bio: string | null
    city: string | null
    country: string | null
    website: string | null
    twitter: string | null
    instagram: string | null
    createdAt: Date
    openAIAPICalls: number
  }, ExtArgs["result"]["user"]>
  composites: {}
}

/**
 * Model User
 * 
 */
export type User = runtime.Types.DefaultSelection<UserPayload>
export type FollowsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    follower: UserPayload<ExtArgs>
    following: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    followerID: string
    followingID: string
  }, ExtArgs["result"]["follows"]>
  composites: {}
}

/**
 * Model Follows
 * 
 */
export type Follows = runtime.Types.DefaultSelection<FollowsPayload>
export type NotePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    userNotePermissions: UserNotePermissionPayload<ExtArgs>[]
    document: DocumentPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    noteID: string
    title: string | null
    content: Prisma.JsonValue | null
    icon: string | null
    updatedAt: Date
    documentID: string
    personal: boolean
  }, ExtArgs["result"]["note"]>
  composites: {}
}

/**
 * Model Note
 * 
 */
export type Note = runtime.Types.DefaultSelection<NotePayload>
export type DocumentVersionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    comments: CommentPayload<ExtArgs>[]
    userDocumentPermissions: UserDocumentPermissionPayload<ExtArgs>[]
    document: DocumentPayload<ExtArgs>
    statUnit: DailyStatUnitPayload<ExtArgs>[]
    userDocumentAttributes: UserDocumentAttributesPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    documentVersionID: string
    content: Prisma.JsonValue | null
    updatedAt: Date
    createdAt: Date
    documentID: string
    versionName: string
    wordCount: number
  }, ExtArgs["result"]["documentVersion"]>
  composites: {}
}

/**
 * Model DocumentVersion
 * 
 */
export type DocumentVersion = runtime.Types.DefaultSelection<DocumentVersionPayload>
export type DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    documentVersions: DocumentVersionPayload<ExtArgs>[]
    userDocumentPermissions: UserDocumentPermissionPayload<ExtArgs>[]
    notes: NotePayload<ExtArgs>[]
    statUnit: DailyStatUnitPayload<ExtArgs>[]
    userDocumentAttributes: UserDocumentAttributesPayload<ExtArgs>[]
    PublishedDocument: PublishedDocumentPayload<ExtArgs>[]
    WritingSession: WritingSessionPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    documentID: string
    title: string
    updatedAt: Date
  }, ExtArgs["result"]["document"]>
  composites: {}
}

/**
 * Model Document
 * 
 */
export type Document = runtime.Types.DefaultSelection<DocumentPayload>
export type UserEnhancedDocumentPermissionsPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    enhancedDocument: EnhancedDocumentPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    userID: string
    enhancedDocumentID: string
    role: EnhancedDocumentRole
  }, ExtArgs["result"]["userEnhancedDocumentPermissions"]>
  composites: {}
}

/**
 * Model UserEnhancedDocumentPermissions
 * 
 */
export type UserEnhancedDocumentPermissions = runtime.Types.DefaultSelection<UserEnhancedDocumentPermissionsPayload>
export type EnhancedDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    userEnhancedDocumentPermissions: UserEnhancedDocumentPermissionsPayload<ExtArgs>[]
    threadAttributes: ThreadAttributesPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    enhancedDocumentID: string
    notesContent: Prisma.JsonValue
    embeddingsByNodeID: Prisma.JsonValue | null
    title: string
    updatedAt: Date
    draftContent: Prisma.JsonValue | null
    draftCollapsed: boolean
    ideas: string[]
  }, ExtArgs["result"]["enhancedDocument"]>
  composites: {}
}

/**
 * Model EnhancedDocument
 * 
 */
export type EnhancedDocument = runtime.Types.DefaultSelection<EnhancedDocumentPayload>
export type ThreadAttributesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    document: EnhancedDocumentPayload<ExtArgs>
    chatMessage: ChatMessagePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    threadID: string
    userID: string
    createdAt: Date
    updatedAt: Date
    archivedAt: Date | null
    enhancedDocumentID: string
    sectionData: Prisma.JsonValue | null
  }, ExtArgs["result"]["threadAttributes"]>
  composites: {}
}

/**
 * Model ThreadAttributes
 * 
 */
export type ThreadAttributes = runtime.Types.DefaultSelection<ThreadAttributesPayload>
export type ChatMessagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    thread: ThreadAttributesPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    chatMessageID: string
    content: string
    author: ChatMessageAuthor
    createdAt: Date
    threadID: string
  }, ExtArgs["result"]["chatMessage"]>
  composites: {}
}

/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = runtime.Types.DefaultSelection<ChatMessagePayload>
export type PublishedDocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    document: DocumentPayload<ExtArgs>
    user: UserPayload<ExtArgs>
    likingUsers: UserPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    publishedDocumentID: string
    documentID: string
    content: Prisma.JsonValue | null
    url: string
    userID: string
    publishedAt: Date
    updatedAt: Date
    title: string
    subtitle: string | null
  }, ExtArgs["result"]["publishedDocument"]>
  composites: {}
}

/**
 * Model PublishedDocument
 * 
 */
export type PublishedDocument = runtime.Types.DefaultSelection<PublishedDocumentPayload>
export type ScratchpadEntryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    scratchpadEntryID: string
    content: Prisma.JsonValue | null
    date: Date
    userID: string
  }, ExtArgs["result"]["scratchpadEntry"]>
  composites: {}
}

/**
 * Model ScratchpadEntry
 * 
 */
export type ScratchpadEntry = runtime.Types.DefaultSelection<ScratchpadEntryPayload>
export type CommentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    author: UserPayload<ExtArgs>
    documentVersion: DocumentVersionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    commentID: string
    commentData: Prisma.JsonValue
    authorID: string
    documentVersionID: string
    updatedAt: Date
    private: boolean
    resolved: boolean
    selectedText: string
  }, ExtArgs["result"]["comment"]>
  composites: {}
}

/**
 * Model Comment
 * 
 */
export type Comment = runtime.Types.DefaultSelection<CommentPayload>
export type UserDocumentPermissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    documentVersion: DocumentVersionPayload<ExtArgs> | null
    document: DocumentPayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    userDocumentPermissionID: string
    userID: string
    documentVersionID: string | null
    role: Role
    documentID: string | null
  }, ExtArgs["result"]["userDocumentPermission"]>
  composites: {}
}

/**
 * Model UserDocumentPermission
 * 
 */
export type UserDocumentPermission = runtime.Types.DefaultSelection<UserDocumentPermissionPayload>
export type UserNotePermissionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    note: NotePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    userNotePermissionID: string
    userID: string
    role: NoteRole
    noteID: string
  }, ExtArgs["result"]["userNotePermission"]>
  composites: {}
}

/**
 * Model UserNotePermission
 * 
 */
export type UserNotePermission = runtime.Types.DefaultSelection<UserNotePermissionPayload>
export type UserDocumentAttributesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    document: DocumentPayload<ExtArgs>
    user: UserPayload<ExtArgs>
    lastOpenedDocumentVersion: DocumentVersionPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    documentID: string
    userID: string
    lastOpenedDocumentVersionID: string
  }, ExtArgs["result"]["userDocumentAttributes"]>
  composites: {}
}

/**
 * Model UserDocumentAttributes
 * 
 */
export type UserDocumentAttributes = runtime.Types.DefaultSelection<UserDocumentAttributesPayload>
export type DailyStatUnitPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    documentVersion: DocumentVersionPayload<ExtArgs> | null
    document: DocumentPayload<ExtArgs> | null
    dailyChallengeResponse: DailyChallengeResponsePayload<ExtArgs> | null
  }
  scalars: $Extensions.GetResult<{
    dailyStatUnitID: string
    userID: string
    documentVersionID: string | null
    documentID: string | null
    dailyChallengeResponseID: string | null
    date: Date
    timeSpentSeconds: number
    wordsAdded: number
    wordsRemoved: number
  }, ExtArgs["result"]["dailyStatUnit"]>
  composites: {}
}

/**
 * Model DailyStatUnit
 * 
 */
export type DailyStatUnit = runtime.Types.DefaultSelection<DailyStatUnitPayload>
export type WritingSessionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    document: DocumentPayload<ExtArgs> | null
    likes: UserPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    writingSessionID: string
    userID: string
    segmentTime: number[]
    wordsAdded: number
    wordsRemoved: number
    timeSpentSeconds: number
    startDateTime: Date
    title: string
    documentID: string | null
    inProgress: boolean
    updatedAt: Date
  }, ExtArgs["result"]["writingSession"]>
  composites: {}
}

/**
 * Model WritingSession
 * 
 */
export type WritingSession = runtime.Types.DefaultSelection<WritingSessionPayload>
export type DailyChallengePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    dailyChallengeResponse: DailyChallengeResponsePayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    prompt: string
    date: Date
    id: number
  }, ExtArgs["result"]["dailyChallenge"]>
  composites: {}
}

/**
 * Model DailyChallenge
 * 
 */
export type DailyChallenge = runtime.Types.DefaultSelection<DailyChallengePayload>
export type DailyChallengeResponseLikesPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
    dailyChallengeResponse: DailyChallengeResponsePayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    userID: string
    dailyChallengeResponseID: string
    likeID: string
  }, ExtArgs["result"]["dailyChallengeResponseLikes"]>
  composites: {}
}

/**
 * Model DailyChallengeResponseLikes
 * 
 */
export type DailyChallengeResponseLikes = runtime.Types.DefaultSelection<DailyChallengeResponseLikesPayload>
export type DailyChallengeResponsePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs> | null
    likes: DailyChallengeResponseLikesPayload<ExtArgs>[]
    dailyChallenge: DailyChallengePayload<ExtArgs>
    dailyStatUnit: DailyStatUnitPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    userID: string | null
    dailyChallengeID: number
    dailyChallengeResponseID: string
    content: Prisma.JsonValue | null
    postedOn: Date | null
    wordCount: number
    completedOnTime: boolean
  }, ExtArgs["result"]["dailyChallengeResponse"]>
  composites: {}
}

/**
 * Model DailyChallengeResponse
 * 
 */
export type DailyChallengeResponse = runtime.Types.DefaultSelection<DailyChallengeResponsePayload>
export type DailyChallengePromptSuggestionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  objects: {
    user: UserPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    promptSuggestionID: string
    prompt: string
    userID: string
    createdAt: Date
    usedOn: Date | null
  }, ExtArgs["result"]["dailyChallengePromptSuggestion"]>
  composites: {}
}

/**
 * Model DailyChallengePromptSuggestion
 * 
 */
export type DailyChallengePromptSuggestion = runtime.Types.DefaultSelection<DailyChallengePromptSuggestionPayload>

/**
 * Enums
 */

export const EnhancedDocumentRole: {
  OWNER: 'OWNER'
};

export type EnhancedDocumentRole = (typeof EnhancedDocumentRole)[keyof typeof EnhancedDocumentRole]


export const ChatMessageAuthor: {
  USER: 'USER',
  SYSTEM: 'SYSTEM'
};

export type ChatMessageAuthor = (typeof ChatMessageAuthor)[keyof typeof ChatMessageAuthor]


export const Role: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR',
  LEAD_REVIEWER: 'LEAD_REVIEWER',
  REVIEWER: 'REVIEWER'
};

export type Role = (typeof Role)[keyof typeof Role]


export const NoteRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  EDITOR: 'EDITOR'
};

export type NoteRole = (typeof NoteRole)[keyof typeof NoteRole]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.follows`: Exposes CRUD operations for the **Follows** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follows.findMany()
    * ```
    */
  get follows(): Prisma.FollowsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.NoteDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.documentVersion`: Exposes CRUD operations for the **DocumentVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentVersions
    * const documentVersions = await prisma.documentVersion.findMany()
    * ```
    */
  get documentVersion(): Prisma.DocumentVersionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userEnhancedDocumentPermissions`: Exposes CRUD operations for the **UserEnhancedDocumentPermissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserEnhancedDocumentPermissions
    * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.findMany()
    * ```
    */
  get userEnhancedDocumentPermissions(): Prisma.UserEnhancedDocumentPermissionsDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.enhancedDocument`: Exposes CRUD operations for the **EnhancedDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EnhancedDocuments
    * const enhancedDocuments = await prisma.enhancedDocument.findMany()
    * ```
    */
  get enhancedDocument(): Prisma.EnhancedDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.threadAttributes`: Exposes CRUD operations for the **ThreadAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreadAttributes
    * const threadAttributes = await prisma.threadAttributes.findMany()
    * ```
    */
  get threadAttributes(): Prisma.ThreadAttributesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.publishedDocument`: Exposes CRUD operations for the **PublishedDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublishedDocuments
    * const publishedDocuments = await prisma.publishedDocument.findMany()
    * ```
    */
  get publishedDocument(): Prisma.PublishedDocumentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.scratchpadEntry`: Exposes CRUD operations for the **ScratchpadEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScratchpadEntries
    * const scratchpadEntries = await prisma.scratchpadEntry.findMany()
    * ```
    */
  get scratchpadEntry(): Prisma.ScratchpadEntryDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userDocumentPermission`: Exposes CRUD operations for the **UserDocumentPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDocumentPermissions
    * const userDocumentPermissions = await prisma.userDocumentPermission.findMany()
    * ```
    */
  get userDocumentPermission(): Prisma.UserDocumentPermissionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userNotePermission`: Exposes CRUD operations for the **UserNotePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotePermissions
    * const userNotePermissions = await prisma.userNotePermission.findMany()
    * ```
    */
  get userNotePermission(): Prisma.UserNotePermissionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.userDocumentAttributes`: Exposes CRUD operations for the **UserDocumentAttributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDocumentAttributes
    * const userDocumentAttributes = await prisma.userDocumentAttributes.findMany()
    * ```
    */
  get userDocumentAttributes(): Prisma.UserDocumentAttributesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dailyStatUnit`: Exposes CRUD operations for the **DailyStatUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyStatUnits
    * const dailyStatUnits = await prisma.dailyStatUnit.findMany()
    * ```
    */
  get dailyStatUnit(): Prisma.DailyStatUnitDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.writingSession`: Exposes CRUD operations for the **WritingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WritingSessions
    * const writingSessions = await prisma.writingSession.findMany()
    * ```
    */
  get writingSession(): Prisma.WritingSessionDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dailyChallenge`: Exposes CRUD operations for the **DailyChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyChallenges
    * const dailyChallenges = await prisma.dailyChallenge.findMany()
    * ```
    */
  get dailyChallenge(): Prisma.DailyChallengeDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dailyChallengeResponseLikes`: Exposes CRUD operations for the **DailyChallengeResponseLikes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyChallengeResponseLikes
    * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.findMany()
    * ```
    */
  get dailyChallengeResponseLikes(): Prisma.DailyChallengeResponseLikesDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dailyChallengeResponse`: Exposes CRUD operations for the **DailyChallengeResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyChallengeResponses
    * const dailyChallengeResponses = await prisma.dailyChallengeResponse.findMany()
    * ```
    */
  get dailyChallengeResponse(): Prisma.DailyChallengeResponseDelegate<GlobalReject, ExtArgs>;

  /**
   * `prisma.dailyChallengePromptSuggestion`: Exposes CRUD operations for the **DailyChallengePromptSuggestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyChallengePromptSuggestions
    * const dailyChallengePromptSuggestions = await prisma.dailyChallengePromptSuggestion.findMany()
    * ```
    */
  get dailyChallengePromptSuggestion(): Prisma.DailyChallengePromptSuggestionDelegate<GlobalReject, ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 4.16.0
   * Query Engine version: b20ead4d3ab9e78ac112966e242ded703f4a052c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Follows: 'Follows',
    Note: 'Note',
    DocumentVersion: 'DocumentVersion',
    Document: 'Document',
    UserEnhancedDocumentPermissions: 'UserEnhancedDocumentPermissions',
    EnhancedDocument: 'EnhancedDocument',
    ThreadAttributes: 'ThreadAttributes',
    ChatMessage: 'ChatMessage',
    PublishedDocument: 'PublishedDocument',
    ScratchpadEntry: 'ScratchpadEntry',
    Comment: 'Comment',
    UserDocumentPermission: 'UserDocumentPermission',
    UserNotePermission: 'UserNotePermission',
    UserDocumentAttributes: 'UserDocumentAttributes',
    DailyStatUnit: 'DailyStatUnit',
    WritingSession: 'WritingSession',
    DailyChallenge: 'DailyChallenge',
    DailyChallengeResponseLikes: 'DailyChallengeResponseLikes',
    DailyChallengeResponse: 'DailyChallengeResponse',
    DailyChallengePromptSuggestion: 'DailyChallengePromptSuggestion'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
      meta: {
        modelProps: 'user' | 'follows' | 'note' | 'documentVersion' | 'document' | 'userEnhancedDocumentPermissions' | 'enhancedDocument' | 'threadAttributes' | 'chatMessage' | 'publishedDocument' | 'scratchpadEntry' | 'comment' | 'userDocumentPermission' | 'userNotePermission' | 'userDocumentAttributes' | 'dailyStatUnit' | 'writingSession' | 'dailyChallenge' | 'dailyChallengeResponseLikes' | 'dailyChallengeResponse' | 'dailyChallengePromptSuggestion'
        txIsolationLevel: Prisma.TransactionIsolationLevel
      },
      model: {
      User: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<User>
          payload: UserPayload<ExtArgs>
        }
      }
      Follows: {
        findUnique: {
          args: Prisma.FollowsFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.FollowsFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.FollowsFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.FollowsFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.FollowsFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        create: {
          args: Prisma.FollowsCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.FollowsCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        delete: {
          args: Prisma.FollowsDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        update: {
          args: Prisma.FollowsUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.FollowsDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.FollowsUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.FollowsUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.FollowsAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.FollowsGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
        count: {
          args: Prisma.FollowsCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Follows>
          payload: FollowsPayload<ExtArgs>
        }
      }
      Note: {
        findUnique: {
          args: Prisma.NoteFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.NoteFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.NoteFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.NoteFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        findMany: {
          args: Prisma.NoteFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        create: {
          args: Prisma.NoteCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        createMany: {
          args: Prisma.NoteCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        delete: {
          args: Prisma.NoteDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        update: {
          args: Prisma.NoteUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.NoteDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.NoteUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        upsert: {
          args: Prisma.NoteUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.NoteAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.NoteGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
        count: {
          args: Prisma.NoteCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Note>
          payload: NotePayload<ExtArgs>
        }
      }
      DocumentVersion: {
        findUnique: {
          args: Prisma.DocumentVersionFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentVersionFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.DocumentVersionFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.DocumentVersionFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.DocumentVersionFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        create: {
          args: Prisma.DocumentVersionCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.DocumentVersionCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        delete: {
          args: Prisma.DocumentVersionDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        update: {
          args: Prisma.DocumentVersionUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.DocumentVersionDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.DocumentVersionUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.DocumentVersionUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.DocumentVersionAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.DocumentVersionGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
        count: {
          args: Prisma.DocumentVersionCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DocumentVersion>
          payload: DocumentVersionPayload<ExtArgs>
        }
      }
      Document: {
        findUnique: {
          args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.DocumentFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.DocumentFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        create: {
          args: Prisma.DocumentCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.DocumentCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        delete: {
          args: Prisma.DocumentDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        update: {
          args: Prisma.DocumentUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.DocumentUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.DocumentAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.DocumentGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
        count: {
          args: Prisma.DocumentCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Document>
          payload: DocumentPayload<ExtArgs>
        }
      }
      UserEnhancedDocumentPermissions: {
        findUnique: {
          args: Prisma.UserEnhancedDocumentPermissionsFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.UserEnhancedDocumentPermissionsFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.UserEnhancedDocumentPermissionsFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.UserEnhancedDocumentPermissionsFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.UserEnhancedDocumentPermissionsFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        create: {
          args: Prisma.UserEnhancedDocumentPermissionsCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.UserEnhancedDocumentPermissionsCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        delete: {
          args: Prisma.UserEnhancedDocumentPermissionsDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        update: {
          args: Prisma.UserEnhancedDocumentPermissionsUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.UserEnhancedDocumentPermissionsDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.UserEnhancedDocumentPermissionsUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.UserEnhancedDocumentPermissionsUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.UserEnhancedDocumentPermissionsAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.UserEnhancedDocumentPermissionsGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
        count: {
          args: Prisma.UserEnhancedDocumentPermissionsCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserEnhancedDocumentPermissions>
          payload: UserEnhancedDocumentPermissionsPayload<ExtArgs>
        }
      }
      EnhancedDocument: {
        findUnique: {
          args: Prisma.EnhancedDocumentFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.EnhancedDocumentFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.EnhancedDocumentFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.EnhancedDocumentFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.EnhancedDocumentFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        create: {
          args: Prisma.EnhancedDocumentCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.EnhancedDocumentCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        delete: {
          args: Prisma.EnhancedDocumentDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        update: {
          args: Prisma.EnhancedDocumentUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.EnhancedDocumentDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.EnhancedDocumentUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.EnhancedDocumentUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.EnhancedDocumentAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.EnhancedDocumentGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
        count: {
          args: Prisma.EnhancedDocumentCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<EnhancedDocument>
          payload: EnhancedDocumentPayload<ExtArgs>
        }
      }
      ThreadAttributes: {
        findUnique: {
          args: Prisma.ThreadAttributesFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.ThreadAttributesFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.ThreadAttributesFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.ThreadAttributesFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.ThreadAttributesFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        create: {
          args: Prisma.ThreadAttributesCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.ThreadAttributesCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        delete: {
          args: Prisma.ThreadAttributesDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        update: {
          args: Prisma.ThreadAttributesUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.ThreadAttributesDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.ThreadAttributesUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.ThreadAttributesUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.ThreadAttributesAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.ThreadAttributesGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
        count: {
          args: Prisma.ThreadAttributesCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ThreadAttributes>
          payload: ThreadAttributesPayload<ExtArgs>
        }
      }
      ChatMessage: {
        findUnique: {
          args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.ChatMessageFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        findMany: {
          args: Prisma.ChatMessageFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        create: {
          args: Prisma.ChatMessageCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        createMany: {
          args: Prisma.ChatMessageCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        delete: {
          args: Prisma.ChatMessageDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        update: {
          args: Prisma.ChatMessageUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        upsert: {
          args: Prisma.ChatMessageUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.ChatMessageAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.ChatMessageGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
        count: {
          args: Prisma.ChatMessageCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ChatMessage>
          payload: ChatMessagePayload<ExtArgs>
        }
      }
      PublishedDocument: {
        findUnique: {
          args: Prisma.PublishedDocumentFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.PublishedDocumentFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.PublishedDocumentFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.PublishedDocumentFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.PublishedDocumentFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        create: {
          args: Prisma.PublishedDocumentCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.PublishedDocumentCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        delete: {
          args: Prisma.PublishedDocumentDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        update: {
          args: Prisma.PublishedDocumentUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.PublishedDocumentDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.PublishedDocumentUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.PublishedDocumentUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.PublishedDocumentAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.PublishedDocumentGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
        count: {
          args: Prisma.PublishedDocumentCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<PublishedDocument>
          payload: PublishedDocumentPayload<ExtArgs>
        }
      }
      ScratchpadEntry: {
        findUnique: {
          args: Prisma.ScratchpadEntryFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.ScratchpadEntryFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.ScratchpadEntryFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.ScratchpadEntryFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.ScratchpadEntryFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        create: {
          args: Prisma.ScratchpadEntryCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.ScratchpadEntryCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        delete: {
          args: Prisma.ScratchpadEntryDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        update: {
          args: Prisma.ScratchpadEntryUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.ScratchpadEntryDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.ScratchpadEntryUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.ScratchpadEntryUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.ScratchpadEntryAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.ScratchpadEntryGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
        count: {
          args: Prisma.ScratchpadEntryCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<ScratchpadEntry>
          payload: ScratchpadEntryPayload<ExtArgs>
        }
      }
      Comment: {
        findUnique: {
          args: Prisma.CommentFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.CommentFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.CommentFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        create: {
          args: Prisma.CommentCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.CommentCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        delete: {
          args: Prisma.CommentDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        update: {
          args: Prisma.CommentUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.CommentDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.CommentUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.CommentUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.CommentAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.CommentGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
        count: {
          args: Prisma.CommentCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<Comment>
          payload: CommentPayload<ExtArgs>
        }
      }
      UserDocumentPermission: {
        findUnique: {
          args: Prisma.UserDocumentPermissionFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.UserDocumentPermissionFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.UserDocumentPermissionFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.UserDocumentPermissionFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.UserDocumentPermissionFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        create: {
          args: Prisma.UserDocumentPermissionCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.UserDocumentPermissionCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        delete: {
          args: Prisma.UserDocumentPermissionDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        update: {
          args: Prisma.UserDocumentPermissionUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.UserDocumentPermissionDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.UserDocumentPermissionUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.UserDocumentPermissionUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.UserDocumentPermissionAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.UserDocumentPermissionGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
        count: {
          args: Prisma.UserDocumentPermissionCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentPermission>
          payload: UserDocumentPermissionPayload<ExtArgs>
        }
      }
      UserNotePermission: {
        findUnique: {
          args: Prisma.UserNotePermissionFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.UserNotePermissionFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.UserNotePermissionFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.UserNotePermissionFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.UserNotePermissionFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        create: {
          args: Prisma.UserNotePermissionCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.UserNotePermissionCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        delete: {
          args: Prisma.UserNotePermissionDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        update: {
          args: Prisma.UserNotePermissionUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.UserNotePermissionDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.UserNotePermissionUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.UserNotePermissionUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.UserNotePermissionAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.UserNotePermissionGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
        count: {
          args: Prisma.UserNotePermissionCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserNotePermission>
          payload: UserNotePermissionPayload<ExtArgs>
        }
      }
      UserDocumentAttributes: {
        findUnique: {
          args: Prisma.UserDocumentAttributesFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.UserDocumentAttributesFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.UserDocumentAttributesFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.UserDocumentAttributesFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.UserDocumentAttributesFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        create: {
          args: Prisma.UserDocumentAttributesCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.UserDocumentAttributesCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        delete: {
          args: Prisma.UserDocumentAttributesDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        update: {
          args: Prisma.UserDocumentAttributesUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.UserDocumentAttributesDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.UserDocumentAttributesUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.UserDocumentAttributesUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.UserDocumentAttributesAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.UserDocumentAttributesGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
        count: {
          args: Prisma.UserDocumentAttributesCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<UserDocumentAttributes>
          payload: UserDocumentAttributesPayload<ExtArgs>
        }
      }
      DailyStatUnit: {
        findUnique: {
          args: Prisma.DailyStatUnitFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.DailyStatUnitFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.DailyStatUnitFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.DailyStatUnitFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.DailyStatUnitFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        create: {
          args: Prisma.DailyStatUnitCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.DailyStatUnitCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        delete: {
          args: Prisma.DailyStatUnitDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        update: {
          args: Prisma.DailyStatUnitUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.DailyStatUnitDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.DailyStatUnitUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.DailyStatUnitUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.DailyStatUnitAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.DailyStatUnitGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
        count: {
          args: Prisma.DailyStatUnitCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyStatUnit>
          payload: DailyStatUnitPayload<ExtArgs>
        }
      }
      WritingSession: {
        findUnique: {
          args: Prisma.WritingSessionFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.WritingSessionFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.WritingSessionFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.WritingSessionFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.WritingSessionFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        create: {
          args: Prisma.WritingSessionCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.WritingSessionCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        delete: {
          args: Prisma.WritingSessionDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        update: {
          args: Prisma.WritingSessionUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.WritingSessionDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.WritingSessionUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.WritingSessionUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.WritingSessionAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.WritingSessionGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
        count: {
          args: Prisma.WritingSessionCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<WritingSession>
          payload: WritingSessionPayload<ExtArgs>
        }
      }
      DailyChallenge: {
        findUnique: {
          args: Prisma.DailyChallengeFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.DailyChallengeFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.DailyChallengeFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.DailyChallengeFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        findMany: {
          args: Prisma.DailyChallengeFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        create: {
          args: Prisma.DailyChallengeCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        createMany: {
          args: Prisma.DailyChallengeCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        delete: {
          args: Prisma.DailyChallengeDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        update: {
          args: Prisma.DailyChallengeUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.DailyChallengeDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.DailyChallengeUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        upsert: {
          args: Prisma.DailyChallengeUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.DailyChallengeAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.DailyChallengeGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
        count: {
          args: Prisma.DailyChallengeCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallenge>
          payload: DailyChallengePayload<ExtArgs>
        }
      }
      DailyChallengeResponseLikes: {
        findUnique: {
          args: Prisma.DailyChallengeResponseLikesFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.DailyChallengeResponseLikesFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.DailyChallengeResponseLikesFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.DailyChallengeResponseLikesFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.DailyChallengeResponseLikesFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        create: {
          args: Prisma.DailyChallengeResponseLikesCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.DailyChallengeResponseLikesCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        delete: {
          args: Prisma.DailyChallengeResponseLikesDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        update: {
          args: Prisma.DailyChallengeResponseLikesUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.DailyChallengeResponseLikesDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.DailyChallengeResponseLikesUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.DailyChallengeResponseLikesUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.DailyChallengeResponseLikesAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.DailyChallengeResponseLikesGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
        count: {
          args: Prisma.DailyChallengeResponseLikesCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponseLikes>
          payload: DailyChallengeResponseLikesPayload<ExtArgs>
        }
      }
      DailyChallengeResponse: {
        findUnique: {
          args: Prisma.DailyChallengeResponseFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.DailyChallengeResponseFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.DailyChallengeResponseFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.DailyChallengeResponseFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        findMany: {
          args: Prisma.DailyChallengeResponseFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        create: {
          args: Prisma.DailyChallengeResponseCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        createMany: {
          args: Prisma.DailyChallengeResponseCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        delete: {
          args: Prisma.DailyChallengeResponseDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        update: {
          args: Prisma.DailyChallengeResponseUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.DailyChallengeResponseDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.DailyChallengeResponseUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        upsert: {
          args: Prisma.DailyChallengeResponseUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.DailyChallengeResponseAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.DailyChallengeResponseGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
        count: {
          args: Prisma.DailyChallengeResponseCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengeResponse>
          payload: DailyChallengeResponsePayload<ExtArgs>
        }
      }
      DailyChallengePromptSuggestion: {
        findUnique: {
          args: Prisma.DailyChallengePromptSuggestionFindUniqueArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        findUniqueOrThrow: {
          args: Prisma.DailyChallengePromptSuggestionFindUniqueOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        findFirst: {
          args: Prisma.DailyChallengePromptSuggestionFindFirstArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        findFirstOrThrow: {
          args: Prisma.DailyChallengePromptSuggestionFindFirstOrThrowArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        findMany: {
          args: Prisma.DailyChallengePromptSuggestionFindManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        create: {
          args: Prisma.DailyChallengePromptSuggestionCreateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        createMany: {
          args: Prisma.DailyChallengePromptSuggestionCreateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        delete: {
          args: Prisma.DailyChallengePromptSuggestionDeleteArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        update: {
          args: Prisma.DailyChallengePromptSuggestionUpdateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        deleteMany: {
          args: Prisma.DailyChallengePromptSuggestionDeleteManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        updateMany: {
          args: Prisma.DailyChallengePromptSuggestionUpdateManyArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        upsert: {
          args: Prisma.DailyChallengePromptSuggestionUpsertArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        aggregate: {
          args: Prisma.DailyChallengePromptSuggestionAggregateArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        groupBy: {
          args: Prisma.DailyChallengePromptSuggestionGroupByArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
        count: {
          args: Prisma.DailyChallengePromptSuggestionCountArgs<ExtArgs>,
          result: $Utils.OptionalFlat<DailyChallengePromptSuggestion>
          payload: DailyChallengePromptSuggestionPayload<ExtArgs>
        }
      }
    }
  } & {
    other: {
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
        payload: any
      }
      $executeRaw: {
        args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
        result: any
        payload: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
        payload: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
        result: any
        payload: any
      }
    }
  }
    export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    comments: number
    userDocumentPermissions: number
    userNotePermission: number
    statUnit: number
    scratchpadEntry: number
    userDocumentAttributes: number
    dailyChallengeResponse: number
    dailyChallengeResponseLikes: number
    dailyChallengePromptSuggestion: number
    followedBy: number
    following: number
    PublishedDocument: number
    publishedDocumentLikes: number
    writingSessions: number
    writingSessionLikes: number
    userEnhancedDocumentPermissions: number
    threadAttributes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    userDocumentPermissions?: boolean | UserCountOutputTypeCountUserDocumentPermissionsArgs
    userNotePermission?: boolean | UserCountOutputTypeCountUserNotePermissionArgs
    statUnit?: boolean | UserCountOutputTypeCountStatUnitArgs
    scratchpadEntry?: boolean | UserCountOutputTypeCountScratchpadEntryArgs
    userDocumentAttributes?: boolean | UserCountOutputTypeCountUserDocumentAttributesArgs
    dailyChallengeResponse?: boolean | UserCountOutputTypeCountDailyChallengeResponseArgs
    dailyChallengeResponseLikes?: boolean | UserCountOutputTypeCountDailyChallengeResponseLikesArgs
    dailyChallengePromptSuggestion?: boolean | UserCountOutputTypeCountDailyChallengePromptSuggestionArgs
    followedBy?: boolean | UserCountOutputTypeCountFollowedByArgs
    following?: boolean | UserCountOutputTypeCountFollowingArgs
    PublishedDocument?: boolean | UserCountOutputTypeCountPublishedDocumentArgs
    publishedDocumentLikes?: boolean | UserCountOutputTypeCountPublishedDocumentLikesArgs
    writingSessions?: boolean | UserCountOutputTypeCountWritingSessionsArgs
    writingSessionLikes?: boolean | UserCountOutputTypeCountWritingSessionLikesArgs
    userEnhancedDocumentPermissions?: boolean | UserCountOutputTypeCountUserEnhancedDocumentPermissionsArgs
    threadAttributes?: boolean | UserCountOutputTypeCountThreadAttributesArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentPermissionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserNotePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserNotePermissionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStatUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyStatUnitWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountScratchpadEntryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ScratchpadEntryWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserDocumentAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentAttributesWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyChallengeResponseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengeResponseWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyChallengeResponseLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengeResponseLikesWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyChallengePromptSuggestionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengePromptSuggestionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowedByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FollowsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FollowsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublishedDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PublishedDocumentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublishedDocumentLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PublishedDocumentWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWritingSessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WritingSessionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWritingSessionLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WritingSessionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserEnhancedDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserEnhancedDocumentPermissionsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountThreadAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ThreadAttributesWhereInput
  }



  /**
   * Count Type NoteCountOutputType
   */


  export type NoteCountOutputType = {
    userNotePermissions: number
  }

  export type NoteCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userNotePermissions?: boolean | NoteCountOutputTypeCountUserNotePermissionsArgs
  }

  // Custom InputTypes

  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteCountOutputType
     */
    select?: NoteCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeCountUserNotePermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserNotePermissionWhereInput
  }



  /**
   * Count Type DocumentVersionCountOutputType
   */


  export type DocumentVersionCountOutputType = {
    comments: number
    userDocumentPermissions: number
    statUnit: number
    userDocumentAttributes: number
  }

  export type DocumentVersionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | DocumentVersionCountOutputTypeCountCommentsArgs
    userDocumentPermissions?: boolean | DocumentVersionCountOutputTypeCountUserDocumentPermissionsArgs
    statUnit?: boolean | DocumentVersionCountOutputTypeCountStatUnitArgs
    userDocumentAttributes?: boolean | DocumentVersionCountOutputTypeCountUserDocumentAttributesArgs
  }

  // Custom InputTypes

  /**
   * DocumentVersionCountOutputType without action
   */
  export type DocumentVersionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersionCountOutputType
     */
    select?: DocumentVersionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DocumentVersionCountOutputType without action
   */
  export type DocumentVersionCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * DocumentVersionCountOutputType without action
   */
  export type DocumentVersionCountOutputTypeCountUserDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentPermissionWhereInput
  }


  /**
   * DocumentVersionCountOutputType without action
   */
  export type DocumentVersionCountOutputTypeCountStatUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyStatUnitWhereInput
  }


  /**
   * DocumentVersionCountOutputType without action
   */
  export type DocumentVersionCountOutputTypeCountUserDocumentAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentAttributesWhereInput
  }



  /**
   * Count Type DocumentCountOutputType
   */


  export type DocumentCountOutputType = {
    documentVersions: number
    userDocumentPermissions: number
    notes: number
    statUnit: number
    userDocumentAttributes: number
    PublishedDocument: number
    WritingSession: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documentVersions?: boolean | DocumentCountOutputTypeCountDocumentVersionsArgs
    userDocumentPermissions?: boolean | DocumentCountOutputTypeCountUserDocumentPermissionsArgs
    notes?: boolean | DocumentCountOutputTypeCountNotesArgs
    statUnit?: boolean | DocumentCountOutputTypeCountStatUnitArgs
    userDocumentAttributes?: boolean | DocumentCountOutputTypeCountUserDocumentAttributesArgs
    PublishedDocument?: boolean | DocumentCountOutputTypeCountPublishedDocumentArgs
    WritingSession?: boolean | DocumentCountOutputTypeCountWritingSessionArgs
  }

  // Custom InputTypes

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountDocumentVersionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountUserDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentPermissionWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountStatUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyStatUnitWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountUserDocumentAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentAttributesWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountPublishedDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PublishedDocumentWhereInput
  }


  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountWritingSessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WritingSessionWhereInput
  }



  /**
   * Count Type EnhancedDocumentCountOutputType
   */


  export type EnhancedDocumentCountOutputType = {
    userEnhancedDocumentPermissions: number
    threadAttributes: number
  }

  export type EnhancedDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userEnhancedDocumentPermissions?: boolean | EnhancedDocumentCountOutputTypeCountUserEnhancedDocumentPermissionsArgs
    threadAttributes?: boolean | EnhancedDocumentCountOutputTypeCountThreadAttributesArgs
  }

  // Custom InputTypes

  /**
   * EnhancedDocumentCountOutputType without action
   */
  export type EnhancedDocumentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocumentCountOutputType
     */
    select?: EnhancedDocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EnhancedDocumentCountOutputType without action
   */
  export type EnhancedDocumentCountOutputTypeCountUserEnhancedDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserEnhancedDocumentPermissionsWhereInput
  }


  /**
   * EnhancedDocumentCountOutputType without action
   */
  export type EnhancedDocumentCountOutputTypeCountThreadAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ThreadAttributesWhereInput
  }



  /**
   * Count Type ThreadAttributesCountOutputType
   */


  export type ThreadAttributesCountOutputType = {
    chatMessage: number
  }

  export type ThreadAttributesCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    chatMessage?: boolean | ThreadAttributesCountOutputTypeCountChatMessageArgs
  }

  // Custom InputTypes

  /**
   * ThreadAttributesCountOutputType without action
   */
  export type ThreadAttributesCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributesCountOutputType
     */
    select?: ThreadAttributesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ThreadAttributesCountOutputType without action
   */
  export type ThreadAttributesCountOutputTypeCountChatMessageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }



  /**
   * Count Type PublishedDocumentCountOutputType
   */


  export type PublishedDocumentCountOutputType = {
    likingUsers: number
  }

  export type PublishedDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    likingUsers?: boolean | PublishedDocumentCountOutputTypeCountLikingUsersArgs
  }

  // Custom InputTypes

  /**
   * PublishedDocumentCountOutputType without action
   */
  export type PublishedDocumentCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocumentCountOutputType
     */
    select?: PublishedDocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PublishedDocumentCountOutputType without action
   */
  export type PublishedDocumentCountOutputTypeCountLikingUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type WritingSessionCountOutputType
   */


  export type WritingSessionCountOutputType = {
    likes: number
  }

  export type WritingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    likes?: boolean | WritingSessionCountOutputTypeCountLikesArgs
  }

  // Custom InputTypes

  /**
   * WritingSessionCountOutputType without action
   */
  export type WritingSessionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSessionCountOutputType
     */
    select?: WritingSessionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * WritingSessionCountOutputType without action
   */
  export type WritingSessionCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }



  /**
   * Count Type DailyChallengeCountOutputType
   */


  export type DailyChallengeCountOutputType = {
    dailyChallengeResponse: number
  }

  export type DailyChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dailyChallengeResponse?: boolean | DailyChallengeCountOutputTypeCountDailyChallengeResponseArgs
  }

  // Custom InputTypes

  /**
   * DailyChallengeCountOutputType without action
   */
  export type DailyChallengeCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeCountOutputType
     */
    select?: DailyChallengeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DailyChallengeCountOutputType without action
   */
  export type DailyChallengeCountOutputTypeCountDailyChallengeResponseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengeResponseWhereInput
  }



  /**
   * Count Type DailyChallengeResponseCountOutputType
   */


  export type DailyChallengeResponseCountOutputType = {
    likes: number
    dailyStatUnit: number
  }

  export type DailyChallengeResponseCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    likes?: boolean | DailyChallengeResponseCountOutputTypeCountLikesArgs
    dailyStatUnit?: boolean | DailyChallengeResponseCountOutputTypeCountDailyStatUnitArgs
  }

  // Custom InputTypes

  /**
   * DailyChallengeResponseCountOutputType without action
   */
  export type DailyChallengeResponseCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseCountOutputType
     */
    select?: DailyChallengeResponseCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DailyChallengeResponseCountOutputType without action
   */
  export type DailyChallengeResponseCountOutputTypeCountLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengeResponseLikesWhereInput
  }


  /**
   * DailyChallengeResponseCountOutputType without action
   */
  export type DailyChallengeResponseCountOutputTypeCountDailyStatUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyStatUnitWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    longestStreak: number | null
    openAIAPICalls: number | null
  }

  export type UserSumAggregateOutputType = {
    longestStreak: number | null
    openAIAPICalls: number | null
  }

  export type UserMinAggregateOutputType = {
    userID: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    longestStreak: number | null
    bio: string | null
    city: string | null
    country: string | null
    website: string | null
    twitter: string | null
    instagram: string | null
    createdAt: Date | null
    openAIAPICalls: number | null
  }

  export type UserMaxAggregateOutputType = {
    userID: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    longestStreak: number | null
    bio: string | null
    city: string | null
    country: string | null
    website: string | null
    twitter: string | null
    instagram: string | null
    createdAt: Date | null
    openAIAPICalls: number | null
  }

  export type UserCountAggregateOutputType = {
    userID: number
    username: number
    appDrawerNoteIDs: number
    firstName: number
    lastName: number
    email: number
    longestStreak: number
    bio: number
    city: number
    country: number
    website: number
    twitter: number
    instagram: number
    createdAt: number
    openAIAPICalls: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    longestStreak?: true
    openAIAPICalls?: true
  }

  export type UserSumAggregateInputType = {
    longestStreak?: true
    openAIAPICalls?: true
  }

  export type UserMinAggregateInputType = {
    userID?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    longestStreak?: true
    bio?: true
    city?: true
    country?: true
    website?: true
    twitter?: true
    instagram?: true
    createdAt?: true
    openAIAPICalls?: true
  }

  export type UserMaxAggregateInputType = {
    userID?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    longestStreak?: true
    bio?: true
    city?: true
    country?: true
    website?: true
    twitter?: true
    instagram?: true
    createdAt?: true
    openAIAPICalls?: true
  }

  export type UserCountAggregateInputType = {
    userID?: true
    username?: true
    appDrawerNoteIDs?: true
    firstName?: true
    lastName?: true
    email?: true
    longestStreak?: true
    bio?: true
    city?: true
    country?: true
    website?: true
    twitter?: true
    instagram?: true
    createdAt?: true
    openAIAPICalls?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    userID: string
    username: string | null
    appDrawerNoteIDs: string[]
    firstName: string | null
    lastName: string | null
    email: string
    longestStreak: number
    bio: string | null
    city: string | null
    country: string | null
    website: string | null
    twitter: string | null
    instagram: string | null
    createdAt: Date
    openAIAPICalls: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userID?: boolean
    username?: boolean
    appDrawerNoteIDs?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    longestStreak?: boolean
    bio?: boolean
    city?: boolean
    country?: boolean
    website?: boolean
    twitter?: boolean
    instagram?: boolean
    createdAt?: boolean
    openAIAPICalls?: boolean
    comments?: boolean | User$commentsArgs<ExtArgs>
    userDocumentPermissions?: boolean | User$userDocumentPermissionsArgs<ExtArgs>
    userNotePermission?: boolean | User$userNotePermissionArgs<ExtArgs>
    statUnit?: boolean | User$statUnitArgs<ExtArgs>
    scratchpadEntry?: boolean | User$scratchpadEntryArgs<ExtArgs>
    userDocumentAttributes?: boolean | User$userDocumentAttributesArgs<ExtArgs>
    dailyChallengeResponse?: boolean | User$dailyChallengeResponseArgs<ExtArgs>
    dailyChallengeResponseLikes?: boolean | User$dailyChallengeResponseLikesArgs<ExtArgs>
    dailyChallengePromptSuggestion?: boolean | User$dailyChallengePromptSuggestionArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    PublishedDocument?: boolean | User$PublishedDocumentArgs<ExtArgs>
    publishedDocumentLikes?: boolean | User$publishedDocumentLikesArgs<ExtArgs>
    writingSessions?: boolean | User$writingSessionsArgs<ExtArgs>
    writingSessionLikes?: boolean | User$writingSessionLikesArgs<ExtArgs>
    userEnhancedDocumentPermissions?: boolean | User$userEnhancedDocumentPermissionsArgs<ExtArgs>
    threadAttributes?: boolean | User$threadAttributesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    userID?: boolean
    username?: boolean
    appDrawerNoteIDs?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    longestStreak?: boolean
    bio?: boolean
    city?: boolean
    country?: boolean
    website?: boolean
    twitter?: boolean
    instagram?: boolean
    createdAt?: boolean
    openAIAPICalls?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | User$commentsArgs<ExtArgs>
    userDocumentPermissions?: boolean | User$userDocumentPermissionsArgs<ExtArgs>
    userNotePermission?: boolean | User$userNotePermissionArgs<ExtArgs>
    statUnit?: boolean | User$statUnitArgs<ExtArgs>
    scratchpadEntry?: boolean | User$scratchpadEntryArgs<ExtArgs>
    userDocumentAttributes?: boolean | User$userDocumentAttributesArgs<ExtArgs>
    dailyChallengeResponse?: boolean | User$dailyChallengeResponseArgs<ExtArgs>
    dailyChallengeResponseLikes?: boolean | User$dailyChallengeResponseLikesArgs<ExtArgs>
    dailyChallengePromptSuggestion?: boolean | User$dailyChallengePromptSuggestionArgs<ExtArgs>
    followedBy?: boolean | User$followedByArgs<ExtArgs>
    following?: boolean | User$followingArgs<ExtArgs>
    PublishedDocument?: boolean | User$PublishedDocumentArgs<ExtArgs>
    publishedDocumentLikes?: boolean | User$publishedDocumentLikesArgs<ExtArgs>
    writingSessions?: boolean | User$writingSessionsArgs<ExtArgs>
    writingSessionLikes?: boolean | User$writingSessionLikesArgs<ExtArgs>
    userEnhancedDocumentPermissions?: boolean | User$userEnhancedDocumentPermissionsArgs<ExtArgs>
    threadAttributes?: boolean | User$threadAttributesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeArgs<ExtArgs>
  }


  type UserGetPayload<S extends boolean | null | undefined | UserArgs> = $Types.GetResult<UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const userWithUserIDOnly = await prisma.user.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userDocumentPermissions<T extends User$userDocumentPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userDocumentPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userNotePermission<T extends User$userNotePermissionArgs<ExtArgs> = {}>(args?: Subset<T, User$userNotePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    statUnit<T extends User$statUnitArgs<ExtArgs> = {}>(args?: Subset<T, User$statUnitArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findMany', never>| Null>;

    scratchpadEntry<T extends User$scratchpadEntryArgs<ExtArgs> = {}>(args?: Subset<T, User$scratchpadEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userDocumentAttributes<T extends User$userDocumentAttributesArgs<ExtArgs> = {}>(args?: Subset<T, User$userDocumentAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    dailyChallengeResponse<T extends User$dailyChallengeResponseArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyChallengeResponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findMany', never>| Null>;

    dailyChallengeResponseLikes<T extends User$dailyChallengeResponseLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyChallengeResponseLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    dailyChallengePromptSuggestion<T extends User$dailyChallengePromptSuggestionArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyChallengePromptSuggestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    followedBy<T extends User$followedByArgs<ExtArgs> = {}>(args?: Subset<T, User$followedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    following<T extends User$followingArgs<ExtArgs> = {}>(args?: Subset<T, User$followingArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    PublishedDocument<T extends User$PublishedDocumentArgs<ExtArgs> = {}>(args?: Subset<T, User$PublishedDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    publishedDocumentLikes<T extends User$publishedDocumentLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$publishedDocumentLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    writingSessions<T extends User$writingSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$writingSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    writingSessionLikes<T extends User$writingSessionLikesArgs<ExtArgs> = {}>(args?: Subset<T, User$writingSessionLikesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userEnhancedDocumentPermissions<T extends User$userEnhancedDocumentPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userEnhancedDocumentPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    threadAttributes<T extends User$threadAttributesArgs<ExtArgs> = {}>(args?: Subset<T, User$threadAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * User.userDocumentPermissions
   */
  export type User$userDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    where?: UserDocumentPermissionWhereInput
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithRelationInput>
    cursor?: UserDocumentPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDocumentPermissionScalarFieldEnum>
  }


  /**
   * User.userNotePermission
   */
  export type User$userNotePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    where?: UserNotePermissionWhereInput
    orderBy?: Enumerable<UserNotePermissionOrderByWithRelationInput>
    cursor?: UserNotePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserNotePermissionScalarFieldEnum>
  }


  /**
   * User.statUnit
   */
  export type User$statUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    where?: DailyStatUnitWhereInput
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    cursor?: DailyStatUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyStatUnitScalarFieldEnum>
  }


  /**
   * User.scratchpadEntry
   */
  export type User$scratchpadEntryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    where?: ScratchpadEntryWhereInput
    orderBy?: Enumerable<ScratchpadEntryOrderByWithRelationInput>
    cursor?: ScratchpadEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ScratchpadEntryScalarFieldEnum>
  }


  /**
   * User.userDocumentAttributes
   */
  export type User$userDocumentAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    where?: UserDocumentAttributesWhereInput
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithRelationInput>
    cursor?: UserDocumentAttributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDocumentAttributesScalarFieldEnum>
  }


  /**
   * User.dailyChallengeResponse
   */
  export type User$dailyChallengeResponseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    where?: DailyChallengeResponseWhereInput
    orderBy?: Enumerable<DailyChallengeResponseOrderByWithRelationInput>
    cursor?: DailyChallengeResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyChallengeResponseScalarFieldEnum>
  }


  /**
   * User.dailyChallengeResponseLikes
   */
  export type User$dailyChallengeResponseLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    where?: DailyChallengeResponseLikesWhereInput
    orderBy?: Enumerable<DailyChallengeResponseLikesOrderByWithRelationInput>
    cursor?: DailyChallengeResponseLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyChallengeResponseLikesScalarFieldEnum>
  }


  /**
   * User.dailyChallengePromptSuggestion
   */
  export type User$dailyChallengePromptSuggestionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    where?: DailyChallengePromptSuggestionWhereInput
    orderBy?: Enumerable<DailyChallengePromptSuggestionOrderByWithRelationInput>
    cursor?: DailyChallengePromptSuggestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyChallengePromptSuggestionScalarFieldEnum>
  }


  /**
   * User.followedBy
   */
  export type User$followedByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    where?: FollowsWhereInput
    orderBy?: Enumerable<FollowsOrderByWithRelationInput>
    cursor?: FollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FollowsScalarFieldEnum>
  }


  /**
   * User.following
   */
  export type User$followingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    where?: FollowsWhereInput
    orderBy?: Enumerable<FollowsOrderByWithRelationInput>
    cursor?: FollowsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FollowsScalarFieldEnum>
  }


  /**
   * User.PublishedDocument
   */
  export type User$PublishedDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    where?: PublishedDocumentWhereInput
    orderBy?: Enumerable<PublishedDocumentOrderByWithRelationInput>
    cursor?: PublishedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublishedDocumentScalarFieldEnum>
  }


  /**
   * User.publishedDocumentLikes
   */
  export type User$publishedDocumentLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    where?: PublishedDocumentWhereInput
    orderBy?: Enumerable<PublishedDocumentOrderByWithRelationInput>
    cursor?: PublishedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublishedDocumentScalarFieldEnum>
  }


  /**
   * User.writingSessions
   */
  export type User$writingSessionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    where?: WritingSessionWhereInput
    orderBy?: Enumerable<WritingSessionOrderByWithRelationInput>
    cursor?: WritingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WritingSessionScalarFieldEnum>
  }


  /**
   * User.writingSessionLikes
   */
  export type User$writingSessionLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    where?: WritingSessionWhereInput
    orderBy?: Enumerable<WritingSessionOrderByWithRelationInput>
    cursor?: WritingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WritingSessionScalarFieldEnum>
  }


  /**
   * User.userEnhancedDocumentPermissions
   */
  export type User$userEnhancedDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    where?: UserEnhancedDocumentPermissionsWhereInput
    orderBy?: Enumerable<UserEnhancedDocumentPermissionsOrderByWithRelationInput>
    cursor?: UserEnhancedDocumentPermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserEnhancedDocumentPermissionsScalarFieldEnum>
  }


  /**
   * User.threadAttributes
   */
  export type User$threadAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    where?: ThreadAttributesWhereInput
    orderBy?: Enumerable<ThreadAttributesOrderByWithRelationInput>
    cursor?: ThreadAttributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ThreadAttributesScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Follows
   */


  export type AggregateFollows = {
    _count: FollowsCountAggregateOutputType | null
    _min: FollowsMinAggregateOutputType | null
    _max: FollowsMaxAggregateOutputType | null
  }

  export type FollowsMinAggregateOutputType = {
    followerID: string | null
    followingID: string | null
  }

  export type FollowsMaxAggregateOutputType = {
    followerID: string | null
    followingID: string | null
  }

  export type FollowsCountAggregateOutputType = {
    followerID: number
    followingID: number
    _all: number
  }


  export type FollowsMinAggregateInputType = {
    followerID?: true
    followingID?: true
  }

  export type FollowsMaxAggregateInputType = {
    followerID?: true
    followingID?: true
  }

  export type FollowsCountAggregateInputType = {
    followerID?: true
    followingID?: true
    _all?: true
  }

  export type FollowsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to aggregate.
     */
    where?: FollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: Enumerable<FollowsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowsMaxAggregateInputType
  }

  export type GetFollowsAggregateType<T extends FollowsAggregateArgs> = {
        [P in keyof T & keyof AggregateFollows]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollows[P]>
      : GetScalarType<T[P], AggregateFollows[P]>
  }




  export type FollowsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FollowsWhereInput
    orderBy?: Enumerable<FollowsOrderByWithAggregationInput>
    by: FollowsScalarFieldEnum[]
    having?: FollowsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowsCountAggregateInputType | true
    _min?: FollowsMinAggregateInputType
    _max?: FollowsMaxAggregateInputType
  }


  export type FollowsGroupByOutputType = {
    followerID: string
    followingID: string
    _count: FollowsCountAggregateOutputType | null
    _min: FollowsMinAggregateOutputType | null
    _max: FollowsMaxAggregateOutputType | null
  }

  type GetFollowsGroupByPayload<T extends FollowsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FollowsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowsGroupByOutputType[P]>
            : GetScalarType<T[P], FollowsGroupByOutputType[P]>
        }
      >
    >


  export type FollowsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    followerID?: boolean
    followingID?: boolean
    follower?: boolean | UserArgs<ExtArgs>
    following?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["follows"]>

  export type FollowsSelectScalar = {
    followerID?: boolean
    followingID?: boolean
  }

  export type FollowsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    follower?: boolean | UserArgs<ExtArgs>
    following?: boolean | UserArgs<ExtArgs>
  }


  type FollowsGetPayload<S extends boolean | null | undefined | FollowsArgs> = $Types.GetResult<FollowsPayload, S>

  type FollowsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FollowsFindManyArgs, 'select' | 'include'> & {
      select?: FollowsCountAggregateInputType | true
    }

  export interface FollowsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follows'], meta: { name: 'Follows' } }
    /**
     * Find zero or one Follows that matches the filter.
     * @param {FollowsFindUniqueArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FollowsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FollowsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Follows'> extends True ? Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Follows that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FollowsFindUniqueOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FollowsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsFindFirstArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FollowsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FollowsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Follows'> extends True ? Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Follows that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsFindFirstOrThrowArgs} args - Arguments to find a Follows
     * @example
     * // Get one Follows
     * const follows = await prisma.follows.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FollowsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follows.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follows.findMany({ take: 10 })
     * 
     * // Only select the `followerID`
     * const followsWithFollowerIDOnly = await prisma.follows.findMany({ select: { followerID: true } })
     * 
    **/
    findMany<T extends FollowsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Follows.
     * @param {FollowsCreateArgs} args - Arguments to create a Follows.
     * @example
     * // Create one Follows
     * const Follows = await prisma.follows.create({
     *   data: {
     *     // ... data to create a Follows
     *   }
     * })
     * 
    **/
    create<T extends FollowsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowsCreateArgs<ExtArgs>>
    ): Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Follows.
     *     @param {FollowsCreateManyArgs} args - Arguments to create many Follows.
     *     @example
     *     // Create many Follows
     *     const follows = await prisma.follows.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FollowsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follows.
     * @param {FollowsDeleteArgs} args - Arguments to delete one Follows.
     * @example
     * // Delete one Follows
     * const Follows = await prisma.follows.delete({
     *   where: {
     *     // ... filter to delete one Follows
     *   }
     * })
     * 
    **/
    delete<T extends FollowsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FollowsDeleteArgs<ExtArgs>>
    ): Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Follows.
     * @param {FollowsUpdateArgs} args - Arguments to update one Follows.
     * @example
     * // Update one Follows
     * const follows = await prisma.follows.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FollowsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowsUpdateArgs<ExtArgs>>
    ): Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Follows.
     * @param {FollowsDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follows.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FollowsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follows = await prisma.follows.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FollowsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FollowsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follows.
     * @param {FollowsUpsertArgs} args - Arguments to update or create a Follows.
     * @example
     * // Update or create a Follows
     * const follows = await prisma.follows.upsert({
     *   create: {
     *     // ... data to create a Follows
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follows we want to update
     *   }
     * })
    **/
    upsert<T extends FollowsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FollowsUpsertArgs<ExtArgs>>
    ): Prisma__FollowsClient<$Types.GetResult<FollowsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follows.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowsCountArgs>(
      args?: Subset<T, FollowsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowsAggregateArgs>(args: Subset<T, FollowsAggregateArgs>): Prisma.PrismaPromise<GetFollowsAggregateType<T>>

    /**
     * Group by Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowsGroupByArgs['orderBy'] }
        : { orderBy?: FollowsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Follows.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FollowsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    follower<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    following<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Follows base type for findUnique actions
   */
  export type FollowsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where: FollowsWhereUniqueInput
  }

  /**
   * Follows findUnique
   */
  export interface FollowsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FollowsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Follows findUniqueOrThrow
   */
  export type FollowsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where: FollowsWhereUniqueInput
  }


  /**
   * Follows base type for findFirst actions
   */
  export type FollowsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: Enumerable<FollowsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: Enumerable<FollowsScalarFieldEnum>
  }

  /**
   * Follows findFirst
   */
  export interface FollowsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends FollowsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Follows findFirstOrThrow
   */
  export type FollowsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: Enumerable<FollowsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: Enumerable<FollowsScalarFieldEnum>
  }


  /**
   * Follows findMany
   */
  export type FollowsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: Enumerable<FollowsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: Enumerable<FollowsScalarFieldEnum>
  }


  /**
   * Follows create
   */
  export type FollowsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * The data needed to create a Follows.
     */
    data: XOR<FollowsCreateInput, FollowsUncheckedCreateInput>
  }


  /**
   * Follows createMany
   */
  export type FollowsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: Enumerable<FollowsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Follows update
   */
  export type FollowsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * The data needed to update a Follows.
     */
    data: XOR<FollowsUpdateInput, FollowsUncheckedUpdateInput>
    /**
     * Choose, which Follows to update.
     */
    where: FollowsWhereUniqueInput
  }


  /**
   * Follows updateMany
   */
  export type FollowsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowsUpdateManyMutationInput, FollowsUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowsWhereInput
  }


  /**
   * Follows upsert
   */
  export type FollowsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * The filter to search for the Follows to update in case it exists.
     */
    where: FollowsWhereUniqueInput
    /**
     * In case the Follows found by the `where` argument doesn't exist, create a new Follows with this data.
     */
    create: XOR<FollowsCreateInput, FollowsUncheckedCreateInput>
    /**
     * In case the Follows was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowsUpdateInput, FollowsUncheckedUpdateInput>
  }


  /**
   * Follows delete
   */
  export type FollowsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
    /**
     * Filter which Follows to delete.
     */
    where: FollowsWhereUniqueInput
  }


  /**
   * Follows deleteMany
   */
  export type FollowsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowsWhereInput
  }


  /**
   * Follows without action
   */
  export type FollowsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follows
     */
    select?: FollowsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowsInclude<ExtArgs> | null
  }



  /**
   * Model Note
   */


  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteMinAggregateOutputType = {
    noteID: string | null
    title: string | null
    icon: string | null
    updatedAt: Date | null
    documentID: string | null
    personal: boolean | null
  }

  export type NoteMaxAggregateOutputType = {
    noteID: string | null
    title: string | null
    icon: string | null
    updatedAt: Date | null
    documentID: string | null
    personal: boolean | null
  }

  export type NoteCountAggregateOutputType = {
    noteID: number
    title: number
    content: number
    icon: number
    updatedAt: number
    documentID: number
    personal: number
    _all: number
  }


  export type NoteMinAggregateInputType = {
    noteID?: true
    title?: true
    icon?: true
    updatedAt?: true
    documentID?: true
    personal?: true
  }

  export type NoteMaxAggregateInputType = {
    noteID?: true
    title?: true
    icon?: true
    updatedAt?: true
    documentID?: true
    personal?: true
  }

  export type NoteCountAggregateInputType = {
    noteID?: true
    title?: true
    content?: true
    icon?: true
    updatedAt?: true
    documentID?: true
    personal?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Note to aggregate.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type NoteGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: NoteWhereInput
    orderBy?: Enumerable<NoteOrderByWithAggregationInput>
    by: NoteScalarFieldEnum[]
    having?: NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }


  export type NoteGroupByOutputType = {
    noteID: string
    title: string | null
    content: JsonValue | null
    icon: string | null
    updatedAt: Date
    documentID: string
    personal: boolean
    _count: NoteCountAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type NoteSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    noteID?: boolean
    title?: boolean
    content?: boolean
    icon?: boolean
    updatedAt?: boolean
    documentID?: boolean
    personal?: boolean
    userNotePermissions?: boolean | Note$userNotePermissionsArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>

  export type NoteSelectScalar = {
    noteID?: boolean
    title?: boolean
    content?: boolean
    icon?: boolean
    updatedAt?: boolean
    documentID?: boolean
    personal?: boolean
  }

  export type NoteInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userNotePermissions?: boolean | Note$userNotePermissionsArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeArgs<ExtArgs>
  }


  type NoteGetPayload<S extends boolean | null | undefined | NoteArgs> = $Types.GetResult<NotePayload, S>

  type NoteCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<NoteFindManyArgs, 'select' | 'include'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface NoteDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Note'], meta: { name: 'Note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {NoteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NoteFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NoteFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Note'> extends True ? Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Note that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NoteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NoteFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NoteFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Note'> extends True ? Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Note that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `noteID`
     * const noteWithNoteIDOnly = await prisma.note.findMany({ select: { noteID: true } })
     * 
    **/
    findMany<T extends NoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<NotePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Note.
     * @param {NoteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
    **/
    create<T extends NoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, NoteCreateArgs<ExtArgs>>
    ): Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Notes.
     *     @param {NoteCreateManyArgs} args - Arguments to create many Notes.
     *     @example
     *     // Create many Notes
     *     const note = await prisma.note.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {NoteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
    **/
    delete<T extends NoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, NoteDeleteArgs<ExtArgs>>
    ): Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Note.
     * @param {NoteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, NoteUpdateArgs<ExtArgs>>
    ): Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Notes.
     * @param {NoteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, NoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, NoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {NoteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
    **/
    upsert<T extends NoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, NoteUpsertArgs<ExtArgs>>
    ): Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends NoteCountArgs>(
      args?: Subset<T, NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoteGroupByArgs['orderBy'] }
        : { orderBy?: NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NoteClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userNotePermissions<T extends Note$userNotePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Note$userNotePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Note base type for findUnique actions
   */
  export type NoteFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }

  /**
   * Note findUnique
   */
  export interface NoteFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NoteFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Note findUniqueOrThrow
   */
  export type NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where: NoteWhereUniqueInput
  }


  /**
   * Note base type for findFirst actions
   */
  export type NoteFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: Enumerable<NoteScalarFieldEnum>
  }

  /**
   * Note findFirst
   */
  export interface NoteFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends NoteFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Note findFirstOrThrow
   */
  export type NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Note to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notes.
     */
    distinct?: Enumerable<NoteScalarFieldEnum>
  }


  /**
   * Note findMany
   */
  export type NoteFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter, which Notes to fetch.
     */
    where?: NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notes to fetch.
     */
    orderBy?: Enumerable<NoteOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notes.
     */
    cursor?: NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notes.
     */
    skip?: number
    distinct?: Enumerable<NoteScalarFieldEnum>
  }


  /**
   * Note create
   */
  export type NoteCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Note.
     */
    data: XOR<NoteCreateInput, NoteUncheckedCreateInput>
  }


  /**
   * Note createMany
   */
  export type NoteCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notes.
     */
    data: Enumerable<NoteCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Note update
   */
  export type NoteUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Note.
     */
    data: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
    /**
     * Choose, which Note to update.
     */
    where: NoteWhereUniqueInput
  }


  /**
   * Note updateMany
   */
  export type NoteUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notes.
     */
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyInput>
    /**
     * Filter which Notes to update
     */
    where?: NoteWhereInput
  }


  /**
   * Note upsert
   */
  export type NoteUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Note to update in case it exists.
     */
    where: NoteWhereUniqueInput
    /**
     * In case the Note found by the `where` argument doesn't exist, create a new Note with this data.
     */
    create: XOR<NoteCreateInput, NoteUncheckedCreateInput>
    /**
     * In case the Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoteUpdateInput, NoteUncheckedUpdateInput>
  }


  /**
   * Note delete
   */
  export type NoteDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    /**
     * Filter which Note to delete.
     */
    where: NoteWhereUniqueInput
  }


  /**
   * Note deleteMany
   */
  export type NoteDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notes to delete
     */
    where?: NoteWhereInput
  }


  /**
   * Note.userNotePermissions
   */
  export type Note$userNotePermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    where?: UserNotePermissionWhereInput
    orderBy?: Enumerable<UserNotePermissionOrderByWithRelationInput>
    cursor?: UserNotePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserNotePermissionScalarFieldEnum>
  }


  /**
   * Note without action
   */
  export type NoteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
  }



  /**
   * Model DocumentVersion
   */


  export type AggregateDocumentVersion = {
    _count: DocumentVersionCountAggregateOutputType | null
    _avg: DocumentVersionAvgAggregateOutputType | null
    _sum: DocumentVersionSumAggregateOutputType | null
    _min: DocumentVersionMinAggregateOutputType | null
    _max: DocumentVersionMaxAggregateOutputType | null
  }

  export type DocumentVersionAvgAggregateOutputType = {
    wordCount: number | null
  }

  export type DocumentVersionSumAggregateOutputType = {
    wordCount: number | null
  }

  export type DocumentVersionMinAggregateOutputType = {
    documentVersionID: string | null
    updatedAt: Date | null
    createdAt: Date | null
    documentID: string | null
    versionName: string | null
    wordCount: number | null
  }

  export type DocumentVersionMaxAggregateOutputType = {
    documentVersionID: string | null
    updatedAt: Date | null
    createdAt: Date | null
    documentID: string | null
    versionName: string | null
    wordCount: number | null
  }

  export type DocumentVersionCountAggregateOutputType = {
    documentVersionID: number
    content: number
    updatedAt: number
    createdAt: number
    documentID: number
    versionName: number
    wordCount: number
    _all: number
  }


  export type DocumentVersionAvgAggregateInputType = {
    wordCount?: true
  }

  export type DocumentVersionSumAggregateInputType = {
    wordCount?: true
  }

  export type DocumentVersionMinAggregateInputType = {
    documentVersionID?: true
    updatedAt?: true
    createdAt?: true
    documentID?: true
    versionName?: true
    wordCount?: true
  }

  export type DocumentVersionMaxAggregateInputType = {
    documentVersionID?: true
    updatedAt?: true
    createdAt?: true
    documentID?: true
    versionName?: true
    wordCount?: true
  }

  export type DocumentVersionCountAggregateInputType = {
    documentVersionID?: true
    content?: true
    updatedAt?: true
    createdAt?: true
    documentID?: true
    versionName?: true
    wordCount?: true
    _all?: true
  }

  export type DocumentVersionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersion to aggregate.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: Enumerable<DocumentVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentVersions
    **/
    _count?: true | DocumentVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentVersionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentVersionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentVersionMaxAggregateInputType
  }

  export type GetDocumentVersionAggregateType<T extends DocumentVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentVersion[P]>
      : GetScalarType<T[P], AggregateDocumentVersion[P]>
  }




  export type DocumentVersionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
    orderBy?: Enumerable<DocumentVersionOrderByWithAggregationInput>
    by: DocumentVersionScalarFieldEnum[]
    having?: DocumentVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentVersionCountAggregateInputType | true
    _avg?: DocumentVersionAvgAggregateInputType
    _sum?: DocumentVersionSumAggregateInputType
    _min?: DocumentVersionMinAggregateInputType
    _max?: DocumentVersionMaxAggregateInputType
  }


  export type DocumentVersionGroupByOutputType = {
    documentVersionID: string
    content: JsonValue | null
    updatedAt: Date
    createdAt: Date
    documentID: string
    versionName: string
    wordCount: number
    _count: DocumentVersionCountAggregateOutputType | null
    _avg: DocumentVersionAvgAggregateOutputType | null
    _sum: DocumentVersionSumAggregateOutputType | null
    _min: DocumentVersionMinAggregateOutputType | null
    _max: DocumentVersionMaxAggregateOutputType | null
  }

  type GetDocumentVersionGroupByPayload<T extends DocumentVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentVersionGroupByOutputType[P]>
        }
      >
    >


  export type DocumentVersionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    documentVersionID?: boolean
    content?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    documentID?: boolean
    versionName?: boolean
    wordCount?: boolean
    comments?: boolean | DocumentVersion$commentsArgs<ExtArgs>
    userDocumentPermissions?: boolean | DocumentVersion$userDocumentPermissionsArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    statUnit?: boolean | DocumentVersion$statUnitArgs<ExtArgs>
    userDocumentAttributes?: boolean | DocumentVersion$userDocumentAttributesArgs<ExtArgs>
    _count?: boolean | DocumentVersionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["documentVersion"]>

  export type DocumentVersionSelectScalar = {
    documentVersionID?: boolean
    content?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    documentID?: boolean
    versionName?: boolean
    wordCount?: boolean
  }

  export type DocumentVersionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    comments?: boolean | DocumentVersion$commentsArgs<ExtArgs>
    userDocumentPermissions?: boolean | DocumentVersion$userDocumentPermissionsArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    statUnit?: boolean | DocumentVersion$statUnitArgs<ExtArgs>
    userDocumentAttributes?: boolean | DocumentVersion$userDocumentAttributesArgs<ExtArgs>
    _count?: boolean | DocumentVersionCountOutputTypeArgs<ExtArgs>
  }


  type DocumentVersionGetPayload<S extends boolean | null | undefined | DocumentVersionArgs> = $Types.GetResult<DocumentVersionPayload, S>

  type DocumentVersionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentVersionFindManyArgs, 'select' | 'include'> & {
      select?: DocumentVersionCountAggregateInputType | true
    }

  export interface DocumentVersionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentVersion'], meta: { name: 'DocumentVersion' } }
    /**
     * Find zero or one DocumentVersion that matches the filter.
     * @param {DocumentVersionFindUniqueArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentVersionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentVersionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DocumentVersion'> extends True ? Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DocumentVersion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentVersionFindUniqueOrThrowArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentVersionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentVersionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DocumentVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindFirstArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentVersionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentVersionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DocumentVersion'> extends True ? Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DocumentVersion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindFirstOrThrowArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentVersionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentVersionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DocumentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentVersions
     * const documentVersions = await prisma.documentVersion.findMany()
     * 
     * // Get first 10 DocumentVersions
     * const documentVersions = await prisma.documentVersion.findMany({ take: 10 })
     * 
     * // Only select the `documentVersionID`
     * const documentVersionWithDocumentVersionIDOnly = await prisma.documentVersion.findMany({ select: { documentVersionID: true } })
     * 
    **/
    findMany<T extends DocumentVersionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentVersionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DocumentVersion.
     * @param {DocumentVersionCreateArgs} args - Arguments to create a DocumentVersion.
     * @example
     * // Create one DocumentVersion
     * const DocumentVersion = await prisma.documentVersion.create({
     *   data: {
     *     // ... data to create a DocumentVersion
     *   }
     * })
     * 
    **/
    create<T extends DocumentVersionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentVersionCreateArgs<ExtArgs>>
    ): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DocumentVersions.
     *     @param {DocumentVersionCreateManyArgs} args - Arguments to create many DocumentVersions.
     *     @example
     *     // Create many DocumentVersions
     *     const documentVersion = await prisma.documentVersion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentVersionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentVersionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DocumentVersion.
     * @param {DocumentVersionDeleteArgs} args - Arguments to delete one DocumentVersion.
     * @example
     * // Delete one DocumentVersion
     * const DocumentVersion = await prisma.documentVersion.delete({
     *   where: {
     *     // ... filter to delete one DocumentVersion
     *   }
     * })
     * 
    **/
    delete<T extends DocumentVersionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentVersionDeleteArgs<ExtArgs>>
    ): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DocumentVersion.
     * @param {DocumentVersionUpdateArgs} args - Arguments to update one DocumentVersion.
     * @example
     * // Update one DocumentVersion
     * const documentVersion = await prisma.documentVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentVersionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentVersionUpdateArgs<ExtArgs>>
    ): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DocumentVersions.
     * @param {DocumentVersionDeleteManyArgs} args - Arguments to filter DocumentVersions to delete.
     * @example
     * // Delete a few DocumentVersions
     * const { count } = await prisma.documentVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentVersionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentVersionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentVersions
     * const documentVersion = await prisma.documentVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentVersionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentVersionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DocumentVersion.
     * @param {DocumentVersionUpsertArgs} args - Arguments to update or create a DocumentVersion.
     * @example
     * // Update or create a DocumentVersion
     * const documentVersion = await prisma.documentVersion.upsert({
     *   create: {
     *     // ... data to create a DocumentVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentVersion we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentVersionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentVersionUpsertArgs<ExtArgs>>
    ): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionCountArgs} args - Arguments to filter DocumentVersions to count.
     * @example
     * // Count the number of DocumentVersions
     * const count = await prisma.documentVersion.count({
     *   where: {
     *     // ... the filter for the DocumentVersions we want to count
     *   }
     * })
    **/
    count<T extends DocumentVersionCountArgs>(
      args?: Subset<T, DocumentVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentVersionAggregateArgs>(args: Subset<T, DocumentVersionAggregateArgs>): Prisma.PrismaPromise<GetDocumentVersionAggregateType<T>>

    /**
     * Group by DocumentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentVersionGroupByArgs['orderBy'] }
        : { orderBy?: DocumentVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentVersionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    comments<T extends DocumentVersion$commentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersion$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userDocumentPermissions<T extends DocumentVersion$userDocumentPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersion$userDocumentPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    statUnit<T extends DocumentVersion$statUnitArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersion$statUnitArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userDocumentAttributes<T extends DocumentVersion$userDocumentAttributesArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersion$userDocumentAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DocumentVersion base type for findUnique actions
   */
  export type DocumentVersionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion findUnique
   */
  export interface DocumentVersionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentVersionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentVersion findUniqueOrThrow
   */
  export type DocumentVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where: DocumentVersionWhereUniqueInput
  }


  /**
   * DocumentVersion base type for findFirst actions
   */
  export type DocumentVersionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: Enumerable<DocumentVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: Enumerable<DocumentVersionScalarFieldEnum>
  }

  /**
   * DocumentVersion findFirst
   */
  export interface DocumentVersionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentVersionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DocumentVersion findFirstOrThrow
   */
  export type DocumentVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: Enumerable<DocumentVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: Enumerable<DocumentVersionScalarFieldEnum>
  }


  /**
   * DocumentVersion findMany
   */
  export type DocumentVersionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: Enumerable<DocumentVersionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    distinct?: Enumerable<DocumentVersionScalarFieldEnum>
  }


  /**
   * DocumentVersion create
   */
  export type DocumentVersionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentVersion.
     */
    data: XOR<DocumentVersionCreateInput, DocumentVersionUncheckedCreateInput>
  }


  /**
   * DocumentVersion createMany
   */
  export type DocumentVersionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentVersions.
     */
    data: Enumerable<DocumentVersionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DocumentVersion update
   */
  export type DocumentVersionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentVersion.
     */
    data: XOR<DocumentVersionUpdateInput, DocumentVersionUncheckedUpdateInput>
    /**
     * Choose, which DocumentVersion to update.
     */
    where: DocumentVersionWhereUniqueInput
  }


  /**
   * DocumentVersion updateMany
   */
  export type DocumentVersionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentVersions.
     */
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentVersions to update
     */
    where?: DocumentVersionWhereInput
  }


  /**
   * DocumentVersion upsert
   */
  export type DocumentVersionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentVersion to update in case it exists.
     */
    where: DocumentVersionWhereUniqueInput
    /**
     * In case the DocumentVersion found by the `where` argument doesn't exist, create a new DocumentVersion with this data.
     */
    create: XOR<DocumentVersionCreateInput, DocumentVersionUncheckedCreateInput>
    /**
     * In case the DocumentVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentVersionUpdateInput, DocumentVersionUncheckedUpdateInput>
  }


  /**
   * DocumentVersion delete
   */
  export type DocumentVersionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter which DocumentVersion to delete.
     */
    where: DocumentVersionWhereUniqueInput
  }


  /**
   * DocumentVersion deleteMany
   */
  export type DocumentVersionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersions to delete
     */
    where?: DocumentVersionWhereInput
  }


  /**
   * DocumentVersion.comments
   */
  export type DocumentVersion$commentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * DocumentVersion.userDocumentPermissions
   */
  export type DocumentVersion$userDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    where?: UserDocumentPermissionWhereInput
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithRelationInput>
    cursor?: UserDocumentPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDocumentPermissionScalarFieldEnum>
  }


  /**
   * DocumentVersion.statUnit
   */
  export type DocumentVersion$statUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    where?: DailyStatUnitWhereInput
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    cursor?: DailyStatUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyStatUnitScalarFieldEnum>
  }


  /**
   * DocumentVersion.userDocumentAttributes
   */
  export type DocumentVersion$userDocumentAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    where?: UserDocumentAttributesWhereInput
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithRelationInput>
    cursor?: UserDocumentAttributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDocumentAttributesScalarFieldEnum>
  }


  /**
   * DocumentVersion without action
   */
  export type DocumentVersionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */


  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    documentID: string | null
    title: string | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    documentID: string | null
    title: string | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    documentID: number
    title: number
    updatedAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    documentID?: true
    title?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    documentID?: true
    title?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    documentID?: true
    title?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: Enumerable<DocumentOrderByWithAggregationInput>
    by: DocumentScalarFieldEnum[]
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }


  export type DocumentGroupByOutputType = {
    documentID: string
    title: string
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    documentID?: boolean
    title?: boolean
    updatedAt?: boolean
    documentVersions?: boolean | Document$documentVersionsArgs<ExtArgs>
    userDocumentPermissions?: boolean | Document$userDocumentPermissionsArgs<ExtArgs>
    notes?: boolean | Document$notesArgs<ExtArgs>
    statUnit?: boolean | Document$statUnitArgs<ExtArgs>
    userDocumentAttributes?: boolean | Document$userDocumentAttributesArgs<ExtArgs>
    PublishedDocument?: boolean | Document$PublishedDocumentArgs<ExtArgs>
    WritingSession?: boolean | Document$WritingSessionArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    documentID?: boolean
    title?: boolean
    updatedAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    documentVersions?: boolean | Document$documentVersionsArgs<ExtArgs>
    userDocumentPermissions?: boolean | Document$userDocumentPermissionsArgs<ExtArgs>
    notes?: boolean | Document$notesArgs<ExtArgs>
    statUnit?: boolean | Document$statUnitArgs<ExtArgs>
    userDocumentAttributes?: boolean | Document$userDocumentAttributesArgs<ExtArgs>
    PublishedDocument?: boolean | Document$PublishedDocumentArgs<ExtArgs>
    WritingSession?: boolean | Document$WritingSessionArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeArgs<ExtArgs>
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentArgs> = $Types.GetResult<DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Document'> extends True ? Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `documentID`
     * const documentWithDocumentIDOnly = await prisma.document.findMany({ select: { documentID: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    documentVersions<T extends Document$documentVersionsArgs<ExtArgs> = {}>(args?: Subset<T, Document$documentVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userDocumentPermissions<T extends Document$userDocumentPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Document$userDocumentPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    notes<T extends Document$notesArgs<ExtArgs> = {}>(args?: Subset<T, Document$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<NotePayload<ExtArgs>, T, 'findMany', never>| Null>;

    statUnit<T extends Document$statUnitArgs<ExtArgs> = {}>(args?: Subset<T, Document$statUnitArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findMany', never>| Null>;

    userDocumentAttributes<T extends Document$userDocumentAttributesArgs<ExtArgs> = {}>(args?: Subset<T, Document$userDocumentAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    PublishedDocument<T extends Document$PublishedDocumentArgs<ExtArgs> = {}>(args?: Subset<T, Document$PublishedDocumentArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findMany', never>| Null>;

    WritingSession<T extends Document$WritingSessionArgs<ExtArgs> = {}>(args?: Subset<T, Document$WritingSessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Document base type for findUnique actions
   */
  export type DocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUnique
   */
  export interface DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document base type for findFirst actions
   */
  export type DocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }

  /**
   * Document findFirst
   */
  export interface DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: Enumerable<DocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: Enumerable<DocumentScalarFieldEnum>
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: Enumerable<DocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document.documentVersions
   */
  export type Document$documentVersionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    where?: DocumentVersionWhereInput
    orderBy?: Enumerable<DocumentVersionOrderByWithRelationInput>
    cursor?: DocumentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DocumentVersionScalarFieldEnum>
  }


  /**
   * Document.userDocumentPermissions
   */
  export type Document$userDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    where?: UserDocumentPermissionWhereInput
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithRelationInput>
    cursor?: UserDocumentPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDocumentPermissionScalarFieldEnum>
  }


  /**
   * Document.notes
   */
  export type Document$notesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Note
     */
    select?: NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: NoteInclude<ExtArgs> | null
    where?: NoteWhereInput
    orderBy?: Enumerable<NoteOrderByWithRelationInput>
    cursor?: NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NoteScalarFieldEnum>
  }


  /**
   * Document.statUnit
   */
  export type Document$statUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    where?: DailyStatUnitWhereInput
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    cursor?: DailyStatUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyStatUnitScalarFieldEnum>
  }


  /**
   * Document.userDocumentAttributes
   */
  export type Document$userDocumentAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    where?: UserDocumentAttributesWhereInput
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithRelationInput>
    cursor?: UserDocumentAttributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserDocumentAttributesScalarFieldEnum>
  }


  /**
   * Document.PublishedDocument
   */
  export type Document$PublishedDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    where?: PublishedDocumentWhereInput
    orderBy?: Enumerable<PublishedDocumentOrderByWithRelationInput>
    cursor?: PublishedDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PublishedDocumentScalarFieldEnum>
  }


  /**
   * Document.WritingSession
   */
  export type Document$WritingSessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    where?: WritingSessionWhereInput
    orderBy?: Enumerable<WritingSessionOrderByWithRelationInput>
    cursor?: WritingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WritingSessionScalarFieldEnum>
  }


  /**
   * Document without action
   */
  export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model UserEnhancedDocumentPermissions
   */


  export type AggregateUserEnhancedDocumentPermissions = {
    _count: UserEnhancedDocumentPermissionsCountAggregateOutputType | null
    _min: UserEnhancedDocumentPermissionsMinAggregateOutputType | null
    _max: UserEnhancedDocumentPermissionsMaxAggregateOutputType | null
  }

  export type UserEnhancedDocumentPermissionsMinAggregateOutputType = {
    userID: string | null
    enhancedDocumentID: string | null
    role: EnhancedDocumentRole | null
  }

  export type UserEnhancedDocumentPermissionsMaxAggregateOutputType = {
    userID: string | null
    enhancedDocumentID: string | null
    role: EnhancedDocumentRole | null
  }

  export type UserEnhancedDocumentPermissionsCountAggregateOutputType = {
    userID: number
    enhancedDocumentID: number
    role: number
    _all: number
  }


  export type UserEnhancedDocumentPermissionsMinAggregateInputType = {
    userID?: true
    enhancedDocumentID?: true
    role?: true
  }

  export type UserEnhancedDocumentPermissionsMaxAggregateInputType = {
    userID?: true
    enhancedDocumentID?: true
    role?: true
  }

  export type UserEnhancedDocumentPermissionsCountAggregateInputType = {
    userID?: true
    enhancedDocumentID?: true
    role?: true
    _all?: true
  }

  export type UserEnhancedDocumentPermissionsAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEnhancedDocumentPermissions to aggregate.
     */
    where?: UserEnhancedDocumentPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnhancedDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserEnhancedDocumentPermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserEnhancedDocumentPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnhancedDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnhancedDocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserEnhancedDocumentPermissions
    **/
    _count?: true | UserEnhancedDocumentPermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserEnhancedDocumentPermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserEnhancedDocumentPermissionsMaxAggregateInputType
  }

  export type GetUserEnhancedDocumentPermissionsAggregateType<T extends UserEnhancedDocumentPermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserEnhancedDocumentPermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserEnhancedDocumentPermissions[P]>
      : GetScalarType<T[P], AggregateUserEnhancedDocumentPermissions[P]>
  }




  export type UserEnhancedDocumentPermissionsGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserEnhancedDocumentPermissionsWhereInput
    orderBy?: Enumerable<UserEnhancedDocumentPermissionsOrderByWithAggregationInput>
    by: UserEnhancedDocumentPermissionsScalarFieldEnum[]
    having?: UserEnhancedDocumentPermissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserEnhancedDocumentPermissionsCountAggregateInputType | true
    _min?: UserEnhancedDocumentPermissionsMinAggregateInputType
    _max?: UserEnhancedDocumentPermissionsMaxAggregateInputType
  }


  export type UserEnhancedDocumentPermissionsGroupByOutputType = {
    userID: string
    enhancedDocumentID: string
    role: EnhancedDocumentRole
    _count: UserEnhancedDocumentPermissionsCountAggregateOutputType | null
    _min: UserEnhancedDocumentPermissionsMinAggregateOutputType | null
    _max: UserEnhancedDocumentPermissionsMaxAggregateOutputType | null
  }

  type GetUserEnhancedDocumentPermissionsGroupByPayload<T extends UserEnhancedDocumentPermissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserEnhancedDocumentPermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserEnhancedDocumentPermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserEnhancedDocumentPermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], UserEnhancedDocumentPermissionsGroupByOutputType[P]>
        }
      >
    >


  export type UserEnhancedDocumentPermissionsSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userID?: boolean
    enhancedDocumentID?: boolean
    role?: boolean
    user?: boolean | UserArgs<ExtArgs>
    enhancedDocument?: boolean | EnhancedDocumentArgs<ExtArgs>
  }, ExtArgs["result"]["userEnhancedDocumentPermissions"]>

  export type UserEnhancedDocumentPermissionsSelectScalar = {
    userID?: boolean
    enhancedDocumentID?: boolean
    role?: boolean
  }

  export type UserEnhancedDocumentPermissionsInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    enhancedDocument?: boolean | EnhancedDocumentArgs<ExtArgs>
  }


  type UserEnhancedDocumentPermissionsGetPayload<S extends boolean | null | undefined | UserEnhancedDocumentPermissionsArgs> = $Types.GetResult<UserEnhancedDocumentPermissionsPayload, S>

  type UserEnhancedDocumentPermissionsCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserEnhancedDocumentPermissionsFindManyArgs, 'select' | 'include'> & {
      select?: UserEnhancedDocumentPermissionsCountAggregateInputType | true
    }

  export interface UserEnhancedDocumentPermissionsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserEnhancedDocumentPermissions'], meta: { name: 'UserEnhancedDocumentPermissions' } }
    /**
     * Find zero or one UserEnhancedDocumentPermissions that matches the filter.
     * @param {UserEnhancedDocumentPermissionsFindUniqueArgs} args - Arguments to find a UserEnhancedDocumentPermissions
     * @example
     * // Get one UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserEnhancedDocumentPermissionsFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserEnhancedDocumentPermissionsFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserEnhancedDocumentPermissions'> extends True ? Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserEnhancedDocumentPermissions that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserEnhancedDocumentPermissionsFindUniqueOrThrowArgs} args - Arguments to find a UserEnhancedDocumentPermissions
     * @example
     * // Get one UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserEnhancedDocumentPermissionsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserEnhancedDocumentPermissionsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserEnhancedDocumentPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnhancedDocumentPermissionsFindFirstArgs} args - Arguments to find a UserEnhancedDocumentPermissions
     * @example
     * // Get one UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserEnhancedDocumentPermissionsFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserEnhancedDocumentPermissionsFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserEnhancedDocumentPermissions'> extends True ? Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserEnhancedDocumentPermissions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnhancedDocumentPermissionsFindFirstOrThrowArgs} args - Arguments to find a UserEnhancedDocumentPermissions
     * @example
     * // Get one UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserEnhancedDocumentPermissionsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserEnhancedDocumentPermissionsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserEnhancedDocumentPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnhancedDocumentPermissionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.findMany()
     * 
     * // Get first 10 UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const userEnhancedDocumentPermissionsWithUserIDOnly = await prisma.userEnhancedDocumentPermissions.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends UserEnhancedDocumentPermissionsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserEnhancedDocumentPermissionsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserEnhancedDocumentPermissions.
     * @param {UserEnhancedDocumentPermissionsCreateArgs} args - Arguments to create a UserEnhancedDocumentPermissions.
     * @example
     * // Create one UserEnhancedDocumentPermissions
     * const UserEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.create({
     *   data: {
     *     // ... data to create a UserEnhancedDocumentPermissions
     *   }
     * })
     * 
    **/
    create<T extends UserEnhancedDocumentPermissionsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserEnhancedDocumentPermissionsCreateArgs<ExtArgs>>
    ): Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserEnhancedDocumentPermissions.
     *     @param {UserEnhancedDocumentPermissionsCreateManyArgs} args - Arguments to create many UserEnhancedDocumentPermissions.
     *     @example
     *     // Create many UserEnhancedDocumentPermissions
     *     const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserEnhancedDocumentPermissionsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserEnhancedDocumentPermissionsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserEnhancedDocumentPermissions.
     * @param {UserEnhancedDocumentPermissionsDeleteArgs} args - Arguments to delete one UserEnhancedDocumentPermissions.
     * @example
     * // Delete one UserEnhancedDocumentPermissions
     * const UserEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.delete({
     *   where: {
     *     // ... filter to delete one UserEnhancedDocumentPermissions
     *   }
     * })
     * 
    **/
    delete<T extends UserEnhancedDocumentPermissionsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserEnhancedDocumentPermissionsDeleteArgs<ExtArgs>>
    ): Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserEnhancedDocumentPermissions.
     * @param {UserEnhancedDocumentPermissionsUpdateArgs} args - Arguments to update one UserEnhancedDocumentPermissions.
     * @example
     * // Update one UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserEnhancedDocumentPermissionsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserEnhancedDocumentPermissionsUpdateArgs<ExtArgs>>
    ): Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserEnhancedDocumentPermissions.
     * @param {UserEnhancedDocumentPermissionsDeleteManyArgs} args - Arguments to filter UserEnhancedDocumentPermissions to delete.
     * @example
     * // Delete a few UserEnhancedDocumentPermissions
     * const { count } = await prisma.userEnhancedDocumentPermissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserEnhancedDocumentPermissionsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserEnhancedDocumentPermissionsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserEnhancedDocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnhancedDocumentPermissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserEnhancedDocumentPermissionsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserEnhancedDocumentPermissionsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserEnhancedDocumentPermissions.
     * @param {UserEnhancedDocumentPermissionsUpsertArgs} args - Arguments to update or create a UserEnhancedDocumentPermissions.
     * @example
     * // Update or create a UserEnhancedDocumentPermissions
     * const userEnhancedDocumentPermissions = await prisma.userEnhancedDocumentPermissions.upsert({
     *   create: {
     *     // ... data to create a UserEnhancedDocumentPermissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserEnhancedDocumentPermissions we want to update
     *   }
     * })
    **/
    upsert<T extends UserEnhancedDocumentPermissionsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserEnhancedDocumentPermissionsUpsertArgs<ExtArgs>>
    ): Prisma__UserEnhancedDocumentPermissionsClient<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserEnhancedDocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnhancedDocumentPermissionsCountArgs} args - Arguments to filter UserEnhancedDocumentPermissions to count.
     * @example
     * // Count the number of UserEnhancedDocumentPermissions
     * const count = await prisma.userEnhancedDocumentPermissions.count({
     *   where: {
     *     // ... the filter for the UserEnhancedDocumentPermissions we want to count
     *   }
     * })
    **/
    count<T extends UserEnhancedDocumentPermissionsCountArgs>(
      args?: Subset<T, UserEnhancedDocumentPermissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserEnhancedDocumentPermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserEnhancedDocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnhancedDocumentPermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserEnhancedDocumentPermissionsAggregateArgs>(args: Subset<T, UserEnhancedDocumentPermissionsAggregateArgs>): Prisma.PrismaPromise<GetUserEnhancedDocumentPermissionsAggregateType<T>>

    /**
     * Group by UserEnhancedDocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserEnhancedDocumentPermissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserEnhancedDocumentPermissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserEnhancedDocumentPermissionsGroupByArgs['orderBy'] }
        : { orderBy?: UserEnhancedDocumentPermissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserEnhancedDocumentPermissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserEnhancedDocumentPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserEnhancedDocumentPermissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserEnhancedDocumentPermissionsClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    enhancedDocument<T extends EnhancedDocumentArgs<ExtArgs> = {}>(args?: Subset<T, EnhancedDocumentArgs<ExtArgs>>): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserEnhancedDocumentPermissions base type for findUnique actions
   */
  export type UserEnhancedDocumentPermissionsFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserEnhancedDocumentPermissions to fetch.
     */
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
  }

  /**
   * UserEnhancedDocumentPermissions findUnique
   */
  export interface UserEnhancedDocumentPermissionsFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserEnhancedDocumentPermissionsFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserEnhancedDocumentPermissions findUniqueOrThrow
   */
  export type UserEnhancedDocumentPermissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserEnhancedDocumentPermissions to fetch.
     */
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
  }


  /**
   * UserEnhancedDocumentPermissions base type for findFirst actions
   */
  export type UserEnhancedDocumentPermissionsFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserEnhancedDocumentPermissions to fetch.
     */
    where?: UserEnhancedDocumentPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnhancedDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserEnhancedDocumentPermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEnhancedDocumentPermissions.
     */
    cursor?: UserEnhancedDocumentPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnhancedDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnhancedDocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEnhancedDocumentPermissions.
     */
    distinct?: Enumerable<UserEnhancedDocumentPermissionsScalarFieldEnum>
  }

  /**
   * UserEnhancedDocumentPermissions findFirst
   */
  export interface UserEnhancedDocumentPermissionsFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserEnhancedDocumentPermissionsFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserEnhancedDocumentPermissions findFirstOrThrow
   */
  export type UserEnhancedDocumentPermissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserEnhancedDocumentPermissions to fetch.
     */
    where?: UserEnhancedDocumentPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnhancedDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserEnhancedDocumentPermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserEnhancedDocumentPermissions.
     */
    cursor?: UserEnhancedDocumentPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnhancedDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnhancedDocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserEnhancedDocumentPermissions.
     */
    distinct?: Enumerable<UserEnhancedDocumentPermissionsScalarFieldEnum>
  }


  /**
   * UserEnhancedDocumentPermissions findMany
   */
  export type UserEnhancedDocumentPermissionsFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * Filter, which UserEnhancedDocumentPermissions to fetch.
     */
    where?: UserEnhancedDocumentPermissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserEnhancedDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserEnhancedDocumentPermissionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserEnhancedDocumentPermissions.
     */
    cursor?: UserEnhancedDocumentPermissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserEnhancedDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserEnhancedDocumentPermissions.
     */
    skip?: number
    distinct?: Enumerable<UserEnhancedDocumentPermissionsScalarFieldEnum>
  }


  /**
   * UserEnhancedDocumentPermissions create
   */
  export type UserEnhancedDocumentPermissionsCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserEnhancedDocumentPermissions.
     */
    data: XOR<UserEnhancedDocumentPermissionsCreateInput, UserEnhancedDocumentPermissionsUncheckedCreateInput>
  }


  /**
   * UserEnhancedDocumentPermissions createMany
   */
  export type UserEnhancedDocumentPermissionsCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserEnhancedDocumentPermissions.
     */
    data: Enumerable<UserEnhancedDocumentPermissionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserEnhancedDocumentPermissions update
   */
  export type UserEnhancedDocumentPermissionsUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserEnhancedDocumentPermissions.
     */
    data: XOR<UserEnhancedDocumentPermissionsUpdateInput, UserEnhancedDocumentPermissionsUncheckedUpdateInput>
    /**
     * Choose, which UserEnhancedDocumentPermissions to update.
     */
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
  }


  /**
   * UserEnhancedDocumentPermissions updateMany
   */
  export type UserEnhancedDocumentPermissionsUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserEnhancedDocumentPermissions.
     */
    data: XOR<UserEnhancedDocumentPermissionsUpdateManyMutationInput, UserEnhancedDocumentPermissionsUncheckedUpdateManyInput>
    /**
     * Filter which UserEnhancedDocumentPermissions to update
     */
    where?: UserEnhancedDocumentPermissionsWhereInput
  }


  /**
   * UserEnhancedDocumentPermissions upsert
   */
  export type UserEnhancedDocumentPermissionsUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserEnhancedDocumentPermissions to update in case it exists.
     */
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
    /**
     * In case the UserEnhancedDocumentPermissions found by the `where` argument doesn't exist, create a new UserEnhancedDocumentPermissions with this data.
     */
    create: XOR<UserEnhancedDocumentPermissionsCreateInput, UserEnhancedDocumentPermissionsUncheckedCreateInput>
    /**
     * In case the UserEnhancedDocumentPermissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserEnhancedDocumentPermissionsUpdateInput, UserEnhancedDocumentPermissionsUncheckedUpdateInput>
  }


  /**
   * UserEnhancedDocumentPermissions delete
   */
  export type UserEnhancedDocumentPermissionsDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    /**
     * Filter which UserEnhancedDocumentPermissions to delete.
     */
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
  }


  /**
   * UserEnhancedDocumentPermissions deleteMany
   */
  export type UserEnhancedDocumentPermissionsDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserEnhancedDocumentPermissions to delete
     */
    where?: UserEnhancedDocumentPermissionsWhereInput
  }


  /**
   * UserEnhancedDocumentPermissions without action
   */
  export type UserEnhancedDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
  }



  /**
   * Model EnhancedDocument
   */


  export type AggregateEnhancedDocument = {
    _count: EnhancedDocumentCountAggregateOutputType | null
    _min: EnhancedDocumentMinAggregateOutputType | null
    _max: EnhancedDocumentMaxAggregateOutputType | null
  }

  export type EnhancedDocumentMinAggregateOutputType = {
    enhancedDocumentID: string | null
    title: string | null
    updatedAt: Date | null
    draftCollapsed: boolean | null
  }

  export type EnhancedDocumentMaxAggregateOutputType = {
    enhancedDocumentID: string | null
    title: string | null
    updatedAt: Date | null
    draftCollapsed: boolean | null
  }

  export type EnhancedDocumentCountAggregateOutputType = {
    enhancedDocumentID: number
    notesContent: number
    embeddingsByNodeID: number
    title: number
    updatedAt: number
    draftContent: number
    draftCollapsed: number
    ideas: number
    _all: number
  }


  export type EnhancedDocumentMinAggregateInputType = {
    enhancedDocumentID?: true
    title?: true
    updatedAt?: true
    draftCollapsed?: true
  }

  export type EnhancedDocumentMaxAggregateInputType = {
    enhancedDocumentID?: true
    title?: true
    updatedAt?: true
    draftCollapsed?: true
  }

  export type EnhancedDocumentCountAggregateInputType = {
    enhancedDocumentID?: true
    notesContent?: true
    embeddingsByNodeID?: true
    title?: true
    updatedAt?: true
    draftContent?: true
    draftCollapsed?: true
    ideas?: true
    _all?: true
  }

  export type EnhancedDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnhancedDocument to aggregate.
     */
    where?: EnhancedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnhancedDocuments to fetch.
     */
    orderBy?: Enumerable<EnhancedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnhancedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnhancedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnhancedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EnhancedDocuments
    **/
    _count?: true | EnhancedDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnhancedDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnhancedDocumentMaxAggregateInputType
  }

  export type GetEnhancedDocumentAggregateType<T extends EnhancedDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateEnhancedDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnhancedDocument[P]>
      : GetScalarType<T[P], AggregateEnhancedDocument[P]>
  }




  export type EnhancedDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: EnhancedDocumentWhereInput
    orderBy?: Enumerable<EnhancedDocumentOrderByWithAggregationInput>
    by: EnhancedDocumentScalarFieldEnum[]
    having?: EnhancedDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnhancedDocumentCountAggregateInputType | true
    _min?: EnhancedDocumentMinAggregateInputType
    _max?: EnhancedDocumentMaxAggregateInputType
  }


  export type EnhancedDocumentGroupByOutputType = {
    enhancedDocumentID: string
    notesContent: JsonValue
    embeddingsByNodeID: JsonValue | null
    title: string
    updatedAt: Date
    draftContent: JsonValue | null
    draftCollapsed: boolean
    ideas: string[]
    _count: EnhancedDocumentCountAggregateOutputType | null
    _min: EnhancedDocumentMinAggregateOutputType | null
    _max: EnhancedDocumentMaxAggregateOutputType | null
  }

  type GetEnhancedDocumentGroupByPayload<T extends EnhancedDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EnhancedDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnhancedDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnhancedDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], EnhancedDocumentGroupByOutputType[P]>
        }
      >
    >


  export type EnhancedDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    enhancedDocumentID?: boolean
    notesContent?: boolean
    embeddingsByNodeID?: boolean
    title?: boolean
    updatedAt?: boolean
    draftContent?: boolean
    draftCollapsed?: boolean
    ideas?: boolean
    userEnhancedDocumentPermissions?: boolean | EnhancedDocument$userEnhancedDocumentPermissionsArgs<ExtArgs>
    threadAttributes?: boolean | EnhancedDocument$threadAttributesArgs<ExtArgs>
    _count?: boolean | EnhancedDocumentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["enhancedDocument"]>

  export type EnhancedDocumentSelectScalar = {
    enhancedDocumentID?: boolean
    notesContent?: boolean
    embeddingsByNodeID?: boolean
    title?: boolean
    updatedAt?: boolean
    draftContent?: boolean
    draftCollapsed?: boolean
    ideas?: boolean
  }

  export type EnhancedDocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    userEnhancedDocumentPermissions?: boolean | EnhancedDocument$userEnhancedDocumentPermissionsArgs<ExtArgs>
    threadAttributes?: boolean | EnhancedDocument$threadAttributesArgs<ExtArgs>
    _count?: boolean | EnhancedDocumentCountOutputTypeArgs<ExtArgs>
  }


  type EnhancedDocumentGetPayload<S extends boolean | null | undefined | EnhancedDocumentArgs> = $Types.GetResult<EnhancedDocumentPayload, S>

  type EnhancedDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<EnhancedDocumentFindManyArgs, 'select' | 'include'> & {
      select?: EnhancedDocumentCountAggregateInputType | true
    }

  export interface EnhancedDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EnhancedDocument'], meta: { name: 'EnhancedDocument' } }
    /**
     * Find zero or one EnhancedDocument that matches the filter.
     * @param {EnhancedDocumentFindUniqueArgs} args - Arguments to find a EnhancedDocument
     * @example
     * // Get one EnhancedDocument
     * const enhancedDocument = await prisma.enhancedDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnhancedDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EnhancedDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'EnhancedDocument'> extends True ? Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one EnhancedDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnhancedDocumentFindUniqueOrThrowArgs} args - Arguments to find a EnhancedDocument
     * @example
     * // Get one EnhancedDocument
     * const enhancedDocument = await prisma.enhancedDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnhancedDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnhancedDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first EnhancedDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnhancedDocumentFindFirstArgs} args - Arguments to find a EnhancedDocument
     * @example
     * // Get one EnhancedDocument
     * const enhancedDocument = await prisma.enhancedDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnhancedDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EnhancedDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'EnhancedDocument'> extends True ? Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first EnhancedDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnhancedDocumentFindFirstOrThrowArgs} args - Arguments to find a EnhancedDocument
     * @example
     * // Get one EnhancedDocument
     * const enhancedDocument = await prisma.enhancedDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnhancedDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnhancedDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more EnhancedDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnhancedDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EnhancedDocuments
     * const enhancedDocuments = await prisma.enhancedDocument.findMany()
     * 
     * // Get first 10 EnhancedDocuments
     * const enhancedDocuments = await prisma.enhancedDocument.findMany({ take: 10 })
     * 
     * // Only select the `enhancedDocumentID`
     * const enhancedDocumentWithEnhancedDocumentIDOnly = await prisma.enhancedDocument.findMany({ select: { enhancedDocumentID: true } })
     * 
    **/
    findMany<T extends EnhancedDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnhancedDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a EnhancedDocument.
     * @param {EnhancedDocumentCreateArgs} args - Arguments to create a EnhancedDocument.
     * @example
     * // Create one EnhancedDocument
     * const EnhancedDocument = await prisma.enhancedDocument.create({
     *   data: {
     *     // ... data to create a EnhancedDocument
     *   }
     * })
     * 
    **/
    create<T extends EnhancedDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnhancedDocumentCreateArgs<ExtArgs>>
    ): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many EnhancedDocuments.
     *     @param {EnhancedDocumentCreateManyArgs} args - Arguments to create many EnhancedDocuments.
     *     @example
     *     // Create many EnhancedDocuments
     *     const enhancedDocument = await prisma.enhancedDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnhancedDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnhancedDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EnhancedDocument.
     * @param {EnhancedDocumentDeleteArgs} args - Arguments to delete one EnhancedDocument.
     * @example
     * // Delete one EnhancedDocument
     * const EnhancedDocument = await prisma.enhancedDocument.delete({
     *   where: {
     *     // ... filter to delete one EnhancedDocument
     *   }
     * })
     * 
    **/
    delete<T extends EnhancedDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnhancedDocumentDeleteArgs<ExtArgs>>
    ): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one EnhancedDocument.
     * @param {EnhancedDocumentUpdateArgs} args - Arguments to update one EnhancedDocument.
     * @example
     * // Update one EnhancedDocument
     * const enhancedDocument = await prisma.enhancedDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnhancedDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnhancedDocumentUpdateArgs<ExtArgs>>
    ): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more EnhancedDocuments.
     * @param {EnhancedDocumentDeleteManyArgs} args - Arguments to filter EnhancedDocuments to delete.
     * @example
     * // Delete a few EnhancedDocuments
     * const { count } = await prisma.enhancedDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnhancedDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnhancedDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EnhancedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnhancedDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EnhancedDocuments
     * const enhancedDocument = await prisma.enhancedDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnhancedDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnhancedDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EnhancedDocument.
     * @param {EnhancedDocumentUpsertArgs} args - Arguments to update or create a EnhancedDocument.
     * @example
     * // Update or create a EnhancedDocument
     * const enhancedDocument = await prisma.enhancedDocument.upsert({
     *   create: {
     *     // ... data to create a EnhancedDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EnhancedDocument we want to update
     *   }
     * })
    **/
    upsert<T extends EnhancedDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnhancedDocumentUpsertArgs<ExtArgs>>
    ): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of EnhancedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnhancedDocumentCountArgs} args - Arguments to filter EnhancedDocuments to count.
     * @example
     * // Count the number of EnhancedDocuments
     * const count = await prisma.enhancedDocument.count({
     *   where: {
     *     // ... the filter for the EnhancedDocuments we want to count
     *   }
     * })
    **/
    count<T extends EnhancedDocumentCountArgs>(
      args?: Subset<T, EnhancedDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnhancedDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EnhancedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnhancedDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnhancedDocumentAggregateArgs>(args: Subset<T, EnhancedDocumentAggregateArgs>): Prisma.PrismaPromise<GetEnhancedDocumentAggregateType<T>>

    /**
     * Group by EnhancedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnhancedDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnhancedDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnhancedDocumentGroupByArgs['orderBy'] }
        : { orderBy?: EnhancedDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnhancedDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnhancedDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for EnhancedDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EnhancedDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    userEnhancedDocumentPermissions<T extends EnhancedDocument$userEnhancedDocumentPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, EnhancedDocument$userEnhancedDocumentPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserEnhancedDocumentPermissionsPayload<ExtArgs>, T, 'findMany', never>| Null>;

    threadAttributes<T extends EnhancedDocument$threadAttributesArgs<ExtArgs> = {}>(args?: Subset<T, EnhancedDocument$threadAttributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * EnhancedDocument base type for findUnique actions
   */
  export type EnhancedDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EnhancedDocument to fetch.
     */
    where: EnhancedDocumentWhereUniqueInput
  }

  /**
   * EnhancedDocument findUnique
   */
  export interface EnhancedDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EnhancedDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EnhancedDocument findUniqueOrThrow
   */
  export type EnhancedDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EnhancedDocument to fetch.
     */
    where: EnhancedDocumentWhereUniqueInput
  }


  /**
   * EnhancedDocument base type for findFirst actions
   */
  export type EnhancedDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EnhancedDocument to fetch.
     */
    where?: EnhancedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnhancedDocuments to fetch.
     */
    orderBy?: Enumerable<EnhancedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnhancedDocuments.
     */
    cursor?: EnhancedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnhancedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnhancedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnhancedDocuments.
     */
    distinct?: Enumerable<EnhancedDocumentScalarFieldEnum>
  }

  /**
   * EnhancedDocument findFirst
   */
  export interface EnhancedDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends EnhancedDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * EnhancedDocument findFirstOrThrow
   */
  export type EnhancedDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EnhancedDocument to fetch.
     */
    where?: EnhancedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnhancedDocuments to fetch.
     */
    orderBy?: Enumerable<EnhancedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EnhancedDocuments.
     */
    cursor?: EnhancedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnhancedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnhancedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EnhancedDocuments.
     */
    distinct?: Enumerable<EnhancedDocumentScalarFieldEnum>
  }


  /**
   * EnhancedDocument findMany
   */
  export type EnhancedDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EnhancedDocuments to fetch.
     */
    where?: EnhancedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EnhancedDocuments to fetch.
     */
    orderBy?: Enumerable<EnhancedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EnhancedDocuments.
     */
    cursor?: EnhancedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EnhancedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EnhancedDocuments.
     */
    skip?: number
    distinct?: Enumerable<EnhancedDocumentScalarFieldEnum>
  }


  /**
   * EnhancedDocument create
   */
  export type EnhancedDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a EnhancedDocument.
     */
    data: XOR<EnhancedDocumentCreateInput, EnhancedDocumentUncheckedCreateInput>
  }


  /**
   * EnhancedDocument createMany
   */
  export type EnhancedDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EnhancedDocuments.
     */
    data: Enumerable<EnhancedDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * EnhancedDocument update
   */
  export type EnhancedDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a EnhancedDocument.
     */
    data: XOR<EnhancedDocumentUpdateInput, EnhancedDocumentUncheckedUpdateInput>
    /**
     * Choose, which EnhancedDocument to update.
     */
    where: EnhancedDocumentWhereUniqueInput
  }


  /**
   * EnhancedDocument updateMany
   */
  export type EnhancedDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EnhancedDocuments.
     */
    data: XOR<EnhancedDocumentUpdateManyMutationInput, EnhancedDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EnhancedDocuments to update
     */
    where?: EnhancedDocumentWhereInput
  }


  /**
   * EnhancedDocument upsert
   */
  export type EnhancedDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the EnhancedDocument to update in case it exists.
     */
    where: EnhancedDocumentWhereUniqueInput
    /**
     * In case the EnhancedDocument found by the `where` argument doesn't exist, create a new EnhancedDocument with this data.
     */
    create: XOR<EnhancedDocumentCreateInput, EnhancedDocumentUncheckedCreateInput>
    /**
     * In case the EnhancedDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnhancedDocumentUpdateInput, EnhancedDocumentUncheckedUpdateInput>
  }


  /**
   * EnhancedDocument delete
   */
  export type EnhancedDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
    /**
     * Filter which EnhancedDocument to delete.
     */
    where: EnhancedDocumentWhereUniqueInput
  }


  /**
   * EnhancedDocument deleteMany
   */
  export type EnhancedDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which EnhancedDocuments to delete
     */
    where?: EnhancedDocumentWhereInput
  }


  /**
   * EnhancedDocument.userEnhancedDocumentPermissions
   */
  export type EnhancedDocument$userEnhancedDocumentPermissionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserEnhancedDocumentPermissions
     */
    select?: UserEnhancedDocumentPermissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserEnhancedDocumentPermissionsInclude<ExtArgs> | null
    where?: UserEnhancedDocumentPermissionsWhereInput
    orderBy?: Enumerable<UserEnhancedDocumentPermissionsOrderByWithRelationInput>
    cursor?: UserEnhancedDocumentPermissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserEnhancedDocumentPermissionsScalarFieldEnum>
  }


  /**
   * EnhancedDocument.threadAttributes
   */
  export type EnhancedDocument$threadAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    where?: ThreadAttributesWhereInput
    orderBy?: Enumerable<ThreadAttributesOrderByWithRelationInput>
    cursor?: ThreadAttributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ThreadAttributesScalarFieldEnum>
  }


  /**
   * EnhancedDocument without action
   */
  export type EnhancedDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EnhancedDocument
     */
    select?: EnhancedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: EnhancedDocumentInclude<ExtArgs> | null
  }



  /**
   * Model ThreadAttributes
   */


  export type AggregateThreadAttributes = {
    _count: ThreadAttributesCountAggregateOutputType | null
    _min: ThreadAttributesMinAggregateOutputType | null
    _max: ThreadAttributesMaxAggregateOutputType | null
  }

  export type ThreadAttributesMinAggregateOutputType = {
    threadID: string | null
    userID: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archivedAt: Date | null
    enhancedDocumentID: string | null
  }

  export type ThreadAttributesMaxAggregateOutputType = {
    threadID: string | null
    userID: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archivedAt: Date | null
    enhancedDocumentID: string | null
  }

  export type ThreadAttributesCountAggregateOutputType = {
    threadID: number
    userID: number
    createdAt: number
    updatedAt: number
    archivedAt: number
    enhancedDocumentID: number
    sectionData: number
    _all: number
  }


  export type ThreadAttributesMinAggregateInputType = {
    threadID?: true
    userID?: true
    createdAt?: true
    updatedAt?: true
    archivedAt?: true
    enhancedDocumentID?: true
  }

  export type ThreadAttributesMaxAggregateInputType = {
    threadID?: true
    userID?: true
    createdAt?: true
    updatedAt?: true
    archivedAt?: true
    enhancedDocumentID?: true
  }

  export type ThreadAttributesCountAggregateInputType = {
    threadID?: true
    userID?: true
    createdAt?: true
    updatedAt?: true
    archivedAt?: true
    enhancedDocumentID?: true
    sectionData?: true
    _all?: true
  }

  export type ThreadAttributesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreadAttributes to aggregate.
     */
    where?: ThreadAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadAttributes to fetch.
     */
    orderBy?: Enumerable<ThreadAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreadAttributes
    **/
    _count?: true | ThreadAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadAttributesMaxAggregateInputType
  }

  export type GetThreadAttributesAggregateType<T extends ThreadAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateThreadAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadAttributes[P]>
      : GetScalarType<T[P], AggregateThreadAttributes[P]>
  }




  export type ThreadAttributesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ThreadAttributesWhereInput
    orderBy?: Enumerable<ThreadAttributesOrderByWithAggregationInput>
    by: ThreadAttributesScalarFieldEnum[]
    having?: ThreadAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadAttributesCountAggregateInputType | true
    _min?: ThreadAttributesMinAggregateInputType
    _max?: ThreadAttributesMaxAggregateInputType
  }


  export type ThreadAttributesGroupByOutputType = {
    threadID: string
    userID: string
    createdAt: Date
    updatedAt: Date
    archivedAt: Date | null
    enhancedDocumentID: string
    sectionData: JsonValue | null
    _count: ThreadAttributesCountAggregateOutputType | null
    _min: ThreadAttributesMinAggregateOutputType | null
    _max: ThreadAttributesMaxAggregateOutputType | null
  }

  type GetThreadAttributesGroupByPayload<T extends ThreadAttributesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ThreadAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadAttributesGroupByOutputType[P]>
        }
      >
    >


  export type ThreadAttributesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    threadID?: boolean
    userID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archivedAt?: boolean
    enhancedDocumentID?: boolean
    sectionData?: boolean
    user?: boolean | UserArgs<ExtArgs>
    document?: boolean | EnhancedDocumentArgs<ExtArgs>
    chatMessage?: boolean | ThreadAttributes$chatMessageArgs<ExtArgs>
    _count?: boolean | ThreadAttributesCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["threadAttributes"]>

  export type ThreadAttributesSelectScalar = {
    threadID?: boolean
    userID?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archivedAt?: boolean
    enhancedDocumentID?: boolean
    sectionData?: boolean
  }

  export type ThreadAttributesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    document?: boolean | EnhancedDocumentArgs<ExtArgs>
    chatMessage?: boolean | ThreadAttributes$chatMessageArgs<ExtArgs>
    _count?: boolean | ThreadAttributesCountOutputTypeArgs<ExtArgs>
  }


  type ThreadAttributesGetPayload<S extends boolean | null | undefined | ThreadAttributesArgs> = $Types.GetResult<ThreadAttributesPayload, S>

  type ThreadAttributesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ThreadAttributesFindManyArgs, 'select' | 'include'> & {
      select?: ThreadAttributesCountAggregateInputType | true
    }

  export interface ThreadAttributesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThreadAttributes'], meta: { name: 'ThreadAttributes' } }
    /**
     * Find zero or one ThreadAttributes that matches the filter.
     * @param {ThreadAttributesFindUniqueArgs} args - Arguments to find a ThreadAttributes
     * @example
     * // Get one ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ThreadAttributesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ThreadAttributesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ThreadAttributes'> extends True ? Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ThreadAttributes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ThreadAttributesFindUniqueOrThrowArgs} args - Arguments to find a ThreadAttributes
     * @example
     * // Get one ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ThreadAttributesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ThreadAttributesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ThreadAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAttributesFindFirstArgs} args - Arguments to find a ThreadAttributes
     * @example
     * // Get one ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ThreadAttributesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ThreadAttributesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ThreadAttributes'> extends True ? Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ThreadAttributes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAttributesFindFirstOrThrowArgs} args - Arguments to find a ThreadAttributes
     * @example
     * // Get one ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ThreadAttributesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ThreadAttributesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ThreadAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.findMany()
     * 
     * // Get first 10 ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.findMany({ take: 10 })
     * 
     * // Only select the `threadID`
     * const threadAttributesWithThreadIDOnly = await prisma.threadAttributes.findMany({ select: { threadID: true } })
     * 
    **/
    findMany<T extends ThreadAttributesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThreadAttributesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ThreadAttributes.
     * @param {ThreadAttributesCreateArgs} args - Arguments to create a ThreadAttributes.
     * @example
     * // Create one ThreadAttributes
     * const ThreadAttributes = await prisma.threadAttributes.create({
     *   data: {
     *     // ... data to create a ThreadAttributes
     *   }
     * })
     * 
    **/
    create<T extends ThreadAttributesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ThreadAttributesCreateArgs<ExtArgs>>
    ): Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ThreadAttributes.
     *     @param {ThreadAttributesCreateManyArgs} args - Arguments to create many ThreadAttributes.
     *     @example
     *     // Create many ThreadAttributes
     *     const threadAttributes = await prisma.threadAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ThreadAttributesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThreadAttributesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ThreadAttributes.
     * @param {ThreadAttributesDeleteArgs} args - Arguments to delete one ThreadAttributes.
     * @example
     * // Delete one ThreadAttributes
     * const ThreadAttributes = await prisma.threadAttributes.delete({
     *   where: {
     *     // ... filter to delete one ThreadAttributes
     *   }
     * })
     * 
    **/
    delete<T extends ThreadAttributesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ThreadAttributesDeleteArgs<ExtArgs>>
    ): Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ThreadAttributes.
     * @param {ThreadAttributesUpdateArgs} args - Arguments to update one ThreadAttributes.
     * @example
     * // Update one ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ThreadAttributesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ThreadAttributesUpdateArgs<ExtArgs>>
    ): Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ThreadAttributes.
     * @param {ThreadAttributesDeleteManyArgs} args - Arguments to filter ThreadAttributes to delete.
     * @example
     * // Delete a few ThreadAttributes
     * const { count } = await prisma.threadAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ThreadAttributesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ThreadAttributesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ThreadAttributesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ThreadAttributesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ThreadAttributes.
     * @param {ThreadAttributesUpsertArgs} args - Arguments to update or create a ThreadAttributes.
     * @example
     * // Update or create a ThreadAttributes
     * const threadAttributes = await prisma.threadAttributes.upsert({
     *   create: {
     *     // ... data to create a ThreadAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends ThreadAttributesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ThreadAttributesUpsertArgs<ExtArgs>>
    ): Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ThreadAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAttributesCountArgs} args - Arguments to filter ThreadAttributes to count.
     * @example
     * // Count the number of ThreadAttributes
     * const count = await prisma.threadAttributes.count({
     *   where: {
     *     // ... the filter for the ThreadAttributes we want to count
     *   }
     * })
    **/
    count<T extends ThreadAttributesCountArgs>(
      args?: Subset<T, ThreadAttributesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreadAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadAttributesAggregateArgs>(args: Subset<T, ThreadAttributesAggregateArgs>): Prisma.PrismaPromise<GetThreadAttributesAggregateType<T>>

    /**
     * Group by ThreadAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadAttributesGroupByArgs['orderBy'] }
        : { orderBy?: ThreadAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadAttributesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ThreadAttributesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    document<T extends EnhancedDocumentArgs<ExtArgs> = {}>(args?: Subset<T, EnhancedDocumentArgs<ExtArgs>>): Prisma__EnhancedDocumentClient<$Types.GetResult<EnhancedDocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    chatMessage<T extends ThreadAttributes$chatMessageArgs<ExtArgs> = {}>(args?: Subset<T, ThreadAttributes$chatMessageArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ThreadAttributes base type for findUnique actions
   */
  export type ThreadAttributesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * Filter, which ThreadAttributes to fetch.
     */
    where: ThreadAttributesWhereUniqueInput
  }

  /**
   * ThreadAttributes findUnique
   */
  export interface ThreadAttributesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ThreadAttributesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadAttributes findUniqueOrThrow
   */
  export type ThreadAttributesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * Filter, which ThreadAttributes to fetch.
     */
    where: ThreadAttributesWhereUniqueInput
  }


  /**
   * ThreadAttributes base type for findFirst actions
   */
  export type ThreadAttributesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * Filter, which ThreadAttributes to fetch.
     */
    where?: ThreadAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadAttributes to fetch.
     */
    orderBy?: Enumerable<ThreadAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadAttributes.
     */
    cursor?: ThreadAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadAttributes.
     */
    distinct?: Enumerable<ThreadAttributesScalarFieldEnum>
  }

  /**
   * ThreadAttributes findFirst
   */
  export interface ThreadAttributesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ThreadAttributesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ThreadAttributes findFirstOrThrow
   */
  export type ThreadAttributesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * Filter, which ThreadAttributes to fetch.
     */
    where?: ThreadAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadAttributes to fetch.
     */
    orderBy?: Enumerable<ThreadAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadAttributes.
     */
    cursor?: ThreadAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadAttributes.
     */
    distinct?: Enumerable<ThreadAttributesScalarFieldEnum>
  }


  /**
   * ThreadAttributes findMany
   */
  export type ThreadAttributesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * Filter, which ThreadAttributes to fetch.
     */
    where?: ThreadAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadAttributes to fetch.
     */
    orderBy?: Enumerable<ThreadAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreadAttributes.
     */
    cursor?: ThreadAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadAttributes.
     */
    skip?: number
    distinct?: Enumerable<ThreadAttributesScalarFieldEnum>
  }


  /**
   * ThreadAttributes create
   */
  export type ThreadAttributesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * The data needed to create a ThreadAttributes.
     */
    data: XOR<ThreadAttributesCreateInput, ThreadAttributesUncheckedCreateInput>
  }


  /**
   * ThreadAttributes createMany
   */
  export type ThreadAttributesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThreadAttributes.
     */
    data: Enumerable<ThreadAttributesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ThreadAttributes update
   */
  export type ThreadAttributesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * The data needed to update a ThreadAttributes.
     */
    data: XOR<ThreadAttributesUpdateInput, ThreadAttributesUncheckedUpdateInput>
    /**
     * Choose, which ThreadAttributes to update.
     */
    where: ThreadAttributesWhereUniqueInput
  }


  /**
   * ThreadAttributes updateMany
   */
  export type ThreadAttributesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThreadAttributes.
     */
    data: XOR<ThreadAttributesUpdateManyMutationInput, ThreadAttributesUncheckedUpdateManyInput>
    /**
     * Filter which ThreadAttributes to update
     */
    where?: ThreadAttributesWhereInput
  }


  /**
   * ThreadAttributes upsert
   */
  export type ThreadAttributesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * The filter to search for the ThreadAttributes to update in case it exists.
     */
    where: ThreadAttributesWhereUniqueInput
    /**
     * In case the ThreadAttributes found by the `where` argument doesn't exist, create a new ThreadAttributes with this data.
     */
    create: XOR<ThreadAttributesCreateInput, ThreadAttributesUncheckedCreateInput>
    /**
     * In case the ThreadAttributes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadAttributesUpdateInput, ThreadAttributesUncheckedUpdateInput>
  }


  /**
   * ThreadAttributes delete
   */
  export type ThreadAttributesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
    /**
     * Filter which ThreadAttributes to delete.
     */
    where: ThreadAttributesWhereUniqueInput
  }


  /**
   * ThreadAttributes deleteMany
   */
  export type ThreadAttributesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreadAttributes to delete
     */
    where?: ThreadAttributesWhereInput
  }


  /**
   * ThreadAttributes.chatMessage
   */
  export type ThreadAttributes$chatMessageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }


  /**
   * ThreadAttributes without action
   */
  export type ThreadAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadAttributes
     */
    select?: ThreadAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ThreadAttributesInclude<ExtArgs> | null
  }



  /**
   * Model ChatMessage
   */


  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    chatMessageID: string | null
    content: string | null
    author: ChatMessageAuthor | null
    createdAt: Date | null
    threadID: string | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    chatMessageID: string | null
    content: string | null
    author: ChatMessageAuthor | null
    createdAt: Date | null
    threadID: string | null
  }

  export type ChatMessageCountAggregateOutputType = {
    chatMessageID: number
    content: number
    author: number
    createdAt: number
    threadID: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    chatMessageID?: true
    content?: true
    author?: true
    createdAt?: true
    threadID?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    chatMessageID?: true
    content?: true
    author?: true
    createdAt?: true
    threadID?: true
  }

  export type ChatMessageCountAggregateInputType = {
    chatMessageID?: true
    content?: true
    author?: true
    createdAt?: true
    threadID?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: Enumerable<ChatMessageOrderByWithAggregationInput>
    by: ChatMessageScalarFieldEnum[]
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }


  export type ChatMessageGroupByOutputType = {
    chatMessageID: string
    content: string
    author: ChatMessageAuthor
    createdAt: Date
    threadID: string
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatMessageID?: boolean
    content?: boolean
    author?: boolean
    createdAt?: boolean
    threadID?: boolean
    thread?: boolean | ThreadAttributesArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    chatMessageID?: boolean
    content?: boolean
    author?: boolean
    createdAt?: boolean
    threadID?: boolean
  }

  export type ChatMessageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    thread?: boolean | ThreadAttributesArgs<ExtArgs>
  }


  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageArgs> = $Types.GetResult<ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ChatMessageFindManyArgs, 'select' | 'include'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChatMessageFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ChatMessage'> extends True ? Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ChatMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChatMessageFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ChatMessage'> extends True ? Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `chatMessageID`
     * const chatMessageWithChatMessageIDOnly = await prisma.chatMessage.findMany({ select: { chatMessageID: true } })
     * 
    **/
    findMany<T extends ChatMessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
    **/
    create<T extends ChatMessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>
    ): Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ChatMessages.
     *     @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     *     @example
     *     // Create many ChatMessages
     *     const chatMessage = await prisma.chatMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChatMessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
    **/
    delete<T extends ChatMessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>
    ): Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChatMessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>
    ): Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChatMessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChatMessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
    **/
    upsert<T extends ChatMessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>
    ): Prisma__ChatMessageClient<$Types.GetResult<ChatMessagePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    thread<T extends ThreadAttributesArgs<ExtArgs> = {}>(args?: Subset<T, ThreadAttributesArgs<ExtArgs>>): Prisma__ThreadAttributesClient<$Types.GetResult<ThreadAttributesPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ChatMessage base type for findUnique actions
   */
  export type ChatMessageFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUnique
   */
  export interface ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ChatMessageFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }


  /**
   * ChatMessage base type for findFirst actions
   */
  export type ChatMessageFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }

  /**
   * ChatMessage findFirst
   */
  export interface ChatMessageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ChatMessageFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }


  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: Enumerable<ChatMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: Enumerable<ChatMessageScalarFieldEnum>
  }


  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }


  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: Enumerable<ChatMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }


  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
  }


  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }


  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }


  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
  }


  /**
   * ChatMessage without action
   */
  export type ChatMessageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }



  /**
   * Model PublishedDocument
   */


  export type AggregatePublishedDocument = {
    _count: PublishedDocumentCountAggregateOutputType | null
    _min: PublishedDocumentMinAggregateOutputType | null
    _max: PublishedDocumentMaxAggregateOutputType | null
  }

  export type PublishedDocumentMinAggregateOutputType = {
    publishedDocumentID: string | null
    documentID: string | null
    url: string | null
    userID: string | null
    publishedAt: Date | null
    updatedAt: Date | null
    title: string | null
    subtitle: string | null
  }

  export type PublishedDocumentMaxAggregateOutputType = {
    publishedDocumentID: string | null
    documentID: string | null
    url: string | null
    userID: string | null
    publishedAt: Date | null
    updatedAt: Date | null
    title: string | null
    subtitle: string | null
  }

  export type PublishedDocumentCountAggregateOutputType = {
    publishedDocumentID: number
    documentID: number
    content: number
    url: number
    userID: number
    publishedAt: number
    updatedAt: number
    title: number
    subtitle: number
    _all: number
  }


  export type PublishedDocumentMinAggregateInputType = {
    publishedDocumentID?: true
    documentID?: true
    url?: true
    userID?: true
    publishedAt?: true
    updatedAt?: true
    title?: true
    subtitle?: true
  }

  export type PublishedDocumentMaxAggregateInputType = {
    publishedDocumentID?: true
    documentID?: true
    url?: true
    userID?: true
    publishedAt?: true
    updatedAt?: true
    title?: true
    subtitle?: true
  }

  export type PublishedDocumentCountAggregateInputType = {
    publishedDocumentID?: true
    documentID?: true
    content?: true
    url?: true
    userID?: true
    publishedAt?: true
    updatedAt?: true
    title?: true
    subtitle?: true
    _all?: true
  }

  export type PublishedDocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublishedDocument to aggregate.
     */
    where?: PublishedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublishedDocuments to fetch.
     */
    orderBy?: Enumerable<PublishedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublishedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublishedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublishedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PublishedDocuments
    **/
    _count?: true | PublishedDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublishedDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublishedDocumentMaxAggregateInputType
  }

  export type GetPublishedDocumentAggregateType<T extends PublishedDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregatePublishedDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublishedDocument[P]>
      : GetScalarType<T[P], AggregatePublishedDocument[P]>
  }




  export type PublishedDocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PublishedDocumentWhereInput
    orderBy?: Enumerable<PublishedDocumentOrderByWithAggregationInput>
    by: PublishedDocumentScalarFieldEnum[]
    having?: PublishedDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublishedDocumentCountAggregateInputType | true
    _min?: PublishedDocumentMinAggregateInputType
    _max?: PublishedDocumentMaxAggregateInputType
  }


  export type PublishedDocumentGroupByOutputType = {
    publishedDocumentID: string
    documentID: string
    content: JsonValue | null
    url: string
    userID: string
    publishedAt: Date
    updatedAt: Date
    title: string
    subtitle: string | null
    _count: PublishedDocumentCountAggregateOutputType | null
    _min: PublishedDocumentMinAggregateOutputType | null
    _max: PublishedDocumentMaxAggregateOutputType | null
  }

  type GetPublishedDocumentGroupByPayload<T extends PublishedDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PublishedDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublishedDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublishedDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PublishedDocumentGroupByOutputType[P]>
        }
      >
    >


  export type PublishedDocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publishedDocumentID?: boolean
    documentID?: boolean
    content?: boolean
    url?: boolean
    userID?: boolean
    publishedAt?: boolean
    updatedAt?: boolean
    title?: boolean
    subtitle?: boolean
    document?: boolean | DocumentArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    likingUsers?: boolean | PublishedDocument$likingUsersArgs<ExtArgs>
    _count?: boolean | PublishedDocumentCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["publishedDocument"]>

  export type PublishedDocumentSelectScalar = {
    publishedDocumentID?: boolean
    documentID?: boolean
    content?: boolean
    url?: boolean
    userID?: boolean
    publishedAt?: boolean
    updatedAt?: boolean
    title?: boolean
    subtitle?: boolean
  }

  export type PublishedDocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    likingUsers?: boolean | PublishedDocument$likingUsersArgs<ExtArgs>
    _count?: boolean | PublishedDocumentCountOutputTypeArgs<ExtArgs>
  }


  type PublishedDocumentGetPayload<S extends boolean | null | undefined | PublishedDocumentArgs> = $Types.GetResult<PublishedDocumentPayload, S>

  type PublishedDocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PublishedDocumentFindManyArgs, 'select' | 'include'> & {
      select?: PublishedDocumentCountAggregateInputType | true
    }

  export interface PublishedDocumentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublishedDocument'], meta: { name: 'PublishedDocument' } }
    /**
     * Find zero or one PublishedDocument that matches the filter.
     * @param {PublishedDocumentFindUniqueArgs} args - Arguments to find a PublishedDocument
     * @example
     * // Get one PublishedDocument
     * const publishedDocument = await prisma.publishedDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PublishedDocumentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PublishedDocumentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PublishedDocument'> extends True ? Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one PublishedDocument that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PublishedDocumentFindUniqueOrThrowArgs} args - Arguments to find a PublishedDocument
     * @example
     * // Get one PublishedDocument
     * const publishedDocument = await prisma.publishedDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PublishedDocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PublishedDocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first PublishedDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedDocumentFindFirstArgs} args - Arguments to find a PublishedDocument
     * @example
     * // Get one PublishedDocument
     * const publishedDocument = await prisma.publishedDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PublishedDocumentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PublishedDocumentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PublishedDocument'> extends True ? Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first PublishedDocument that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedDocumentFindFirstOrThrowArgs} args - Arguments to find a PublishedDocument
     * @example
     * // Get one PublishedDocument
     * const publishedDocument = await prisma.publishedDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PublishedDocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PublishedDocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more PublishedDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedDocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublishedDocuments
     * const publishedDocuments = await prisma.publishedDocument.findMany()
     * 
     * // Get first 10 PublishedDocuments
     * const publishedDocuments = await prisma.publishedDocument.findMany({ take: 10 })
     * 
     * // Only select the `publishedDocumentID`
     * const publishedDocumentWithPublishedDocumentIDOnly = await prisma.publishedDocument.findMany({ select: { publishedDocumentID: true } })
     * 
    **/
    findMany<T extends PublishedDocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublishedDocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a PublishedDocument.
     * @param {PublishedDocumentCreateArgs} args - Arguments to create a PublishedDocument.
     * @example
     * // Create one PublishedDocument
     * const PublishedDocument = await prisma.publishedDocument.create({
     *   data: {
     *     // ... data to create a PublishedDocument
     *   }
     * })
     * 
    **/
    create<T extends PublishedDocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PublishedDocumentCreateArgs<ExtArgs>>
    ): Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many PublishedDocuments.
     *     @param {PublishedDocumentCreateManyArgs} args - Arguments to create many PublishedDocuments.
     *     @example
     *     // Create many PublishedDocuments
     *     const publishedDocument = await prisma.publishedDocument.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PublishedDocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublishedDocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PublishedDocument.
     * @param {PublishedDocumentDeleteArgs} args - Arguments to delete one PublishedDocument.
     * @example
     * // Delete one PublishedDocument
     * const PublishedDocument = await prisma.publishedDocument.delete({
     *   where: {
     *     // ... filter to delete one PublishedDocument
     *   }
     * })
     * 
    **/
    delete<T extends PublishedDocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PublishedDocumentDeleteArgs<ExtArgs>>
    ): Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one PublishedDocument.
     * @param {PublishedDocumentUpdateArgs} args - Arguments to update one PublishedDocument.
     * @example
     * // Update one PublishedDocument
     * const publishedDocument = await prisma.publishedDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PublishedDocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PublishedDocumentUpdateArgs<ExtArgs>>
    ): Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more PublishedDocuments.
     * @param {PublishedDocumentDeleteManyArgs} args - Arguments to filter PublishedDocuments to delete.
     * @example
     * // Delete a few PublishedDocuments
     * const { count } = await prisma.publishedDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PublishedDocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublishedDocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublishedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublishedDocuments
     * const publishedDocument = await prisma.publishedDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PublishedDocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PublishedDocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PublishedDocument.
     * @param {PublishedDocumentUpsertArgs} args - Arguments to update or create a PublishedDocument.
     * @example
     * // Update or create a PublishedDocument
     * const publishedDocument = await prisma.publishedDocument.upsert({
     *   create: {
     *     // ... data to create a PublishedDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublishedDocument we want to update
     *   }
     * })
    **/
    upsert<T extends PublishedDocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PublishedDocumentUpsertArgs<ExtArgs>>
    ): Prisma__PublishedDocumentClient<$Types.GetResult<PublishedDocumentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of PublishedDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedDocumentCountArgs} args - Arguments to filter PublishedDocuments to count.
     * @example
     * // Count the number of PublishedDocuments
     * const count = await prisma.publishedDocument.count({
     *   where: {
     *     // ... the filter for the PublishedDocuments we want to count
     *   }
     * })
    **/
    count<T extends PublishedDocumentCountArgs>(
      args?: Subset<T, PublishedDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublishedDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublishedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublishedDocumentAggregateArgs>(args: Subset<T, PublishedDocumentAggregateArgs>): Prisma.PrismaPromise<GetPublishedDocumentAggregateType<T>>

    /**
     * Group by PublishedDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublishedDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublishedDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PublishedDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublishedDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublishedDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PublishedDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PublishedDocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    likingUsers<T extends PublishedDocument$likingUsersArgs<ExtArgs> = {}>(args?: Subset<T, PublishedDocument$likingUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PublishedDocument base type for findUnique actions
   */
  export type PublishedDocumentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PublishedDocument to fetch.
     */
    where: PublishedDocumentWhereUniqueInput
  }

  /**
   * PublishedDocument findUnique
   */
  export interface PublishedDocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PublishedDocumentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PublishedDocument findUniqueOrThrow
   */
  export type PublishedDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PublishedDocument to fetch.
     */
    where: PublishedDocumentWhereUniqueInput
  }


  /**
   * PublishedDocument base type for findFirst actions
   */
  export type PublishedDocumentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PublishedDocument to fetch.
     */
    where?: PublishedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublishedDocuments to fetch.
     */
    orderBy?: Enumerable<PublishedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublishedDocuments.
     */
    cursor?: PublishedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublishedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublishedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublishedDocuments.
     */
    distinct?: Enumerable<PublishedDocumentScalarFieldEnum>
  }

  /**
   * PublishedDocument findFirst
   */
  export interface PublishedDocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends PublishedDocumentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PublishedDocument findFirstOrThrow
   */
  export type PublishedDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PublishedDocument to fetch.
     */
    where?: PublishedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublishedDocuments to fetch.
     */
    orderBy?: Enumerable<PublishedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PublishedDocuments.
     */
    cursor?: PublishedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublishedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublishedDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PublishedDocuments.
     */
    distinct?: Enumerable<PublishedDocumentScalarFieldEnum>
  }


  /**
   * PublishedDocument findMany
   */
  export type PublishedDocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PublishedDocuments to fetch.
     */
    where?: PublishedDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PublishedDocuments to fetch.
     */
    orderBy?: Enumerable<PublishedDocumentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PublishedDocuments.
     */
    cursor?: PublishedDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PublishedDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PublishedDocuments.
     */
    skip?: number
    distinct?: Enumerable<PublishedDocumentScalarFieldEnum>
  }


  /**
   * PublishedDocument create
   */
  export type PublishedDocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a PublishedDocument.
     */
    data: XOR<PublishedDocumentCreateInput, PublishedDocumentUncheckedCreateInput>
  }


  /**
   * PublishedDocument createMany
   */
  export type PublishedDocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublishedDocuments.
     */
    data: Enumerable<PublishedDocumentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PublishedDocument update
   */
  export type PublishedDocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a PublishedDocument.
     */
    data: XOR<PublishedDocumentUpdateInput, PublishedDocumentUncheckedUpdateInput>
    /**
     * Choose, which PublishedDocument to update.
     */
    where: PublishedDocumentWhereUniqueInput
  }


  /**
   * PublishedDocument updateMany
   */
  export type PublishedDocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublishedDocuments.
     */
    data: XOR<PublishedDocumentUpdateManyMutationInput, PublishedDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PublishedDocuments to update
     */
    where?: PublishedDocumentWhereInput
  }


  /**
   * PublishedDocument upsert
   */
  export type PublishedDocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the PublishedDocument to update in case it exists.
     */
    where: PublishedDocumentWhereUniqueInput
    /**
     * In case the PublishedDocument found by the `where` argument doesn't exist, create a new PublishedDocument with this data.
     */
    create: XOR<PublishedDocumentCreateInput, PublishedDocumentUncheckedCreateInput>
    /**
     * In case the PublishedDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublishedDocumentUpdateInput, PublishedDocumentUncheckedUpdateInput>
  }


  /**
   * PublishedDocument delete
   */
  export type PublishedDocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
    /**
     * Filter which PublishedDocument to delete.
     */
    where: PublishedDocumentWhereUniqueInput
  }


  /**
   * PublishedDocument deleteMany
   */
  export type PublishedDocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublishedDocuments to delete
     */
    where?: PublishedDocumentWhereInput
  }


  /**
   * PublishedDocument.likingUsers
   */
  export type PublishedDocument$likingUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * PublishedDocument without action
   */
  export type PublishedDocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedDocument
     */
    select?: PublishedDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublishedDocumentInclude<ExtArgs> | null
  }



  /**
   * Model ScratchpadEntry
   */


  export type AggregateScratchpadEntry = {
    _count: ScratchpadEntryCountAggregateOutputType | null
    _min: ScratchpadEntryMinAggregateOutputType | null
    _max: ScratchpadEntryMaxAggregateOutputType | null
  }

  export type ScratchpadEntryMinAggregateOutputType = {
    scratchpadEntryID: string | null
    date: Date | null
    userID: string | null
  }

  export type ScratchpadEntryMaxAggregateOutputType = {
    scratchpadEntryID: string | null
    date: Date | null
    userID: string | null
  }

  export type ScratchpadEntryCountAggregateOutputType = {
    scratchpadEntryID: number
    content: number
    date: number
    userID: number
    _all: number
  }


  export type ScratchpadEntryMinAggregateInputType = {
    scratchpadEntryID?: true
    date?: true
    userID?: true
  }

  export type ScratchpadEntryMaxAggregateInputType = {
    scratchpadEntryID?: true
    date?: true
    userID?: true
  }

  export type ScratchpadEntryCountAggregateInputType = {
    scratchpadEntryID?: true
    content?: true
    date?: true
    userID?: true
    _all?: true
  }

  export type ScratchpadEntryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScratchpadEntry to aggregate.
     */
    where?: ScratchpadEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScratchpadEntries to fetch.
     */
    orderBy?: Enumerable<ScratchpadEntryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScratchpadEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScratchpadEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScratchpadEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScratchpadEntries
    **/
    _count?: true | ScratchpadEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScratchpadEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScratchpadEntryMaxAggregateInputType
  }

  export type GetScratchpadEntryAggregateType<T extends ScratchpadEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateScratchpadEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScratchpadEntry[P]>
      : GetScalarType<T[P], AggregateScratchpadEntry[P]>
  }




  export type ScratchpadEntryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ScratchpadEntryWhereInput
    orderBy?: Enumerable<ScratchpadEntryOrderByWithAggregationInput>
    by: ScratchpadEntryScalarFieldEnum[]
    having?: ScratchpadEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScratchpadEntryCountAggregateInputType | true
    _min?: ScratchpadEntryMinAggregateInputType
    _max?: ScratchpadEntryMaxAggregateInputType
  }


  export type ScratchpadEntryGroupByOutputType = {
    scratchpadEntryID: string
    content: JsonValue | null
    date: Date
    userID: string
    _count: ScratchpadEntryCountAggregateOutputType | null
    _min: ScratchpadEntryMinAggregateOutputType | null
    _max: ScratchpadEntryMaxAggregateOutputType | null
  }

  type GetScratchpadEntryGroupByPayload<T extends ScratchpadEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ScratchpadEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScratchpadEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScratchpadEntryGroupByOutputType[P]>
            : GetScalarType<T[P], ScratchpadEntryGroupByOutputType[P]>
        }
      >
    >


  export type ScratchpadEntrySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    scratchpadEntryID?: boolean
    content?: boolean
    date?: boolean
    userID?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["scratchpadEntry"]>

  export type ScratchpadEntrySelectScalar = {
    scratchpadEntryID?: boolean
    content?: boolean
    date?: boolean
    userID?: boolean
  }

  export type ScratchpadEntryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type ScratchpadEntryGetPayload<S extends boolean | null | undefined | ScratchpadEntryArgs> = $Types.GetResult<ScratchpadEntryPayload, S>

  type ScratchpadEntryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ScratchpadEntryFindManyArgs, 'select' | 'include'> & {
      select?: ScratchpadEntryCountAggregateInputType | true
    }

  export interface ScratchpadEntryDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScratchpadEntry'], meta: { name: 'ScratchpadEntry' } }
    /**
     * Find zero or one ScratchpadEntry that matches the filter.
     * @param {ScratchpadEntryFindUniqueArgs} args - Arguments to find a ScratchpadEntry
     * @example
     * // Get one ScratchpadEntry
     * const scratchpadEntry = await prisma.scratchpadEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ScratchpadEntryFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ScratchpadEntryFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ScratchpadEntry'> extends True ? Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one ScratchpadEntry that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ScratchpadEntryFindUniqueOrThrowArgs} args - Arguments to find a ScratchpadEntry
     * @example
     * // Get one ScratchpadEntry
     * const scratchpadEntry = await prisma.scratchpadEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ScratchpadEntryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScratchpadEntryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first ScratchpadEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScratchpadEntryFindFirstArgs} args - Arguments to find a ScratchpadEntry
     * @example
     * // Get one ScratchpadEntry
     * const scratchpadEntry = await prisma.scratchpadEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ScratchpadEntryFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ScratchpadEntryFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ScratchpadEntry'> extends True ? Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first ScratchpadEntry that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScratchpadEntryFindFirstOrThrowArgs} args - Arguments to find a ScratchpadEntry
     * @example
     * // Get one ScratchpadEntry
     * const scratchpadEntry = await prisma.scratchpadEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ScratchpadEntryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ScratchpadEntryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more ScratchpadEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScratchpadEntryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScratchpadEntries
     * const scratchpadEntries = await prisma.scratchpadEntry.findMany()
     * 
     * // Get first 10 ScratchpadEntries
     * const scratchpadEntries = await prisma.scratchpadEntry.findMany({ take: 10 })
     * 
     * // Only select the `scratchpadEntryID`
     * const scratchpadEntryWithScratchpadEntryIDOnly = await prisma.scratchpadEntry.findMany({ select: { scratchpadEntryID: true } })
     * 
    **/
    findMany<T extends ScratchpadEntryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScratchpadEntryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a ScratchpadEntry.
     * @param {ScratchpadEntryCreateArgs} args - Arguments to create a ScratchpadEntry.
     * @example
     * // Create one ScratchpadEntry
     * const ScratchpadEntry = await prisma.scratchpadEntry.create({
     *   data: {
     *     // ... data to create a ScratchpadEntry
     *   }
     * })
     * 
    **/
    create<T extends ScratchpadEntryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ScratchpadEntryCreateArgs<ExtArgs>>
    ): Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many ScratchpadEntries.
     *     @param {ScratchpadEntryCreateManyArgs} args - Arguments to create many ScratchpadEntries.
     *     @example
     *     // Create many ScratchpadEntries
     *     const scratchpadEntry = await prisma.scratchpadEntry.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ScratchpadEntryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScratchpadEntryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ScratchpadEntry.
     * @param {ScratchpadEntryDeleteArgs} args - Arguments to delete one ScratchpadEntry.
     * @example
     * // Delete one ScratchpadEntry
     * const ScratchpadEntry = await prisma.scratchpadEntry.delete({
     *   where: {
     *     // ... filter to delete one ScratchpadEntry
     *   }
     * })
     * 
    **/
    delete<T extends ScratchpadEntryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ScratchpadEntryDeleteArgs<ExtArgs>>
    ): Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one ScratchpadEntry.
     * @param {ScratchpadEntryUpdateArgs} args - Arguments to update one ScratchpadEntry.
     * @example
     * // Update one ScratchpadEntry
     * const scratchpadEntry = await prisma.scratchpadEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ScratchpadEntryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ScratchpadEntryUpdateArgs<ExtArgs>>
    ): Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more ScratchpadEntries.
     * @param {ScratchpadEntryDeleteManyArgs} args - Arguments to filter ScratchpadEntries to delete.
     * @example
     * // Delete a few ScratchpadEntries
     * const { count } = await prisma.scratchpadEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ScratchpadEntryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ScratchpadEntryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScratchpadEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScratchpadEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScratchpadEntries
     * const scratchpadEntry = await prisma.scratchpadEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ScratchpadEntryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ScratchpadEntryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ScratchpadEntry.
     * @param {ScratchpadEntryUpsertArgs} args - Arguments to update or create a ScratchpadEntry.
     * @example
     * // Update or create a ScratchpadEntry
     * const scratchpadEntry = await prisma.scratchpadEntry.upsert({
     *   create: {
     *     // ... data to create a ScratchpadEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScratchpadEntry we want to update
     *   }
     * })
    **/
    upsert<T extends ScratchpadEntryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ScratchpadEntryUpsertArgs<ExtArgs>>
    ): Prisma__ScratchpadEntryClient<$Types.GetResult<ScratchpadEntryPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of ScratchpadEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScratchpadEntryCountArgs} args - Arguments to filter ScratchpadEntries to count.
     * @example
     * // Count the number of ScratchpadEntries
     * const count = await prisma.scratchpadEntry.count({
     *   where: {
     *     // ... the filter for the ScratchpadEntries we want to count
     *   }
     * })
    **/
    count<T extends ScratchpadEntryCountArgs>(
      args?: Subset<T, ScratchpadEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScratchpadEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScratchpadEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScratchpadEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScratchpadEntryAggregateArgs>(args: Subset<T, ScratchpadEntryAggregateArgs>): Prisma.PrismaPromise<GetScratchpadEntryAggregateType<T>>

    /**
     * Group by ScratchpadEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScratchpadEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScratchpadEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScratchpadEntryGroupByArgs['orderBy'] }
        : { orderBy?: ScratchpadEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScratchpadEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScratchpadEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ScratchpadEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ScratchpadEntryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ScratchpadEntry base type for findUnique actions
   */
  export type ScratchpadEntryFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * Filter, which ScratchpadEntry to fetch.
     */
    where: ScratchpadEntryWhereUniqueInput
  }

  /**
   * ScratchpadEntry findUnique
   */
  export interface ScratchpadEntryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ScratchpadEntryFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ScratchpadEntry findUniqueOrThrow
   */
  export type ScratchpadEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * Filter, which ScratchpadEntry to fetch.
     */
    where: ScratchpadEntryWhereUniqueInput
  }


  /**
   * ScratchpadEntry base type for findFirst actions
   */
  export type ScratchpadEntryFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * Filter, which ScratchpadEntry to fetch.
     */
    where?: ScratchpadEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScratchpadEntries to fetch.
     */
    orderBy?: Enumerable<ScratchpadEntryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScratchpadEntries.
     */
    cursor?: ScratchpadEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScratchpadEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScratchpadEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScratchpadEntries.
     */
    distinct?: Enumerable<ScratchpadEntryScalarFieldEnum>
  }

  /**
   * ScratchpadEntry findFirst
   */
  export interface ScratchpadEntryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends ScratchpadEntryFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ScratchpadEntry findFirstOrThrow
   */
  export type ScratchpadEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * Filter, which ScratchpadEntry to fetch.
     */
    where?: ScratchpadEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScratchpadEntries to fetch.
     */
    orderBy?: Enumerable<ScratchpadEntryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScratchpadEntries.
     */
    cursor?: ScratchpadEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScratchpadEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScratchpadEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScratchpadEntries.
     */
    distinct?: Enumerable<ScratchpadEntryScalarFieldEnum>
  }


  /**
   * ScratchpadEntry findMany
   */
  export type ScratchpadEntryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * Filter, which ScratchpadEntries to fetch.
     */
    where?: ScratchpadEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScratchpadEntries to fetch.
     */
    orderBy?: Enumerable<ScratchpadEntryOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScratchpadEntries.
     */
    cursor?: ScratchpadEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ScratchpadEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScratchpadEntries.
     */
    skip?: number
    distinct?: Enumerable<ScratchpadEntryScalarFieldEnum>
  }


  /**
   * ScratchpadEntry create
   */
  export type ScratchpadEntryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a ScratchpadEntry.
     */
    data: XOR<ScratchpadEntryCreateInput, ScratchpadEntryUncheckedCreateInput>
  }


  /**
   * ScratchpadEntry createMany
   */
  export type ScratchpadEntryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScratchpadEntries.
     */
    data: Enumerable<ScratchpadEntryCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ScratchpadEntry update
   */
  export type ScratchpadEntryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a ScratchpadEntry.
     */
    data: XOR<ScratchpadEntryUpdateInput, ScratchpadEntryUncheckedUpdateInput>
    /**
     * Choose, which ScratchpadEntry to update.
     */
    where: ScratchpadEntryWhereUniqueInput
  }


  /**
   * ScratchpadEntry updateMany
   */
  export type ScratchpadEntryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScratchpadEntries.
     */
    data: XOR<ScratchpadEntryUpdateManyMutationInput, ScratchpadEntryUncheckedUpdateManyInput>
    /**
     * Filter which ScratchpadEntries to update
     */
    where?: ScratchpadEntryWhereInput
  }


  /**
   * ScratchpadEntry upsert
   */
  export type ScratchpadEntryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the ScratchpadEntry to update in case it exists.
     */
    where: ScratchpadEntryWhereUniqueInput
    /**
     * In case the ScratchpadEntry found by the `where` argument doesn't exist, create a new ScratchpadEntry with this data.
     */
    create: XOR<ScratchpadEntryCreateInput, ScratchpadEntryUncheckedCreateInput>
    /**
     * In case the ScratchpadEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScratchpadEntryUpdateInput, ScratchpadEntryUncheckedUpdateInput>
  }


  /**
   * ScratchpadEntry delete
   */
  export type ScratchpadEntryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
    /**
     * Filter which ScratchpadEntry to delete.
     */
    where: ScratchpadEntryWhereUniqueInput
  }


  /**
   * ScratchpadEntry deleteMany
   */
  export type ScratchpadEntryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScratchpadEntries to delete
     */
    where?: ScratchpadEntryWhereInput
  }


  /**
   * ScratchpadEntry without action
   */
  export type ScratchpadEntryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScratchpadEntry
     */
    select?: ScratchpadEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ScratchpadEntryInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */


  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    commentID: string | null
    authorID: string | null
    documentVersionID: string | null
    updatedAt: Date | null
    private: boolean | null
    resolved: boolean | null
    selectedText: string | null
  }

  export type CommentMaxAggregateOutputType = {
    commentID: string | null
    authorID: string | null
    documentVersionID: string | null
    updatedAt: Date | null
    private: boolean | null
    resolved: boolean | null
    selectedText: string | null
  }

  export type CommentCountAggregateOutputType = {
    commentID: number
    commentData: number
    authorID: number
    documentVersionID: number
    updatedAt: number
    private: number
    resolved: number
    selectedText: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    commentID?: true
    authorID?: true
    documentVersionID?: true
    updatedAt?: true
    private?: true
    resolved?: true
    selectedText?: true
  }

  export type CommentMaxAggregateInputType = {
    commentID?: true
    authorID?: true
    documentVersionID?: true
    updatedAt?: true
    private?: true
    resolved?: true
    selectedText?: true
  }

  export type CommentCountAggregateInputType = {
    commentID?: true
    commentData?: true
    authorID?: true
    documentVersionID?: true
    updatedAt?: true
    private?: true
    resolved?: true
    selectedText?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: Enumerable<CommentOrderByWithAggregationInput>
    by: CommentScalarFieldEnum[]
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }


  export type CommentGroupByOutputType = {
    commentID: string
    commentData: JsonValue
    authorID: string
    documentVersionID: string
    updatedAt: Date
    private: boolean
    resolved: boolean
    selectedText: string
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    commentID?: boolean
    commentData?: boolean
    authorID?: boolean
    documentVersionID?: boolean
    updatedAt?: boolean
    private?: boolean
    resolved?: boolean
    selectedText?: boolean
    author?: boolean | UserArgs<ExtArgs>
    documentVersion?: boolean | DocumentVersionArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    commentID?: boolean
    commentData?: boolean
    authorID?: boolean
    documentVersionID?: boolean
    updatedAt?: boolean
    private?: boolean
    resolved?: boolean
    selectedText?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    author?: boolean | UserArgs<ExtArgs>
    documentVersion?: boolean | DocumentVersionArgs<ExtArgs>
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentArgs> = $Types.GetResult<CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Comment'> extends True ? Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Comment'> extends True ? Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `commentID`
     * const commentWithCommentIDOnly = await prisma.comment.findMany({ select: { commentID: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<CommentPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Types.GetResult<CommentPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    author<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documentVersion<T extends DocumentVersionArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersionArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Comment base type for findUnique actions
   */
  export type CommentFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUnique
   */
  export interface CommentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment base type for findFirst actions
   */
  export type CommentFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }

  /**
   * Comment findFirst
   */
  export interface CommentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends CommentFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: Enumerable<CommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: Enumerable<CommentScalarFieldEnum>
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: Enumerable<CommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Model UserDocumentPermission
   */


  export type AggregateUserDocumentPermission = {
    _count: UserDocumentPermissionCountAggregateOutputType | null
    _min: UserDocumentPermissionMinAggregateOutputType | null
    _max: UserDocumentPermissionMaxAggregateOutputType | null
  }

  export type UserDocumentPermissionMinAggregateOutputType = {
    userDocumentPermissionID: string | null
    userID: string | null
    documentVersionID: string | null
    role: Role | null
    documentID: string | null
  }

  export type UserDocumentPermissionMaxAggregateOutputType = {
    userDocumentPermissionID: string | null
    userID: string | null
    documentVersionID: string | null
    role: Role | null
    documentID: string | null
  }

  export type UserDocumentPermissionCountAggregateOutputType = {
    userDocumentPermissionID: number
    userID: number
    documentVersionID: number
    role: number
    documentID: number
    _all: number
  }


  export type UserDocumentPermissionMinAggregateInputType = {
    userDocumentPermissionID?: true
    userID?: true
    documentVersionID?: true
    role?: true
    documentID?: true
  }

  export type UserDocumentPermissionMaxAggregateInputType = {
    userDocumentPermissionID?: true
    userID?: true
    documentVersionID?: true
    role?: true
    documentID?: true
  }

  export type UserDocumentPermissionCountAggregateInputType = {
    userDocumentPermissionID?: true
    userID?: true
    documentVersionID?: true
    role?: true
    documentID?: true
    _all?: true
  }

  export type UserDocumentPermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocumentPermission to aggregate.
     */
    where?: UserDocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDocumentPermissions
    **/
    _count?: true | UserDocumentPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDocumentPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDocumentPermissionMaxAggregateInputType
  }

  export type GetUserDocumentPermissionAggregateType<T extends UserDocumentPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDocumentPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDocumentPermission[P]>
      : GetScalarType<T[P], AggregateUserDocumentPermission[P]>
  }




  export type UserDocumentPermissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentPermissionWhereInput
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithAggregationInput>
    by: UserDocumentPermissionScalarFieldEnum[]
    having?: UserDocumentPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDocumentPermissionCountAggregateInputType | true
    _min?: UserDocumentPermissionMinAggregateInputType
    _max?: UserDocumentPermissionMaxAggregateInputType
  }


  export type UserDocumentPermissionGroupByOutputType = {
    userDocumentPermissionID: string
    userID: string
    documentVersionID: string | null
    role: Role
    documentID: string | null
    _count: UserDocumentPermissionCountAggregateOutputType | null
    _min: UserDocumentPermissionMinAggregateOutputType | null
    _max: UserDocumentPermissionMaxAggregateOutputType | null
  }

  type GetUserDocumentPermissionGroupByPayload<T extends UserDocumentPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserDocumentPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDocumentPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDocumentPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserDocumentPermissionGroupByOutputType[P]>
        }
      >
    >


  export type UserDocumentPermissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userDocumentPermissionID?: boolean
    userID?: boolean
    documentVersionID?: boolean
    role?: boolean
    documentID?: boolean
    user?: boolean | UserArgs<ExtArgs>
    documentVersion?: boolean | DocumentVersionArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
  }, ExtArgs["result"]["userDocumentPermission"]>

  export type UserDocumentPermissionSelectScalar = {
    userDocumentPermissionID?: boolean
    userID?: boolean
    documentVersionID?: boolean
    role?: boolean
    documentID?: boolean
  }

  export type UserDocumentPermissionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    documentVersion?: boolean | DocumentVersionArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
  }


  type UserDocumentPermissionGetPayload<S extends boolean | null | undefined | UserDocumentPermissionArgs> = $Types.GetResult<UserDocumentPermissionPayload, S>

  type UserDocumentPermissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserDocumentPermissionFindManyArgs, 'select' | 'include'> & {
      select?: UserDocumentPermissionCountAggregateInputType | true
    }

  export interface UserDocumentPermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDocumentPermission'], meta: { name: 'UserDocumentPermission' } }
    /**
     * Find zero or one UserDocumentPermission that matches the filter.
     * @param {UserDocumentPermissionFindUniqueArgs} args - Arguments to find a UserDocumentPermission
     * @example
     * // Get one UserDocumentPermission
     * const userDocumentPermission = await prisma.userDocumentPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserDocumentPermissionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserDocumentPermissionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserDocumentPermission'> extends True ? Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserDocumentPermission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserDocumentPermissionFindUniqueOrThrowArgs} args - Arguments to find a UserDocumentPermission
     * @example
     * // Get one UserDocumentPermission
     * const userDocumentPermission = await prisma.userDocumentPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserDocumentPermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentPermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserDocumentPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentPermissionFindFirstArgs} args - Arguments to find a UserDocumentPermission
     * @example
     * // Get one UserDocumentPermission
     * const userDocumentPermission = await prisma.userDocumentPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserDocumentPermissionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserDocumentPermissionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserDocumentPermission'> extends True ? Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserDocumentPermission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentPermissionFindFirstOrThrowArgs} args - Arguments to find a UserDocumentPermission
     * @example
     * // Get one UserDocumentPermission
     * const userDocumentPermission = await prisma.userDocumentPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserDocumentPermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentPermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserDocumentPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentPermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDocumentPermissions
     * const userDocumentPermissions = await prisma.userDocumentPermission.findMany()
     * 
     * // Get first 10 UserDocumentPermissions
     * const userDocumentPermissions = await prisma.userDocumentPermission.findMany({ take: 10 })
     * 
     * // Only select the `userDocumentPermissionID`
     * const userDocumentPermissionWithUserDocumentPermissionIDOnly = await prisma.userDocumentPermission.findMany({ select: { userDocumentPermissionID: true } })
     * 
    **/
    findMany<T extends UserDocumentPermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentPermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserDocumentPermission.
     * @param {UserDocumentPermissionCreateArgs} args - Arguments to create a UserDocumentPermission.
     * @example
     * // Create one UserDocumentPermission
     * const UserDocumentPermission = await prisma.userDocumentPermission.create({
     *   data: {
     *     // ... data to create a UserDocumentPermission
     *   }
     * })
     * 
    **/
    create<T extends UserDocumentPermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentPermissionCreateArgs<ExtArgs>>
    ): Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserDocumentPermissions.
     *     @param {UserDocumentPermissionCreateManyArgs} args - Arguments to create many UserDocumentPermissions.
     *     @example
     *     // Create many UserDocumentPermissions
     *     const userDocumentPermission = await prisma.userDocumentPermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserDocumentPermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentPermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserDocumentPermission.
     * @param {UserDocumentPermissionDeleteArgs} args - Arguments to delete one UserDocumentPermission.
     * @example
     * // Delete one UserDocumentPermission
     * const UserDocumentPermission = await prisma.userDocumentPermission.delete({
     *   where: {
     *     // ... filter to delete one UserDocumentPermission
     *   }
     * })
     * 
    **/
    delete<T extends UserDocumentPermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentPermissionDeleteArgs<ExtArgs>>
    ): Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserDocumentPermission.
     * @param {UserDocumentPermissionUpdateArgs} args - Arguments to update one UserDocumentPermission.
     * @example
     * // Update one UserDocumentPermission
     * const userDocumentPermission = await prisma.userDocumentPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserDocumentPermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentPermissionUpdateArgs<ExtArgs>>
    ): Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserDocumentPermissions.
     * @param {UserDocumentPermissionDeleteManyArgs} args - Arguments to filter UserDocumentPermissions to delete.
     * @example
     * // Delete a few UserDocumentPermissions
     * const { count } = await prisma.userDocumentPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDocumentPermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentPermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDocumentPermissions
     * const userDocumentPermission = await prisma.userDocumentPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserDocumentPermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentPermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserDocumentPermission.
     * @param {UserDocumentPermissionUpsertArgs} args - Arguments to update or create a UserDocumentPermission.
     * @example
     * // Update or create a UserDocumentPermission
     * const userDocumentPermission = await prisma.userDocumentPermission.upsert({
     *   create: {
     *     // ... data to create a UserDocumentPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDocumentPermission we want to update
     *   }
     * })
    **/
    upsert<T extends UserDocumentPermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentPermissionUpsertArgs<ExtArgs>>
    ): Prisma__UserDocumentPermissionClient<$Types.GetResult<UserDocumentPermissionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserDocumentPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentPermissionCountArgs} args - Arguments to filter UserDocumentPermissions to count.
     * @example
     * // Count the number of UserDocumentPermissions
     * const count = await prisma.userDocumentPermission.count({
     *   where: {
     *     // ... the filter for the UserDocumentPermissions we want to count
     *   }
     * })
    **/
    count<T extends UserDocumentPermissionCountArgs>(
      args?: Subset<T, UserDocumentPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDocumentPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDocumentPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDocumentPermissionAggregateArgs>(args: Subset<T, UserDocumentPermissionAggregateArgs>): Prisma.PrismaPromise<GetUserDocumentPermissionAggregateType<T>>

    /**
     * Group by UserDocumentPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDocumentPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDocumentPermissionGroupByArgs['orderBy'] }
        : { orderBy?: UserDocumentPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDocumentPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDocumentPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDocumentPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserDocumentPermissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documentVersion<T extends DocumentVersionArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersionArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserDocumentPermission base type for findUnique actions
   */
  export type UserDocumentPermissionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentPermission to fetch.
     */
    where: UserDocumentPermissionWhereUniqueInput
  }

  /**
   * UserDocumentPermission findUnique
   */
  export interface UserDocumentPermissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentPermissionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocumentPermission findUniqueOrThrow
   */
  export type UserDocumentPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentPermission to fetch.
     */
    where: UserDocumentPermissionWhereUniqueInput
  }


  /**
   * UserDocumentPermission base type for findFirst actions
   */
  export type UserDocumentPermissionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentPermission to fetch.
     */
    where?: UserDocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocumentPermissions.
     */
    cursor?: UserDocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocumentPermissions.
     */
    distinct?: Enumerable<UserDocumentPermissionScalarFieldEnum>
  }

  /**
   * UserDocumentPermission findFirst
   */
  export interface UserDocumentPermissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentPermissionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocumentPermission findFirstOrThrow
   */
  export type UserDocumentPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentPermission to fetch.
     */
    where?: UserDocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocumentPermissions.
     */
    cursor?: UserDocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocumentPermissions.
     */
    distinct?: Enumerable<UserDocumentPermissionScalarFieldEnum>
  }


  /**
   * UserDocumentPermission findMany
   */
  export type UserDocumentPermissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentPermissions to fetch.
     */
    where?: UserDocumentPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentPermissions to fetch.
     */
    orderBy?: Enumerable<UserDocumentPermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDocumentPermissions.
     */
    cursor?: UserDocumentPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentPermissions.
     */
    skip?: number
    distinct?: Enumerable<UserDocumentPermissionScalarFieldEnum>
  }


  /**
   * UserDocumentPermission create
   */
  export type UserDocumentPermissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDocumentPermission.
     */
    data: XOR<UserDocumentPermissionCreateInput, UserDocumentPermissionUncheckedCreateInput>
  }


  /**
   * UserDocumentPermission createMany
   */
  export type UserDocumentPermissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDocumentPermissions.
     */
    data: Enumerable<UserDocumentPermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserDocumentPermission update
   */
  export type UserDocumentPermissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDocumentPermission.
     */
    data: XOR<UserDocumentPermissionUpdateInput, UserDocumentPermissionUncheckedUpdateInput>
    /**
     * Choose, which UserDocumentPermission to update.
     */
    where: UserDocumentPermissionWhereUniqueInput
  }


  /**
   * UserDocumentPermission updateMany
   */
  export type UserDocumentPermissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDocumentPermissions.
     */
    data: XOR<UserDocumentPermissionUpdateManyMutationInput, UserDocumentPermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserDocumentPermissions to update
     */
    where?: UserDocumentPermissionWhereInput
  }


  /**
   * UserDocumentPermission upsert
   */
  export type UserDocumentPermissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDocumentPermission to update in case it exists.
     */
    where: UserDocumentPermissionWhereUniqueInput
    /**
     * In case the UserDocumentPermission found by the `where` argument doesn't exist, create a new UserDocumentPermission with this data.
     */
    create: XOR<UserDocumentPermissionCreateInput, UserDocumentPermissionUncheckedCreateInput>
    /**
     * In case the UserDocumentPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDocumentPermissionUpdateInput, UserDocumentPermissionUncheckedUpdateInput>
  }


  /**
   * UserDocumentPermission delete
   */
  export type UserDocumentPermissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
    /**
     * Filter which UserDocumentPermission to delete.
     */
    where: UserDocumentPermissionWhereUniqueInput
  }


  /**
   * UserDocumentPermission deleteMany
   */
  export type UserDocumentPermissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocumentPermissions to delete
     */
    where?: UserDocumentPermissionWhereInput
  }


  /**
   * UserDocumentPermission without action
   */
  export type UserDocumentPermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentPermission
     */
    select?: UserDocumentPermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentPermissionInclude<ExtArgs> | null
  }



  /**
   * Model UserNotePermission
   */


  export type AggregateUserNotePermission = {
    _count: UserNotePermissionCountAggregateOutputType | null
    _min: UserNotePermissionMinAggregateOutputType | null
    _max: UserNotePermissionMaxAggregateOutputType | null
  }

  export type UserNotePermissionMinAggregateOutputType = {
    userNotePermissionID: string | null
    userID: string | null
    role: NoteRole | null
    noteID: string | null
  }

  export type UserNotePermissionMaxAggregateOutputType = {
    userNotePermissionID: string | null
    userID: string | null
    role: NoteRole | null
    noteID: string | null
  }

  export type UserNotePermissionCountAggregateOutputType = {
    userNotePermissionID: number
    userID: number
    role: number
    noteID: number
    _all: number
  }


  export type UserNotePermissionMinAggregateInputType = {
    userNotePermissionID?: true
    userID?: true
    role?: true
    noteID?: true
  }

  export type UserNotePermissionMaxAggregateInputType = {
    userNotePermissionID?: true
    userID?: true
    role?: true
    noteID?: true
  }

  export type UserNotePermissionCountAggregateInputType = {
    userNotePermissionID?: true
    userID?: true
    role?: true
    noteID?: true
    _all?: true
  }

  export type UserNotePermissionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotePermission to aggregate.
     */
    where?: UserNotePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotePermissions to fetch.
     */
    orderBy?: Enumerable<UserNotePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNotePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNotePermissions
    **/
    _count?: true | UserNotePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotePermissionMaxAggregateInputType
  }

  export type GetUserNotePermissionAggregateType<T extends UserNotePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotePermission[P]>
      : GetScalarType<T[P], AggregateUserNotePermission[P]>
  }




  export type UserNotePermissionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserNotePermissionWhereInput
    orderBy?: Enumerable<UserNotePermissionOrderByWithAggregationInput>
    by: UserNotePermissionScalarFieldEnum[]
    having?: UserNotePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotePermissionCountAggregateInputType | true
    _min?: UserNotePermissionMinAggregateInputType
    _max?: UserNotePermissionMaxAggregateInputType
  }


  export type UserNotePermissionGroupByOutputType = {
    userNotePermissionID: string
    userID: string
    role: NoteRole
    noteID: string
    _count: UserNotePermissionCountAggregateOutputType | null
    _min: UserNotePermissionMinAggregateOutputType | null
    _max: UserNotePermissionMaxAggregateOutputType | null
  }

  type GetUserNotePermissionGroupByPayload<T extends UserNotePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserNotePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotePermissionGroupByOutputType[P]>
        }
      >
    >


  export type UserNotePermissionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userNotePermissionID?: boolean
    userID?: boolean
    role?: boolean
    noteID?: boolean
    user?: boolean | UserArgs<ExtArgs>
    note?: boolean | NoteArgs<ExtArgs>
  }, ExtArgs["result"]["userNotePermission"]>

  export type UserNotePermissionSelectScalar = {
    userNotePermissionID?: boolean
    userID?: boolean
    role?: boolean
    noteID?: boolean
  }

  export type UserNotePermissionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    note?: boolean | NoteArgs<ExtArgs>
  }


  type UserNotePermissionGetPayload<S extends boolean | null | undefined | UserNotePermissionArgs> = $Types.GetResult<UserNotePermissionPayload, S>

  type UserNotePermissionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserNotePermissionFindManyArgs, 'select' | 'include'> & {
      select?: UserNotePermissionCountAggregateInputType | true
    }

  export interface UserNotePermissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNotePermission'], meta: { name: 'UserNotePermission' } }
    /**
     * Find zero or one UserNotePermission that matches the filter.
     * @param {UserNotePermissionFindUniqueArgs} args - Arguments to find a UserNotePermission
     * @example
     * // Get one UserNotePermission
     * const userNotePermission = await prisma.userNotePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserNotePermissionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserNotePermissionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserNotePermission'> extends True ? Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserNotePermission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserNotePermissionFindUniqueOrThrowArgs} args - Arguments to find a UserNotePermission
     * @example
     * // Get one UserNotePermission
     * const userNotePermission = await prisma.userNotePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserNotePermissionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserNotePermissionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserNotePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotePermissionFindFirstArgs} args - Arguments to find a UserNotePermission
     * @example
     * // Get one UserNotePermission
     * const userNotePermission = await prisma.userNotePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserNotePermissionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserNotePermissionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserNotePermission'> extends True ? Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserNotePermission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotePermissionFindFirstOrThrowArgs} args - Arguments to find a UserNotePermission
     * @example
     * // Get one UserNotePermission
     * const userNotePermission = await prisma.userNotePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserNotePermissionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserNotePermissionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserNotePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotePermissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotePermissions
     * const userNotePermissions = await prisma.userNotePermission.findMany()
     * 
     * // Get first 10 UserNotePermissions
     * const userNotePermissions = await prisma.userNotePermission.findMany({ take: 10 })
     * 
     * // Only select the `userNotePermissionID`
     * const userNotePermissionWithUserNotePermissionIDOnly = await prisma.userNotePermission.findMany({ select: { userNotePermissionID: true } })
     * 
    **/
    findMany<T extends UserNotePermissionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserNotePermissionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserNotePermission.
     * @param {UserNotePermissionCreateArgs} args - Arguments to create a UserNotePermission.
     * @example
     * // Create one UserNotePermission
     * const UserNotePermission = await prisma.userNotePermission.create({
     *   data: {
     *     // ... data to create a UserNotePermission
     *   }
     * })
     * 
    **/
    create<T extends UserNotePermissionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserNotePermissionCreateArgs<ExtArgs>>
    ): Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserNotePermissions.
     *     @param {UserNotePermissionCreateManyArgs} args - Arguments to create many UserNotePermissions.
     *     @example
     *     // Create many UserNotePermissions
     *     const userNotePermission = await prisma.userNotePermission.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserNotePermissionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserNotePermissionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserNotePermission.
     * @param {UserNotePermissionDeleteArgs} args - Arguments to delete one UserNotePermission.
     * @example
     * // Delete one UserNotePermission
     * const UserNotePermission = await prisma.userNotePermission.delete({
     *   where: {
     *     // ... filter to delete one UserNotePermission
     *   }
     * })
     * 
    **/
    delete<T extends UserNotePermissionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserNotePermissionDeleteArgs<ExtArgs>>
    ): Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserNotePermission.
     * @param {UserNotePermissionUpdateArgs} args - Arguments to update one UserNotePermission.
     * @example
     * // Update one UserNotePermission
     * const userNotePermission = await prisma.userNotePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserNotePermissionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserNotePermissionUpdateArgs<ExtArgs>>
    ): Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserNotePermissions.
     * @param {UserNotePermissionDeleteManyArgs} args - Arguments to filter UserNotePermissions to delete.
     * @example
     * // Delete a few UserNotePermissions
     * const { count } = await prisma.userNotePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserNotePermissionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserNotePermissionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotePermissions
     * const userNotePermission = await prisma.userNotePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserNotePermissionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserNotePermissionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserNotePermission.
     * @param {UserNotePermissionUpsertArgs} args - Arguments to update or create a UserNotePermission.
     * @example
     * // Update or create a UserNotePermission
     * const userNotePermission = await prisma.userNotePermission.upsert({
     *   create: {
     *     // ... data to create a UserNotePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotePermission we want to update
     *   }
     * })
    **/
    upsert<T extends UserNotePermissionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserNotePermissionUpsertArgs<ExtArgs>>
    ): Prisma__UserNotePermissionClient<$Types.GetResult<UserNotePermissionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserNotePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotePermissionCountArgs} args - Arguments to filter UserNotePermissions to count.
     * @example
     * // Count the number of UserNotePermissions
     * const count = await prisma.userNotePermission.count({
     *   where: {
     *     // ... the filter for the UserNotePermissions we want to count
     *   }
     * })
    **/
    count<T extends UserNotePermissionCountArgs>(
      args?: Subset<T, UserNotePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotePermissionAggregateArgs>(args: Subset<T, UserNotePermissionAggregateArgs>): Prisma.PrismaPromise<GetUserNotePermissionAggregateType<T>>

    /**
     * Group by UserNotePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNotePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNotePermissionGroupByArgs['orderBy'] }
        : { orderBy?: UserNotePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNotePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNotePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserNotePermissionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    note<T extends NoteArgs<ExtArgs> = {}>(args?: Subset<T, NoteArgs<ExtArgs>>): Prisma__NoteClient<$Types.GetResult<NotePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserNotePermission base type for findUnique actions
   */
  export type UserNotePermissionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserNotePermission to fetch.
     */
    where: UserNotePermissionWhereUniqueInput
  }

  /**
   * UserNotePermission findUnique
   */
  export interface UserNotePermissionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserNotePermissionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserNotePermission findUniqueOrThrow
   */
  export type UserNotePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserNotePermission to fetch.
     */
    where: UserNotePermissionWhereUniqueInput
  }


  /**
   * UserNotePermission base type for findFirst actions
   */
  export type UserNotePermissionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserNotePermission to fetch.
     */
    where?: UserNotePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotePermissions to fetch.
     */
    orderBy?: Enumerable<UserNotePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotePermissions.
     */
    cursor?: UserNotePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotePermissions.
     */
    distinct?: Enumerable<UserNotePermissionScalarFieldEnum>
  }

  /**
   * UserNotePermission findFirst
   */
  export interface UserNotePermissionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserNotePermissionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserNotePermission findFirstOrThrow
   */
  export type UserNotePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserNotePermission to fetch.
     */
    where?: UserNotePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotePermissions to fetch.
     */
    orderBy?: Enumerable<UserNotePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNotePermissions.
     */
    cursor?: UserNotePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNotePermissions.
     */
    distinct?: Enumerable<UserNotePermissionScalarFieldEnum>
  }


  /**
   * UserNotePermission findMany
   */
  export type UserNotePermissionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * Filter, which UserNotePermissions to fetch.
     */
    where?: UserNotePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNotePermissions to fetch.
     */
    orderBy?: Enumerable<UserNotePermissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNotePermissions.
     */
    cursor?: UserNotePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNotePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNotePermissions.
     */
    skip?: number
    distinct?: Enumerable<UserNotePermissionScalarFieldEnum>
  }


  /**
   * UserNotePermission create
   */
  export type UserNotePermissionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNotePermission.
     */
    data: XOR<UserNotePermissionCreateInput, UserNotePermissionUncheckedCreateInput>
  }


  /**
   * UserNotePermission createMany
   */
  export type UserNotePermissionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNotePermissions.
     */
    data: Enumerable<UserNotePermissionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserNotePermission update
   */
  export type UserNotePermissionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNotePermission.
     */
    data: XOR<UserNotePermissionUpdateInput, UserNotePermissionUncheckedUpdateInput>
    /**
     * Choose, which UserNotePermission to update.
     */
    where: UserNotePermissionWhereUniqueInput
  }


  /**
   * UserNotePermission updateMany
   */
  export type UserNotePermissionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNotePermissions.
     */
    data: XOR<UserNotePermissionUpdateManyMutationInput, UserNotePermissionUncheckedUpdateManyInput>
    /**
     * Filter which UserNotePermissions to update
     */
    where?: UserNotePermissionWhereInput
  }


  /**
   * UserNotePermission upsert
   */
  export type UserNotePermissionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNotePermission to update in case it exists.
     */
    where: UserNotePermissionWhereUniqueInput
    /**
     * In case the UserNotePermission found by the `where` argument doesn't exist, create a new UserNotePermission with this data.
     */
    create: XOR<UserNotePermissionCreateInput, UserNotePermissionUncheckedCreateInput>
    /**
     * In case the UserNotePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNotePermissionUpdateInput, UserNotePermissionUncheckedUpdateInput>
  }


  /**
   * UserNotePermission delete
   */
  export type UserNotePermissionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
    /**
     * Filter which UserNotePermission to delete.
     */
    where: UserNotePermissionWhereUniqueInput
  }


  /**
   * UserNotePermission deleteMany
   */
  export type UserNotePermissionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNotePermissions to delete
     */
    where?: UserNotePermissionWhereInput
  }


  /**
   * UserNotePermission without action
   */
  export type UserNotePermissionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNotePermission
     */
    select?: UserNotePermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserNotePermissionInclude<ExtArgs> | null
  }



  /**
   * Model UserDocumentAttributes
   */


  export type AggregateUserDocumentAttributes = {
    _count: UserDocumentAttributesCountAggregateOutputType | null
    _min: UserDocumentAttributesMinAggregateOutputType | null
    _max: UserDocumentAttributesMaxAggregateOutputType | null
  }

  export type UserDocumentAttributesMinAggregateOutputType = {
    documentID: string | null
    userID: string | null
    lastOpenedDocumentVersionID: string | null
  }

  export type UserDocumentAttributesMaxAggregateOutputType = {
    documentID: string | null
    userID: string | null
    lastOpenedDocumentVersionID: string | null
  }

  export type UserDocumentAttributesCountAggregateOutputType = {
    documentID: number
    userID: number
    lastOpenedDocumentVersionID: number
    _all: number
  }


  export type UserDocumentAttributesMinAggregateInputType = {
    documentID?: true
    userID?: true
    lastOpenedDocumentVersionID?: true
  }

  export type UserDocumentAttributesMaxAggregateInputType = {
    documentID?: true
    userID?: true
    lastOpenedDocumentVersionID?: true
  }

  export type UserDocumentAttributesCountAggregateInputType = {
    documentID?: true
    userID?: true
    lastOpenedDocumentVersionID?: true
    _all?: true
  }

  export type UserDocumentAttributesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocumentAttributes to aggregate.
     */
    where?: UserDocumentAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentAttributes to fetch.
     */
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDocumentAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDocumentAttributes
    **/
    _count?: true | UserDocumentAttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDocumentAttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDocumentAttributesMaxAggregateInputType
  }

  export type GetUserDocumentAttributesAggregateType<T extends UserDocumentAttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDocumentAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDocumentAttributes[P]>
      : GetScalarType<T[P], AggregateUserDocumentAttributes[P]>
  }




  export type UserDocumentAttributesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserDocumentAttributesWhereInput
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithAggregationInput>
    by: UserDocumentAttributesScalarFieldEnum[]
    having?: UserDocumentAttributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDocumentAttributesCountAggregateInputType | true
    _min?: UserDocumentAttributesMinAggregateInputType
    _max?: UserDocumentAttributesMaxAggregateInputType
  }


  export type UserDocumentAttributesGroupByOutputType = {
    documentID: string
    userID: string
    lastOpenedDocumentVersionID: string
    _count: UserDocumentAttributesCountAggregateOutputType | null
    _min: UserDocumentAttributesMinAggregateOutputType | null
    _max: UserDocumentAttributesMaxAggregateOutputType | null
  }

  type GetUserDocumentAttributesGroupByPayload<T extends UserDocumentAttributesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserDocumentAttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDocumentAttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDocumentAttributesGroupByOutputType[P]>
            : GetScalarType<T[P], UserDocumentAttributesGroupByOutputType[P]>
        }
      >
    >


  export type UserDocumentAttributesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    documentID?: boolean
    userID?: boolean
    lastOpenedDocumentVersionID?: boolean
    document?: boolean | DocumentArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    lastOpenedDocumentVersion?: boolean | DocumentVersionArgs<ExtArgs>
  }, ExtArgs["result"]["userDocumentAttributes"]>

  export type UserDocumentAttributesSelectScalar = {
    documentID?: boolean
    userID?: boolean
    lastOpenedDocumentVersionID?: boolean
  }

  export type UserDocumentAttributesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentArgs<ExtArgs>
    user?: boolean | UserArgs<ExtArgs>
    lastOpenedDocumentVersion?: boolean | DocumentVersionArgs<ExtArgs>
  }


  type UserDocumentAttributesGetPayload<S extends boolean | null | undefined | UserDocumentAttributesArgs> = $Types.GetResult<UserDocumentAttributesPayload, S>

  type UserDocumentAttributesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserDocumentAttributesFindManyArgs, 'select' | 'include'> & {
      select?: UserDocumentAttributesCountAggregateInputType | true
    }

  export interface UserDocumentAttributesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDocumentAttributes'], meta: { name: 'UserDocumentAttributes' } }
    /**
     * Find zero or one UserDocumentAttributes that matches the filter.
     * @param {UserDocumentAttributesFindUniqueArgs} args - Arguments to find a UserDocumentAttributes
     * @example
     * // Get one UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserDocumentAttributesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserDocumentAttributesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UserDocumentAttributes'> extends True ? Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one UserDocumentAttributes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserDocumentAttributesFindUniqueOrThrowArgs} args - Arguments to find a UserDocumentAttributes
     * @example
     * // Get one UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserDocumentAttributesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentAttributesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first UserDocumentAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAttributesFindFirstArgs} args - Arguments to find a UserDocumentAttributes
     * @example
     * // Get one UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserDocumentAttributesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserDocumentAttributesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UserDocumentAttributes'> extends True ? Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first UserDocumentAttributes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAttributesFindFirstOrThrowArgs} args - Arguments to find a UserDocumentAttributes
     * @example
     * // Get one UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserDocumentAttributesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentAttributesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more UserDocumentAttributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAttributesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.findMany()
     * 
     * // Get first 10 UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.findMany({ take: 10 })
     * 
     * // Only select the `documentID`
     * const userDocumentAttributesWithDocumentIDOnly = await prisma.userDocumentAttributes.findMany({ select: { documentID: true } })
     * 
    **/
    findMany<T extends UserDocumentAttributesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentAttributesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a UserDocumentAttributes.
     * @param {UserDocumentAttributesCreateArgs} args - Arguments to create a UserDocumentAttributes.
     * @example
     * // Create one UserDocumentAttributes
     * const UserDocumentAttributes = await prisma.userDocumentAttributes.create({
     *   data: {
     *     // ... data to create a UserDocumentAttributes
     *   }
     * })
     * 
    **/
    create<T extends UserDocumentAttributesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentAttributesCreateArgs<ExtArgs>>
    ): Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many UserDocumentAttributes.
     *     @param {UserDocumentAttributesCreateManyArgs} args - Arguments to create many UserDocumentAttributes.
     *     @example
     *     // Create many UserDocumentAttributes
     *     const userDocumentAttributes = await prisma.userDocumentAttributes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserDocumentAttributesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentAttributesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserDocumentAttributes.
     * @param {UserDocumentAttributesDeleteArgs} args - Arguments to delete one UserDocumentAttributes.
     * @example
     * // Delete one UserDocumentAttributes
     * const UserDocumentAttributes = await prisma.userDocumentAttributes.delete({
     *   where: {
     *     // ... filter to delete one UserDocumentAttributes
     *   }
     * })
     * 
    **/
    delete<T extends UserDocumentAttributesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentAttributesDeleteArgs<ExtArgs>>
    ): Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one UserDocumentAttributes.
     * @param {UserDocumentAttributesUpdateArgs} args - Arguments to update one UserDocumentAttributes.
     * @example
     * // Update one UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserDocumentAttributesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentAttributesUpdateArgs<ExtArgs>>
    ): Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more UserDocumentAttributes.
     * @param {UserDocumentAttributesDeleteManyArgs} args - Arguments to filter UserDocumentAttributes to delete.
     * @example
     * // Delete a few UserDocumentAttributes
     * const { count } = await prisma.userDocumentAttributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDocumentAttributesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDocumentAttributesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDocumentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAttributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserDocumentAttributesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentAttributesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserDocumentAttributes.
     * @param {UserDocumentAttributesUpsertArgs} args - Arguments to update or create a UserDocumentAttributes.
     * @example
     * // Update or create a UserDocumentAttributes
     * const userDocumentAttributes = await prisma.userDocumentAttributes.upsert({
     *   create: {
     *     // ... data to create a UserDocumentAttributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDocumentAttributes we want to update
     *   }
     * })
    **/
    upsert<T extends UserDocumentAttributesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserDocumentAttributesUpsertArgs<ExtArgs>>
    ): Prisma__UserDocumentAttributesClient<$Types.GetResult<UserDocumentAttributesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of UserDocumentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAttributesCountArgs} args - Arguments to filter UserDocumentAttributes to count.
     * @example
     * // Count the number of UserDocumentAttributes
     * const count = await prisma.userDocumentAttributes.count({
     *   where: {
     *     // ... the filter for the UserDocumentAttributes we want to count
     *   }
     * })
    **/
    count<T extends UserDocumentAttributesCountArgs>(
      args?: Subset<T, UserDocumentAttributesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDocumentAttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDocumentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDocumentAttributesAggregateArgs>(args: Subset<T, UserDocumentAttributesAggregateArgs>): Prisma.PrismaPromise<GetUserDocumentAttributesAggregateType<T>>

    /**
     * Group by UserDocumentAttributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentAttributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDocumentAttributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDocumentAttributesGroupByArgs['orderBy'] }
        : { orderBy?: UserDocumentAttributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDocumentAttributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDocumentAttributesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDocumentAttributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserDocumentAttributesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    lastOpenedDocumentVersion<T extends DocumentVersionArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersionArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * UserDocumentAttributes base type for findUnique actions
   */
  export type UserDocumentAttributesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentAttributes to fetch.
     */
    where: UserDocumentAttributesWhereUniqueInput
  }

  /**
   * UserDocumentAttributes findUnique
   */
  export interface UserDocumentAttributesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentAttributesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocumentAttributes findUniqueOrThrow
   */
  export type UserDocumentAttributesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentAttributes to fetch.
     */
    where: UserDocumentAttributesWhereUniqueInput
  }


  /**
   * UserDocumentAttributes base type for findFirst actions
   */
  export type UserDocumentAttributesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentAttributes to fetch.
     */
    where?: UserDocumentAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentAttributes to fetch.
     */
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocumentAttributes.
     */
    cursor?: UserDocumentAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocumentAttributes.
     */
    distinct?: Enumerable<UserDocumentAttributesScalarFieldEnum>
  }

  /**
   * UserDocumentAttributes findFirst
   */
  export interface UserDocumentAttributesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends UserDocumentAttributesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * UserDocumentAttributes findFirstOrThrow
   */
  export type UserDocumentAttributesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentAttributes to fetch.
     */
    where?: UserDocumentAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentAttributes to fetch.
     */
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocumentAttributes.
     */
    cursor?: UserDocumentAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentAttributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocumentAttributes.
     */
    distinct?: Enumerable<UserDocumentAttributesScalarFieldEnum>
  }


  /**
   * UserDocumentAttributes findMany
   */
  export type UserDocumentAttributesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * Filter, which UserDocumentAttributes to fetch.
     */
    where?: UserDocumentAttributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocumentAttributes to fetch.
     */
    orderBy?: Enumerable<UserDocumentAttributesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDocumentAttributes.
     */
    cursor?: UserDocumentAttributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocumentAttributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocumentAttributes.
     */
    skip?: number
    distinct?: Enumerable<UserDocumentAttributesScalarFieldEnum>
  }


  /**
   * UserDocumentAttributes create
   */
  export type UserDocumentAttributesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDocumentAttributes.
     */
    data: XOR<UserDocumentAttributesCreateInput, UserDocumentAttributesUncheckedCreateInput>
  }


  /**
   * UserDocumentAttributes createMany
   */
  export type UserDocumentAttributesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDocumentAttributes.
     */
    data: Enumerable<UserDocumentAttributesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * UserDocumentAttributes update
   */
  export type UserDocumentAttributesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDocumentAttributes.
     */
    data: XOR<UserDocumentAttributesUpdateInput, UserDocumentAttributesUncheckedUpdateInput>
    /**
     * Choose, which UserDocumentAttributes to update.
     */
    where: UserDocumentAttributesWhereUniqueInput
  }


  /**
   * UserDocumentAttributes updateMany
   */
  export type UserDocumentAttributesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDocumentAttributes.
     */
    data: XOR<UserDocumentAttributesUpdateManyMutationInput, UserDocumentAttributesUncheckedUpdateManyInput>
    /**
     * Filter which UserDocumentAttributes to update
     */
    where?: UserDocumentAttributesWhereInput
  }


  /**
   * UserDocumentAttributes upsert
   */
  export type UserDocumentAttributesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDocumentAttributes to update in case it exists.
     */
    where: UserDocumentAttributesWhereUniqueInput
    /**
     * In case the UserDocumentAttributes found by the `where` argument doesn't exist, create a new UserDocumentAttributes with this data.
     */
    create: XOR<UserDocumentAttributesCreateInput, UserDocumentAttributesUncheckedCreateInput>
    /**
     * In case the UserDocumentAttributes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDocumentAttributesUpdateInput, UserDocumentAttributesUncheckedUpdateInput>
  }


  /**
   * UserDocumentAttributes delete
   */
  export type UserDocumentAttributesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
    /**
     * Filter which UserDocumentAttributes to delete.
     */
    where: UserDocumentAttributesWhereUniqueInput
  }


  /**
   * UserDocumentAttributes deleteMany
   */
  export type UserDocumentAttributesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocumentAttributes to delete
     */
    where?: UserDocumentAttributesWhereInput
  }


  /**
   * UserDocumentAttributes without action
   */
  export type UserDocumentAttributesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocumentAttributes
     */
    select?: UserDocumentAttributesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserDocumentAttributesInclude<ExtArgs> | null
  }



  /**
   * Model DailyStatUnit
   */


  export type AggregateDailyStatUnit = {
    _count: DailyStatUnitCountAggregateOutputType | null
    _avg: DailyStatUnitAvgAggregateOutputType | null
    _sum: DailyStatUnitSumAggregateOutputType | null
    _min: DailyStatUnitMinAggregateOutputType | null
    _max: DailyStatUnitMaxAggregateOutputType | null
  }

  export type DailyStatUnitAvgAggregateOutputType = {
    timeSpentSeconds: number | null
    wordsAdded: number | null
    wordsRemoved: number | null
  }

  export type DailyStatUnitSumAggregateOutputType = {
    timeSpentSeconds: number | null
    wordsAdded: number | null
    wordsRemoved: number | null
  }

  export type DailyStatUnitMinAggregateOutputType = {
    dailyStatUnitID: string | null
    userID: string | null
    documentVersionID: string | null
    documentID: string | null
    dailyChallengeResponseID: string | null
    date: Date | null
    timeSpentSeconds: number | null
    wordsAdded: number | null
    wordsRemoved: number | null
  }

  export type DailyStatUnitMaxAggregateOutputType = {
    dailyStatUnitID: string | null
    userID: string | null
    documentVersionID: string | null
    documentID: string | null
    dailyChallengeResponseID: string | null
    date: Date | null
    timeSpentSeconds: number | null
    wordsAdded: number | null
    wordsRemoved: number | null
  }

  export type DailyStatUnitCountAggregateOutputType = {
    dailyStatUnitID: number
    userID: number
    documentVersionID: number
    documentID: number
    dailyChallengeResponseID: number
    date: number
    timeSpentSeconds: number
    wordsAdded: number
    wordsRemoved: number
    _all: number
  }


  export type DailyStatUnitAvgAggregateInputType = {
    timeSpentSeconds?: true
    wordsAdded?: true
    wordsRemoved?: true
  }

  export type DailyStatUnitSumAggregateInputType = {
    timeSpentSeconds?: true
    wordsAdded?: true
    wordsRemoved?: true
  }

  export type DailyStatUnitMinAggregateInputType = {
    dailyStatUnitID?: true
    userID?: true
    documentVersionID?: true
    documentID?: true
    dailyChallengeResponseID?: true
    date?: true
    timeSpentSeconds?: true
    wordsAdded?: true
    wordsRemoved?: true
  }

  export type DailyStatUnitMaxAggregateInputType = {
    dailyStatUnitID?: true
    userID?: true
    documentVersionID?: true
    documentID?: true
    dailyChallengeResponseID?: true
    date?: true
    timeSpentSeconds?: true
    wordsAdded?: true
    wordsRemoved?: true
  }

  export type DailyStatUnitCountAggregateInputType = {
    dailyStatUnitID?: true
    userID?: true
    documentVersionID?: true
    documentID?: true
    dailyChallengeResponseID?: true
    date?: true
    timeSpentSeconds?: true
    wordsAdded?: true
    wordsRemoved?: true
    _all?: true
  }

  export type DailyStatUnitAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStatUnit to aggregate.
     */
    where?: DailyStatUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStatUnits to fetch.
     */
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyStatUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStatUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStatUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyStatUnits
    **/
    _count?: true | DailyStatUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyStatUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyStatUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyStatUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyStatUnitMaxAggregateInputType
  }

  export type GetDailyStatUnitAggregateType<T extends DailyStatUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyStatUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyStatUnit[P]>
      : GetScalarType<T[P], AggregateDailyStatUnit[P]>
  }




  export type DailyStatUnitGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyStatUnitWhereInput
    orderBy?: Enumerable<DailyStatUnitOrderByWithAggregationInput>
    by: DailyStatUnitScalarFieldEnum[]
    having?: DailyStatUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyStatUnitCountAggregateInputType | true
    _avg?: DailyStatUnitAvgAggregateInputType
    _sum?: DailyStatUnitSumAggregateInputType
    _min?: DailyStatUnitMinAggregateInputType
    _max?: DailyStatUnitMaxAggregateInputType
  }


  export type DailyStatUnitGroupByOutputType = {
    dailyStatUnitID: string
    userID: string
    documentVersionID: string | null
    documentID: string | null
    dailyChallengeResponseID: string | null
    date: Date
    timeSpentSeconds: number
    wordsAdded: number
    wordsRemoved: number
    _count: DailyStatUnitCountAggregateOutputType | null
    _avg: DailyStatUnitAvgAggregateOutputType | null
    _sum: DailyStatUnitSumAggregateOutputType | null
    _min: DailyStatUnitMinAggregateOutputType | null
    _max: DailyStatUnitMaxAggregateOutputType | null
  }

  type GetDailyStatUnitGroupByPayload<T extends DailyStatUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DailyStatUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyStatUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyStatUnitGroupByOutputType[P]>
            : GetScalarType<T[P], DailyStatUnitGroupByOutputType[P]>
        }
      >
    >


  export type DailyStatUnitSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    dailyStatUnitID?: boolean
    userID?: boolean
    documentVersionID?: boolean
    documentID?: boolean
    dailyChallengeResponseID?: boolean
    date?: boolean
    timeSpentSeconds?: boolean
    wordsAdded?: boolean
    wordsRemoved?: boolean
    user?: boolean | UserArgs<ExtArgs>
    documentVersion?: boolean | DocumentVersionArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    dailyChallengeResponse?: boolean | DailyChallengeResponseArgs<ExtArgs>
  }, ExtArgs["result"]["dailyStatUnit"]>

  export type DailyStatUnitSelectScalar = {
    dailyStatUnitID?: boolean
    userID?: boolean
    documentVersionID?: boolean
    documentID?: boolean
    dailyChallengeResponseID?: boolean
    date?: boolean
    timeSpentSeconds?: boolean
    wordsAdded?: boolean
    wordsRemoved?: boolean
  }

  export type DailyStatUnitInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    documentVersion?: boolean | DocumentVersionArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    dailyChallengeResponse?: boolean | DailyChallengeResponseArgs<ExtArgs>
  }


  type DailyStatUnitGetPayload<S extends boolean | null | undefined | DailyStatUnitArgs> = $Types.GetResult<DailyStatUnitPayload, S>

  type DailyStatUnitCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DailyStatUnitFindManyArgs, 'select' | 'include'> & {
      select?: DailyStatUnitCountAggregateInputType | true
    }

  export interface DailyStatUnitDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyStatUnit'], meta: { name: 'DailyStatUnit' } }
    /**
     * Find zero or one DailyStatUnit that matches the filter.
     * @param {DailyStatUnitFindUniqueArgs} args - Arguments to find a DailyStatUnit
     * @example
     * // Get one DailyStatUnit
     * const dailyStatUnit = await prisma.dailyStatUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyStatUnitFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyStatUnitFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyStatUnit'> extends True ? Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DailyStatUnit that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DailyStatUnitFindUniqueOrThrowArgs} args - Arguments to find a DailyStatUnit
     * @example
     * // Get one DailyStatUnit
     * const dailyStatUnit = await prisma.dailyStatUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DailyStatUnitFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyStatUnitFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DailyStatUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUnitFindFirstArgs} args - Arguments to find a DailyStatUnit
     * @example
     * // Get one DailyStatUnit
     * const dailyStatUnit = await prisma.dailyStatUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyStatUnitFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyStatUnitFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyStatUnit'> extends True ? Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DailyStatUnit that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUnitFindFirstOrThrowArgs} args - Arguments to find a DailyStatUnit
     * @example
     * // Get one DailyStatUnit
     * const dailyStatUnit = await prisma.dailyStatUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DailyStatUnitFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyStatUnitFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DailyStatUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyStatUnits
     * const dailyStatUnits = await prisma.dailyStatUnit.findMany()
     * 
     * // Get first 10 DailyStatUnits
     * const dailyStatUnits = await prisma.dailyStatUnit.findMany({ take: 10 })
     * 
     * // Only select the `dailyStatUnitID`
     * const dailyStatUnitWithDailyStatUnitIDOnly = await prisma.dailyStatUnit.findMany({ select: { dailyStatUnitID: true } })
     * 
    **/
    findMany<T extends DailyStatUnitFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyStatUnitFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DailyStatUnit.
     * @param {DailyStatUnitCreateArgs} args - Arguments to create a DailyStatUnit.
     * @example
     * // Create one DailyStatUnit
     * const DailyStatUnit = await prisma.dailyStatUnit.create({
     *   data: {
     *     // ... data to create a DailyStatUnit
     *   }
     * })
     * 
    **/
    create<T extends DailyStatUnitCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyStatUnitCreateArgs<ExtArgs>>
    ): Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DailyStatUnits.
     *     @param {DailyStatUnitCreateManyArgs} args - Arguments to create many DailyStatUnits.
     *     @example
     *     // Create many DailyStatUnits
     *     const dailyStatUnit = await prisma.dailyStatUnit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyStatUnitCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyStatUnitCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyStatUnit.
     * @param {DailyStatUnitDeleteArgs} args - Arguments to delete one DailyStatUnit.
     * @example
     * // Delete one DailyStatUnit
     * const DailyStatUnit = await prisma.dailyStatUnit.delete({
     *   where: {
     *     // ... filter to delete one DailyStatUnit
     *   }
     * })
     * 
    **/
    delete<T extends DailyStatUnitDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DailyStatUnitDeleteArgs<ExtArgs>>
    ): Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DailyStatUnit.
     * @param {DailyStatUnitUpdateArgs} args - Arguments to update one DailyStatUnit.
     * @example
     * // Update one DailyStatUnit
     * const dailyStatUnit = await prisma.dailyStatUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyStatUnitUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyStatUnitUpdateArgs<ExtArgs>>
    ): Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DailyStatUnits.
     * @param {DailyStatUnitDeleteManyArgs} args - Arguments to filter DailyStatUnits to delete.
     * @example
     * // Delete a few DailyStatUnits
     * const { count } = await prisma.dailyStatUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyStatUnitDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyStatUnitDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyStatUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyStatUnits
     * const dailyStatUnit = await prisma.dailyStatUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyStatUnitUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DailyStatUnitUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyStatUnit.
     * @param {DailyStatUnitUpsertArgs} args - Arguments to update or create a DailyStatUnit.
     * @example
     * // Update or create a DailyStatUnit
     * const dailyStatUnit = await prisma.dailyStatUnit.upsert({
     *   create: {
     *     // ... data to create a DailyStatUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyStatUnit we want to update
     *   }
     * })
    **/
    upsert<T extends DailyStatUnitUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DailyStatUnitUpsertArgs<ExtArgs>>
    ): Prisma__DailyStatUnitClient<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DailyStatUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUnitCountArgs} args - Arguments to filter DailyStatUnits to count.
     * @example
     * // Count the number of DailyStatUnits
     * const count = await prisma.dailyStatUnit.count({
     *   where: {
     *     // ... the filter for the DailyStatUnits we want to count
     *   }
     * })
    **/
    count<T extends DailyStatUnitCountArgs>(
      args?: Subset<T, DailyStatUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyStatUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyStatUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyStatUnitAggregateArgs>(args: Subset<T, DailyStatUnitAggregateArgs>): Prisma.PrismaPromise<GetDailyStatUnitAggregateType<T>>

    /**
     * Group by DailyStatUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyStatUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyStatUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyStatUnitGroupByArgs['orderBy'] }
        : { orderBy?: DailyStatUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyStatUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyStatUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyStatUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyStatUnitClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    documentVersion<T extends DocumentVersionArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersionArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Types.GetResult<DocumentVersionPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    dailyChallengeResponse<T extends DailyChallengeResponseArgs<ExtArgs> = {}>(args?: Subset<T, DailyChallengeResponseArgs<ExtArgs>>): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DailyStatUnit base type for findUnique actions
   */
  export type DailyStatUnitFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * Filter, which DailyStatUnit to fetch.
     */
    where: DailyStatUnitWhereUniqueInput
  }

  /**
   * DailyStatUnit findUnique
   */
  export interface DailyStatUnitFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyStatUnitFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyStatUnit findUniqueOrThrow
   */
  export type DailyStatUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * Filter, which DailyStatUnit to fetch.
     */
    where: DailyStatUnitWhereUniqueInput
  }


  /**
   * DailyStatUnit base type for findFirst actions
   */
  export type DailyStatUnitFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * Filter, which DailyStatUnit to fetch.
     */
    where?: DailyStatUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStatUnits to fetch.
     */
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStatUnits.
     */
    cursor?: DailyStatUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStatUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStatUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStatUnits.
     */
    distinct?: Enumerable<DailyStatUnitScalarFieldEnum>
  }

  /**
   * DailyStatUnit findFirst
   */
  export interface DailyStatUnitFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyStatUnitFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyStatUnit findFirstOrThrow
   */
  export type DailyStatUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * Filter, which DailyStatUnit to fetch.
     */
    where?: DailyStatUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStatUnits to fetch.
     */
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyStatUnits.
     */
    cursor?: DailyStatUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStatUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStatUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyStatUnits.
     */
    distinct?: Enumerable<DailyStatUnitScalarFieldEnum>
  }


  /**
   * DailyStatUnit findMany
   */
  export type DailyStatUnitFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * Filter, which DailyStatUnits to fetch.
     */
    where?: DailyStatUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyStatUnits to fetch.
     */
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyStatUnits.
     */
    cursor?: DailyStatUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyStatUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyStatUnits.
     */
    skip?: number
    distinct?: Enumerable<DailyStatUnitScalarFieldEnum>
  }


  /**
   * DailyStatUnit create
   */
  export type DailyStatUnitCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyStatUnit.
     */
    data: XOR<DailyStatUnitCreateInput, DailyStatUnitUncheckedCreateInput>
  }


  /**
   * DailyStatUnit createMany
   */
  export type DailyStatUnitCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyStatUnits.
     */
    data: Enumerable<DailyStatUnitCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DailyStatUnit update
   */
  export type DailyStatUnitUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyStatUnit.
     */
    data: XOR<DailyStatUnitUpdateInput, DailyStatUnitUncheckedUpdateInput>
    /**
     * Choose, which DailyStatUnit to update.
     */
    where: DailyStatUnitWhereUniqueInput
  }


  /**
   * DailyStatUnit updateMany
   */
  export type DailyStatUnitUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyStatUnits.
     */
    data: XOR<DailyStatUnitUpdateManyMutationInput, DailyStatUnitUncheckedUpdateManyInput>
    /**
     * Filter which DailyStatUnits to update
     */
    where?: DailyStatUnitWhereInput
  }


  /**
   * DailyStatUnit upsert
   */
  export type DailyStatUnitUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyStatUnit to update in case it exists.
     */
    where: DailyStatUnitWhereUniqueInput
    /**
     * In case the DailyStatUnit found by the `where` argument doesn't exist, create a new DailyStatUnit with this data.
     */
    create: XOR<DailyStatUnitCreateInput, DailyStatUnitUncheckedCreateInput>
    /**
     * In case the DailyStatUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyStatUnitUpdateInput, DailyStatUnitUncheckedUpdateInput>
  }


  /**
   * DailyStatUnit delete
   */
  export type DailyStatUnitDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    /**
     * Filter which DailyStatUnit to delete.
     */
    where: DailyStatUnitWhereUniqueInput
  }


  /**
   * DailyStatUnit deleteMany
   */
  export type DailyStatUnitDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyStatUnits to delete
     */
    where?: DailyStatUnitWhereInput
  }


  /**
   * DailyStatUnit without action
   */
  export type DailyStatUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
  }



  /**
   * Model WritingSession
   */


  export type AggregateWritingSession = {
    _count: WritingSessionCountAggregateOutputType | null
    _avg: WritingSessionAvgAggregateOutputType | null
    _sum: WritingSessionSumAggregateOutputType | null
    _min: WritingSessionMinAggregateOutputType | null
    _max: WritingSessionMaxAggregateOutputType | null
  }

  export type WritingSessionAvgAggregateOutputType = {
    segmentTime: number | null
    wordsAdded: number | null
    wordsRemoved: number | null
    timeSpentSeconds: number | null
  }

  export type WritingSessionSumAggregateOutputType = {
    segmentTime: number[] | null
    wordsAdded: number | null
    wordsRemoved: number | null
    timeSpentSeconds: number | null
  }

  export type WritingSessionMinAggregateOutputType = {
    writingSessionID: string | null
    userID: string | null
    wordsAdded: number | null
    wordsRemoved: number | null
    timeSpentSeconds: number | null
    startDateTime: Date | null
    title: string | null
    documentID: string | null
    inProgress: boolean | null
    updatedAt: Date | null
  }

  export type WritingSessionMaxAggregateOutputType = {
    writingSessionID: string | null
    userID: string | null
    wordsAdded: number | null
    wordsRemoved: number | null
    timeSpentSeconds: number | null
    startDateTime: Date | null
    title: string | null
    documentID: string | null
    inProgress: boolean | null
    updatedAt: Date | null
  }

  export type WritingSessionCountAggregateOutputType = {
    writingSessionID: number
    userID: number
    segmentTime: number
    wordsAdded: number
    wordsRemoved: number
    timeSpentSeconds: number
    startDateTime: number
    title: number
    documentID: number
    inProgress: number
    updatedAt: number
    _all: number
  }


  export type WritingSessionAvgAggregateInputType = {
    segmentTime?: true
    wordsAdded?: true
    wordsRemoved?: true
    timeSpentSeconds?: true
  }

  export type WritingSessionSumAggregateInputType = {
    segmentTime?: true
    wordsAdded?: true
    wordsRemoved?: true
    timeSpentSeconds?: true
  }

  export type WritingSessionMinAggregateInputType = {
    writingSessionID?: true
    userID?: true
    wordsAdded?: true
    wordsRemoved?: true
    timeSpentSeconds?: true
    startDateTime?: true
    title?: true
    documentID?: true
    inProgress?: true
    updatedAt?: true
  }

  export type WritingSessionMaxAggregateInputType = {
    writingSessionID?: true
    userID?: true
    wordsAdded?: true
    wordsRemoved?: true
    timeSpentSeconds?: true
    startDateTime?: true
    title?: true
    documentID?: true
    inProgress?: true
    updatedAt?: true
  }

  export type WritingSessionCountAggregateInputType = {
    writingSessionID?: true
    userID?: true
    segmentTime?: true
    wordsAdded?: true
    wordsRemoved?: true
    timeSpentSeconds?: true
    startDateTime?: true
    title?: true
    documentID?: true
    inProgress?: true
    updatedAt?: true
    _all?: true
  }

  export type WritingSessionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WritingSession to aggregate.
     */
    where?: WritingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingSessions to fetch.
     */
    orderBy?: Enumerable<WritingSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WritingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WritingSessions
    **/
    _count?: true | WritingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WritingSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WritingSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WritingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WritingSessionMaxAggregateInputType
  }

  export type GetWritingSessionAggregateType<T extends WritingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWritingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWritingSession[P]>
      : GetScalarType<T[P], AggregateWritingSession[P]>
  }




  export type WritingSessionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: WritingSessionWhereInput
    orderBy?: Enumerable<WritingSessionOrderByWithAggregationInput>
    by: WritingSessionScalarFieldEnum[]
    having?: WritingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WritingSessionCountAggregateInputType | true
    _avg?: WritingSessionAvgAggregateInputType
    _sum?: WritingSessionSumAggregateInputType
    _min?: WritingSessionMinAggregateInputType
    _max?: WritingSessionMaxAggregateInputType
  }


  export type WritingSessionGroupByOutputType = {
    writingSessionID: string
    userID: string
    segmentTime: number[]
    wordsAdded: number
    wordsRemoved: number
    timeSpentSeconds: number
    startDateTime: Date
    title: string
    documentID: string | null
    inProgress: boolean
    updatedAt: Date
    _count: WritingSessionCountAggregateOutputType | null
    _avg: WritingSessionAvgAggregateOutputType | null
    _sum: WritingSessionSumAggregateOutputType | null
    _min: WritingSessionMinAggregateOutputType | null
    _max: WritingSessionMaxAggregateOutputType | null
  }

  type GetWritingSessionGroupByPayload<T extends WritingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WritingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WritingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WritingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WritingSessionGroupByOutputType[P]>
        }
      >
    >


  export type WritingSessionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    writingSessionID?: boolean
    userID?: boolean
    segmentTime?: boolean
    wordsAdded?: boolean
    wordsRemoved?: boolean
    timeSpentSeconds?: boolean
    startDateTime?: boolean
    title?: boolean
    documentID?: boolean
    inProgress?: boolean
    updatedAt?: boolean
    user?: boolean | UserArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    likes?: boolean | WritingSession$likesArgs<ExtArgs>
    _count?: boolean | WritingSessionCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["writingSession"]>

  export type WritingSessionSelectScalar = {
    writingSessionID?: boolean
    userID?: boolean
    segmentTime?: boolean
    wordsAdded?: boolean
    wordsRemoved?: boolean
    timeSpentSeconds?: boolean
    startDateTime?: boolean
    title?: boolean
    documentID?: boolean
    inProgress?: boolean
    updatedAt?: boolean
  }

  export type WritingSessionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    document?: boolean | DocumentArgs<ExtArgs>
    likes?: boolean | WritingSession$likesArgs<ExtArgs>
    _count?: boolean | WritingSessionCountOutputTypeArgs<ExtArgs>
  }


  type WritingSessionGetPayload<S extends boolean | null | undefined | WritingSessionArgs> = $Types.GetResult<WritingSessionPayload, S>

  type WritingSessionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<WritingSessionFindManyArgs, 'select' | 'include'> & {
      select?: WritingSessionCountAggregateInputType | true
    }

  export interface WritingSessionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WritingSession'], meta: { name: 'WritingSession' } }
    /**
     * Find zero or one WritingSession that matches the filter.
     * @param {WritingSessionFindUniqueArgs} args - Arguments to find a WritingSession
     * @example
     * // Get one WritingSession
     * const writingSession = await prisma.writingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WritingSessionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WritingSessionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WritingSession'> extends True ? Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one WritingSession that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WritingSessionFindUniqueOrThrowArgs} args - Arguments to find a WritingSession
     * @example
     * // Get one WritingSession
     * const writingSession = await prisma.writingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WritingSessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WritingSessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first WritingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingSessionFindFirstArgs} args - Arguments to find a WritingSession
     * @example
     * // Get one WritingSession
     * const writingSession = await prisma.writingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WritingSessionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WritingSessionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WritingSession'> extends True ? Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first WritingSession that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingSessionFindFirstOrThrowArgs} args - Arguments to find a WritingSession
     * @example
     * // Get one WritingSession
     * const writingSession = await prisma.writingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WritingSessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, WritingSessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more WritingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingSessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WritingSessions
     * const writingSessions = await prisma.writingSession.findMany()
     * 
     * // Get first 10 WritingSessions
     * const writingSessions = await prisma.writingSession.findMany({ take: 10 })
     * 
     * // Only select the `writingSessionID`
     * const writingSessionWithWritingSessionIDOnly = await prisma.writingSession.findMany({ select: { writingSessionID: true } })
     * 
    **/
    findMany<T extends WritingSessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WritingSessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a WritingSession.
     * @param {WritingSessionCreateArgs} args - Arguments to create a WritingSession.
     * @example
     * // Create one WritingSession
     * const WritingSession = await prisma.writingSession.create({
     *   data: {
     *     // ... data to create a WritingSession
     *   }
     * })
     * 
    **/
    create<T extends WritingSessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, WritingSessionCreateArgs<ExtArgs>>
    ): Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many WritingSessions.
     *     @param {WritingSessionCreateManyArgs} args - Arguments to create many WritingSessions.
     *     @example
     *     // Create many WritingSessions
     *     const writingSession = await prisma.writingSession.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WritingSessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WritingSessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WritingSession.
     * @param {WritingSessionDeleteArgs} args - Arguments to delete one WritingSession.
     * @example
     * // Delete one WritingSession
     * const WritingSession = await prisma.writingSession.delete({
     *   where: {
     *     // ... filter to delete one WritingSession
     *   }
     * })
     * 
    **/
    delete<T extends WritingSessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, WritingSessionDeleteArgs<ExtArgs>>
    ): Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one WritingSession.
     * @param {WritingSessionUpdateArgs} args - Arguments to update one WritingSession.
     * @example
     * // Update one WritingSession
     * const writingSession = await prisma.writingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WritingSessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, WritingSessionUpdateArgs<ExtArgs>>
    ): Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more WritingSessions.
     * @param {WritingSessionDeleteManyArgs} args - Arguments to filter WritingSessions to delete.
     * @example
     * // Delete a few WritingSessions
     * const { count } = await prisma.writingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WritingSessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, WritingSessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WritingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WritingSessions
     * const writingSession = await prisma.writingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WritingSessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, WritingSessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WritingSession.
     * @param {WritingSessionUpsertArgs} args - Arguments to update or create a WritingSession.
     * @example
     * // Update or create a WritingSession
     * const writingSession = await prisma.writingSession.upsert({
     *   create: {
     *     // ... data to create a WritingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WritingSession we want to update
     *   }
     * })
    **/
    upsert<T extends WritingSessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, WritingSessionUpsertArgs<ExtArgs>>
    ): Prisma__WritingSessionClient<$Types.GetResult<WritingSessionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of WritingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingSessionCountArgs} args - Arguments to filter WritingSessions to count.
     * @example
     * // Count the number of WritingSessions
     * const count = await prisma.writingSession.count({
     *   where: {
     *     // ... the filter for the WritingSessions we want to count
     *   }
     * })
    **/
    count<T extends WritingSessionCountArgs>(
      args?: Subset<T, WritingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WritingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WritingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WritingSessionAggregateArgs>(args: Subset<T, WritingSessionAggregateArgs>): Prisma.PrismaPromise<GetWritingSessionAggregateType<T>>

    /**
     * Group by WritingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WritingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WritingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WritingSessionGroupByArgs['orderBy'] }
        : { orderBy?: WritingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WritingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWritingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WritingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WritingSessionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    document<T extends DocumentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentArgs<ExtArgs>>): Prisma__DocumentClient<$Types.GetResult<DocumentPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    likes<T extends WritingSession$likesArgs<ExtArgs> = {}>(args?: Subset<T, WritingSession$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<UserPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WritingSession base type for findUnique actions
   */
  export type WritingSessionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * Filter, which WritingSession to fetch.
     */
    where: WritingSessionWhereUniqueInput
  }

  /**
   * WritingSession findUnique
   */
  export interface WritingSessionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WritingSessionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WritingSession findUniqueOrThrow
   */
  export type WritingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * Filter, which WritingSession to fetch.
     */
    where: WritingSessionWhereUniqueInput
  }


  /**
   * WritingSession base type for findFirst actions
   */
  export type WritingSessionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * Filter, which WritingSession to fetch.
     */
    where?: WritingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingSessions to fetch.
     */
    orderBy?: Enumerable<WritingSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WritingSessions.
     */
    cursor?: WritingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WritingSessions.
     */
    distinct?: Enumerable<WritingSessionScalarFieldEnum>
  }

  /**
   * WritingSession findFirst
   */
  export interface WritingSessionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends WritingSessionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WritingSession findFirstOrThrow
   */
  export type WritingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * Filter, which WritingSession to fetch.
     */
    where?: WritingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingSessions to fetch.
     */
    orderBy?: Enumerable<WritingSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WritingSessions.
     */
    cursor?: WritingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WritingSessions.
     */
    distinct?: Enumerable<WritingSessionScalarFieldEnum>
  }


  /**
   * WritingSession findMany
   */
  export type WritingSessionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * Filter, which WritingSessions to fetch.
     */
    where?: WritingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WritingSessions to fetch.
     */
    orderBy?: Enumerable<WritingSessionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WritingSessions.
     */
    cursor?: WritingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WritingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WritingSessions.
     */
    skip?: number
    distinct?: Enumerable<WritingSessionScalarFieldEnum>
  }


  /**
   * WritingSession create
   */
  export type WritingSessionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WritingSession.
     */
    data: XOR<WritingSessionCreateInput, WritingSessionUncheckedCreateInput>
  }


  /**
   * WritingSession createMany
   */
  export type WritingSessionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WritingSessions.
     */
    data: Enumerable<WritingSessionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WritingSession update
   */
  export type WritingSessionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WritingSession.
     */
    data: XOR<WritingSessionUpdateInput, WritingSessionUncheckedUpdateInput>
    /**
     * Choose, which WritingSession to update.
     */
    where: WritingSessionWhereUniqueInput
  }


  /**
   * WritingSession updateMany
   */
  export type WritingSessionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WritingSessions.
     */
    data: XOR<WritingSessionUpdateManyMutationInput, WritingSessionUncheckedUpdateManyInput>
    /**
     * Filter which WritingSessions to update
     */
    where?: WritingSessionWhereInput
  }


  /**
   * WritingSession upsert
   */
  export type WritingSessionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WritingSession to update in case it exists.
     */
    where: WritingSessionWhereUniqueInput
    /**
     * In case the WritingSession found by the `where` argument doesn't exist, create a new WritingSession with this data.
     */
    create: XOR<WritingSessionCreateInput, WritingSessionUncheckedCreateInput>
    /**
     * In case the WritingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WritingSessionUpdateInput, WritingSessionUncheckedUpdateInput>
  }


  /**
   * WritingSession delete
   */
  export type WritingSessionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
    /**
     * Filter which WritingSession to delete.
     */
    where: WritingSessionWhereUniqueInput
  }


  /**
   * WritingSession deleteMany
   */
  export type WritingSessionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which WritingSessions to delete
     */
    where?: WritingSessionWhereInput
  }


  /**
   * WritingSession.likes
   */
  export type WritingSession$likesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * WritingSession without action
   */
  export type WritingSessionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WritingSession
     */
    select?: WritingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WritingSessionInclude<ExtArgs> | null
  }



  /**
   * Model DailyChallenge
   */


  export type AggregateDailyChallenge = {
    _count: DailyChallengeCountAggregateOutputType | null
    _avg: DailyChallengeAvgAggregateOutputType | null
    _sum: DailyChallengeSumAggregateOutputType | null
    _min: DailyChallengeMinAggregateOutputType | null
    _max: DailyChallengeMaxAggregateOutputType | null
  }

  export type DailyChallengeAvgAggregateOutputType = {
    id: number | null
  }

  export type DailyChallengeSumAggregateOutputType = {
    id: number | null
  }

  export type DailyChallengeMinAggregateOutputType = {
    prompt: string | null
    date: Date | null
    id: number | null
  }

  export type DailyChallengeMaxAggregateOutputType = {
    prompt: string | null
    date: Date | null
    id: number | null
  }

  export type DailyChallengeCountAggregateOutputType = {
    prompt: number
    date: number
    id: number
    _all: number
  }


  export type DailyChallengeAvgAggregateInputType = {
    id?: true
  }

  export type DailyChallengeSumAggregateInputType = {
    id?: true
  }

  export type DailyChallengeMinAggregateInputType = {
    prompt?: true
    date?: true
    id?: true
  }

  export type DailyChallengeMaxAggregateInputType = {
    prompt?: true
    date?: true
    id?: true
  }

  export type DailyChallengeCountAggregateInputType = {
    prompt?: true
    date?: true
    id?: true
    _all?: true
  }

  export type DailyChallengeAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallenge to aggregate.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: Enumerable<DailyChallengeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyChallenges
    **/
    _count?: true | DailyChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyChallengeMaxAggregateInputType
  }

  export type GetDailyChallengeAggregateType<T extends DailyChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyChallenge[P]>
      : GetScalarType<T[P], AggregateDailyChallenge[P]>
  }




  export type DailyChallengeGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengeWhereInput
    orderBy?: Enumerable<DailyChallengeOrderByWithAggregationInput>
    by: DailyChallengeScalarFieldEnum[]
    having?: DailyChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyChallengeCountAggregateInputType | true
    _avg?: DailyChallengeAvgAggregateInputType
    _sum?: DailyChallengeSumAggregateInputType
    _min?: DailyChallengeMinAggregateInputType
    _max?: DailyChallengeMaxAggregateInputType
  }


  export type DailyChallengeGroupByOutputType = {
    prompt: string
    date: Date
    id: number
    _count: DailyChallengeCountAggregateOutputType | null
    _avg: DailyChallengeAvgAggregateOutputType | null
    _sum: DailyChallengeSumAggregateOutputType | null
    _min: DailyChallengeMinAggregateOutputType | null
    _max: DailyChallengeMaxAggregateOutputType | null
  }

  type GetDailyChallengeGroupByPayload<T extends DailyChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DailyChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], DailyChallengeGroupByOutputType[P]>
        }
      >
    >


  export type DailyChallengeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    prompt?: boolean
    date?: boolean
    id?: boolean
    dailyChallengeResponse?: boolean | DailyChallenge$dailyChallengeResponseArgs<ExtArgs>
    _count?: boolean | DailyChallengeCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["dailyChallenge"]>

  export type DailyChallengeSelectScalar = {
    prompt?: boolean
    date?: boolean
    id?: boolean
  }

  export type DailyChallengeInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dailyChallengeResponse?: boolean | DailyChallenge$dailyChallengeResponseArgs<ExtArgs>
    _count?: boolean | DailyChallengeCountOutputTypeArgs<ExtArgs>
  }


  type DailyChallengeGetPayload<S extends boolean | null | undefined | DailyChallengeArgs> = $Types.GetResult<DailyChallengePayload, S>

  type DailyChallengeCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DailyChallengeFindManyArgs, 'select' | 'include'> & {
      select?: DailyChallengeCountAggregateInputType | true
    }

  export interface DailyChallengeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyChallenge'], meta: { name: 'DailyChallenge' } }
    /**
     * Find zero or one DailyChallenge that matches the filter.
     * @param {DailyChallengeFindUniqueArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyChallengeFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyChallengeFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyChallenge'> extends True ? Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DailyChallenge that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DailyChallengeFindUniqueOrThrowArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DailyChallengeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DailyChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeFindFirstArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyChallengeFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyChallengeFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyChallenge'> extends True ? Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DailyChallenge that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeFindFirstOrThrowArgs} args - Arguments to find a DailyChallenge
     * @example
     * // Get one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DailyChallengeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DailyChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyChallenges
     * const dailyChallenges = await prisma.dailyChallenge.findMany()
     * 
     * // Get first 10 DailyChallenges
     * const dailyChallenges = await prisma.dailyChallenge.findMany({ take: 10 })
     * 
     * // Only select the `prompt`
     * const dailyChallengeWithPromptOnly = await prisma.dailyChallenge.findMany({ select: { prompt: true } })
     * 
    **/
    findMany<T extends DailyChallengeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DailyChallenge.
     * @param {DailyChallengeCreateArgs} args - Arguments to create a DailyChallenge.
     * @example
     * // Create one DailyChallenge
     * const DailyChallenge = await prisma.dailyChallenge.create({
     *   data: {
     *     // ... data to create a DailyChallenge
     *   }
     * })
     * 
    **/
    create<T extends DailyChallengeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeCreateArgs<ExtArgs>>
    ): Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DailyChallenges.
     *     @param {DailyChallengeCreateManyArgs} args - Arguments to create many DailyChallenges.
     *     @example
     *     // Create many DailyChallenges
     *     const dailyChallenge = await prisma.dailyChallenge.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyChallengeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyChallenge.
     * @param {DailyChallengeDeleteArgs} args - Arguments to delete one DailyChallenge.
     * @example
     * // Delete one DailyChallenge
     * const DailyChallenge = await prisma.dailyChallenge.delete({
     *   where: {
     *     // ... filter to delete one DailyChallenge
     *   }
     * })
     * 
    **/
    delete<T extends DailyChallengeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeDeleteArgs<ExtArgs>>
    ): Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DailyChallenge.
     * @param {DailyChallengeUpdateArgs} args - Arguments to update one DailyChallenge.
     * @example
     * // Update one DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyChallengeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeUpdateArgs<ExtArgs>>
    ): Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DailyChallenges.
     * @param {DailyChallengeDeleteManyArgs} args - Arguments to filter DailyChallenges to delete.
     * @example
     * // Delete a few DailyChallenges
     * const { count } = await prisma.dailyChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyChallengeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyChallenges
     * const dailyChallenge = await prisma.dailyChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyChallengeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyChallenge.
     * @param {DailyChallengeUpsertArgs} args - Arguments to update or create a DailyChallenge.
     * @example
     * // Update or create a DailyChallenge
     * const dailyChallenge = await prisma.dailyChallenge.upsert({
     *   create: {
     *     // ... data to create a DailyChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyChallenge we want to update
     *   }
     * })
    **/
    upsert<T extends DailyChallengeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeUpsertArgs<ExtArgs>>
    ): Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DailyChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeCountArgs} args - Arguments to filter DailyChallenges to count.
     * @example
     * // Count the number of DailyChallenges
     * const count = await prisma.dailyChallenge.count({
     *   where: {
     *     // ... the filter for the DailyChallenges we want to count
     *   }
     * })
    **/
    count<T extends DailyChallengeCountArgs>(
      args?: Subset<T, DailyChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyChallengeAggregateArgs>(args: Subset<T, DailyChallengeAggregateArgs>): Prisma.PrismaPromise<GetDailyChallengeAggregateType<T>>

    /**
     * Group by DailyChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyChallengeGroupByArgs['orderBy'] }
        : { orderBy?: DailyChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyChallengeClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    dailyChallengeResponse<T extends DailyChallenge$dailyChallengeResponseArgs<ExtArgs> = {}>(args?: Subset<T, DailyChallenge$dailyChallengeResponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DailyChallenge base type for findUnique actions
   */
  export type DailyChallengeFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where: DailyChallengeWhereUniqueInput
  }

  /**
   * DailyChallenge findUnique
   */
  export interface DailyChallengeFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengeFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallenge findUniqueOrThrow
   */
  export type DailyChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where: DailyChallengeWhereUniqueInput
  }


  /**
   * DailyChallenge base type for findFirst actions
   */
  export type DailyChallengeFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: Enumerable<DailyChallengeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallenges.
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallenges.
     */
    distinct?: Enumerable<DailyChallengeScalarFieldEnum>
  }

  /**
   * DailyChallenge findFirst
   */
  export interface DailyChallengeFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengeFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallenge findFirstOrThrow
   */
  export type DailyChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenge to fetch.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: Enumerable<DailyChallengeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallenges.
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallenges.
     */
    distinct?: Enumerable<DailyChallengeScalarFieldEnum>
  }


  /**
   * DailyChallenge findMany
   */
  export type DailyChallengeFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallenges to fetch.
     */
    where?: DailyChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallenges to fetch.
     */
    orderBy?: Enumerable<DailyChallengeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyChallenges.
     */
    cursor?: DailyChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallenges.
     */
    skip?: number
    distinct?: Enumerable<DailyChallengeScalarFieldEnum>
  }


  /**
   * DailyChallenge create
   */
  export type DailyChallengeCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyChallenge.
     */
    data: XOR<DailyChallengeCreateInput, DailyChallengeUncheckedCreateInput>
  }


  /**
   * DailyChallenge createMany
   */
  export type DailyChallengeCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyChallenges.
     */
    data: Enumerable<DailyChallengeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DailyChallenge update
   */
  export type DailyChallengeUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyChallenge.
     */
    data: XOR<DailyChallengeUpdateInput, DailyChallengeUncheckedUpdateInput>
    /**
     * Choose, which DailyChallenge to update.
     */
    where: DailyChallengeWhereUniqueInput
  }


  /**
   * DailyChallenge updateMany
   */
  export type DailyChallengeUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyChallenges.
     */
    data: XOR<DailyChallengeUpdateManyMutationInput, DailyChallengeUncheckedUpdateManyInput>
    /**
     * Filter which DailyChallenges to update
     */
    where?: DailyChallengeWhereInput
  }


  /**
   * DailyChallenge upsert
   */
  export type DailyChallengeUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyChallenge to update in case it exists.
     */
    where: DailyChallengeWhereUniqueInput
    /**
     * In case the DailyChallenge found by the `where` argument doesn't exist, create a new DailyChallenge with this data.
     */
    create: XOR<DailyChallengeCreateInput, DailyChallengeUncheckedCreateInput>
    /**
     * In case the DailyChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyChallengeUpdateInput, DailyChallengeUncheckedUpdateInput>
  }


  /**
   * DailyChallenge delete
   */
  export type DailyChallengeDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
    /**
     * Filter which DailyChallenge to delete.
     */
    where: DailyChallengeWhereUniqueInput
  }


  /**
   * DailyChallenge deleteMany
   */
  export type DailyChallengeDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallenges to delete
     */
    where?: DailyChallengeWhereInput
  }


  /**
   * DailyChallenge.dailyChallengeResponse
   */
  export type DailyChallenge$dailyChallengeResponseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    where?: DailyChallengeResponseWhereInput
    orderBy?: Enumerable<DailyChallengeResponseOrderByWithRelationInput>
    cursor?: DailyChallengeResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyChallengeResponseScalarFieldEnum>
  }


  /**
   * DailyChallenge without action
   */
  export type DailyChallengeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallenge
     */
    select?: DailyChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeInclude<ExtArgs> | null
  }



  /**
   * Model DailyChallengeResponseLikes
   */


  export type AggregateDailyChallengeResponseLikes = {
    _count: DailyChallengeResponseLikesCountAggregateOutputType | null
    _min: DailyChallengeResponseLikesMinAggregateOutputType | null
    _max: DailyChallengeResponseLikesMaxAggregateOutputType | null
  }

  export type DailyChallengeResponseLikesMinAggregateOutputType = {
    userID: string | null
    dailyChallengeResponseID: string | null
    likeID: string | null
  }

  export type DailyChallengeResponseLikesMaxAggregateOutputType = {
    userID: string | null
    dailyChallengeResponseID: string | null
    likeID: string | null
  }

  export type DailyChallengeResponseLikesCountAggregateOutputType = {
    userID: number
    dailyChallengeResponseID: number
    likeID: number
    _all: number
  }


  export type DailyChallengeResponseLikesMinAggregateInputType = {
    userID?: true
    dailyChallengeResponseID?: true
    likeID?: true
  }

  export type DailyChallengeResponseLikesMaxAggregateInputType = {
    userID?: true
    dailyChallengeResponseID?: true
    likeID?: true
  }

  export type DailyChallengeResponseLikesCountAggregateInputType = {
    userID?: true
    dailyChallengeResponseID?: true
    likeID?: true
    _all?: true
  }

  export type DailyChallengeResponseLikesAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallengeResponseLikes to aggregate.
     */
    where?: DailyChallengeResponseLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponseLikes to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyChallengeResponseLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponseLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyChallengeResponseLikes
    **/
    _count?: true | DailyChallengeResponseLikesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyChallengeResponseLikesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyChallengeResponseLikesMaxAggregateInputType
  }

  export type GetDailyChallengeResponseLikesAggregateType<T extends DailyChallengeResponseLikesAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyChallengeResponseLikes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyChallengeResponseLikes[P]>
      : GetScalarType<T[P], AggregateDailyChallengeResponseLikes[P]>
  }




  export type DailyChallengeResponseLikesGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengeResponseLikesWhereInput
    orderBy?: Enumerable<DailyChallengeResponseLikesOrderByWithAggregationInput>
    by: DailyChallengeResponseLikesScalarFieldEnum[]
    having?: DailyChallengeResponseLikesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyChallengeResponseLikesCountAggregateInputType | true
    _min?: DailyChallengeResponseLikesMinAggregateInputType
    _max?: DailyChallengeResponseLikesMaxAggregateInputType
  }


  export type DailyChallengeResponseLikesGroupByOutputType = {
    userID: string
    dailyChallengeResponseID: string
    likeID: string
    _count: DailyChallengeResponseLikesCountAggregateOutputType | null
    _min: DailyChallengeResponseLikesMinAggregateOutputType | null
    _max: DailyChallengeResponseLikesMaxAggregateOutputType | null
  }

  type GetDailyChallengeResponseLikesGroupByPayload<T extends DailyChallengeResponseLikesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DailyChallengeResponseLikesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyChallengeResponseLikesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyChallengeResponseLikesGroupByOutputType[P]>
            : GetScalarType<T[P], DailyChallengeResponseLikesGroupByOutputType[P]>
        }
      >
    >


  export type DailyChallengeResponseLikesSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userID?: boolean
    dailyChallengeResponseID?: boolean
    likeID?: boolean
    user?: boolean | UserArgs<ExtArgs>
    dailyChallengeResponse?: boolean | DailyChallengeResponseArgs<ExtArgs>
  }, ExtArgs["result"]["dailyChallengeResponseLikes"]>

  export type DailyChallengeResponseLikesSelectScalar = {
    userID?: boolean
    dailyChallengeResponseID?: boolean
    likeID?: boolean
  }

  export type DailyChallengeResponseLikesInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    dailyChallengeResponse?: boolean | DailyChallengeResponseArgs<ExtArgs>
  }


  type DailyChallengeResponseLikesGetPayload<S extends boolean | null | undefined | DailyChallengeResponseLikesArgs> = $Types.GetResult<DailyChallengeResponseLikesPayload, S>

  type DailyChallengeResponseLikesCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DailyChallengeResponseLikesFindManyArgs, 'select' | 'include'> & {
      select?: DailyChallengeResponseLikesCountAggregateInputType | true
    }

  export interface DailyChallengeResponseLikesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyChallengeResponseLikes'], meta: { name: 'DailyChallengeResponseLikes' } }
    /**
     * Find zero or one DailyChallengeResponseLikes that matches the filter.
     * @param {DailyChallengeResponseLikesFindUniqueArgs} args - Arguments to find a DailyChallengeResponseLikes
     * @example
     * // Get one DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyChallengeResponseLikesFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyChallengeResponseLikesFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyChallengeResponseLikes'> extends True ? Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DailyChallengeResponseLikes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DailyChallengeResponseLikesFindUniqueOrThrowArgs} args - Arguments to find a DailyChallengeResponseLikes
     * @example
     * // Get one DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DailyChallengeResponseLikesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseLikesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DailyChallengeResponseLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseLikesFindFirstArgs} args - Arguments to find a DailyChallengeResponseLikes
     * @example
     * // Get one DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyChallengeResponseLikesFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyChallengeResponseLikesFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyChallengeResponseLikes'> extends True ? Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DailyChallengeResponseLikes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseLikesFindFirstOrThrowArgs} args - Arguments to find a DailyChallengeResponseLikes
     * @example
     * // Get one DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DailyChallengeResponseLikesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseLikesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DailyChallengeResponseLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseLikesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.findMany()
     * 
     * // Get first 10 DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const dailyChallengeResponseLikesWithUserIDOnly = await prisma.dailyChallengeResponseLikes.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends DailyChallengeResponseLikesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseLikesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DailyChallengeResponseLikes.
     * @param {DailyChallengeResponseLikesCreateArgs} args - Arguments to create a DailyChallengeResponseLikes.
     * @example
     * // Create one DailyChallengeResponseLikes
     * const DailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.create({
     *   data: {
     *     // ... data to create a DailyChallengeResponseLikes
     *   }
     * })
     * 
    **/
    create<T extends DailyChallengeResponseLikesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseLikesCreateArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DailyChallengeResponseLikes.
     *     @param {DailyChallengeResponseLikesCreateManyArgs} args - Arguments to create many DailyChallengeResponseLikes.
     *     @example
     *     // Create many DailyChallengeResponseLikes
     *     const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyChallengeResponseLikesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseLikesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyChallengeResponseLikes.
     * @param {DailyChallengeResponseLikesDeleteArgs} args - Arguments to delete one DailyChallengeResponseLikes.
     * @example
     * // Delete one DailyChallengeResponseLikes
     * const DailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.delete({
     *   where: {
     *     // ... filter to delete one DailyChallengeResponseLikes
     *   }
     * })
     * 
    **/
    delete<T extends DailyChallengeResponseLikesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseLikesDeleteArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DailyChallengeResponseLikes.
     * @param {DailyChallengeResponseLikesUpdateArgs} args - Arguments to update one DailyChallengeResponseLikes.
     * @example
     * // Update one DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyChallengeResponseLikesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseLikesUpdateArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DailyChallengeResponseLikes.
     * @param {DailyChallengeResponseLikesDeleteManyArgs} args - Arguments to filter DailyChallengeResponseLikes to delete.
     * @example
     * // Delete a few DailyChallengeResponseLikes
     * const { count } = await prisma.dailyChallengeResponseLikes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyChallengeResponseLikesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseLikesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyChallengeResponseLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseLikesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyChallengeResponseLikesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseLikesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyChallengeResponseLikes.
     * @param {DailyChallengeResponseLikesUpsertArgs} args - Arguments to update or create a DailyChallengeResponseLikes.
     * @example
     * // Update or create a DailyChallengeResponseLikes
     * const dailyChallengeResponseLikes = await prisma.dailyChallengeResponseLikes.upsert({
     *   create: {
     *     // ... data to create a DailyChallengeResponseLikes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyChallengeResponseLikes we want to update
     *   }
     * })
    **/
    upsert<T extends DailyChallengeResponseLikesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseLikesUpsertArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseLikesClient<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DailyChallengeResponseLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseLikesCountArgs} args - Arguments to filter DailyChallengeResponseLikes to count.
     * @example
     * // Count the number of DailyChallengeResponseLikes
     * const count = await prisma.dailyChallengeResponseLikes.count({
     *   where: {
     *     // ... the filter for the DailyChallengeResponseLikes we want to count
     *   }
     * })
    **/
    count<T extends DailyChallengeResponseLikesCountArgs>(
      args?: Subset<T, DailyChallengeResponseLikesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyChallengeResponseLikesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyChallengeResponseLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseLikesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyChallengeResponseLikesAggregateArgs>(args: Subset<T, DailyChallengeResponseLikesAggregateArgs>): Prisma.PrismaPromise<GetDailyChallengeResponseLikesAggregateType<T>>

    /**
     * Group by DailyChallengeResponseLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseLikesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyChallengeResponseLikesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyChallengeResponseLikesGroupByArgs['orderBy'] }
        : { orderBy?: DailyChallengeResponseLikesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyChallengeResponseLikesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyChallengeResponseLikesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyChallengeResponseLikes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyChallengeResponseLikesClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    dailyChallengeResponse<T extends DailyChallengeResponseArgs<ExtArgs> = {}>(args?: Subset<T, DailyChallengeResponseArgs<ExtArgs>>): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DailyChallengeResponseLikes base type for findUnique actions
   */
  export type DailyChallengeResponseLikesFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponseLikes to fetch.
     */
    where: DailyChallengeResponseLikesWhereUniqueInput
  }

  /**
   * DailyChallengeResponseLikes findUnique
   */
  export interface DailyChallengeResponseLikesFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengeResponseLikesFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallengeResponseLikes findUniqueOrThrow
   */
  export type DailyChallengeResponseLikesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponseLikes to fetch.
     */
    where: DailyChallengeResponseLikesWhereUniqueInput
  }


  /**
   * DailyChallengeResponseLikes base type for findFirst actions
   */
  export type DailyChallengeResponseLikesFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponseLikes to fetch.
     */
    where?: DailyChallengeResponseLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponseLikes to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallengeResponseLikes.
     */
    cursor?: DailyChallengeResponseLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponseLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallengeResponseLikes.
     */
    distinct?: Enumerable<DailyChallengeResponseLikesScalarFieldEnum>
  }

  /**
   * DailyChallengeResponseLikes findFirst
   */
  export interface DailyChallengeResponseLikesFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengeResponseLikesFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallengeResponseLikes findFirstOrThrow
   */
  export type DailyChallengeResponseLikesFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponseLikes to fetch.
     */
    where?: DailyChallengeResponseLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponseLikes to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallengeResponseLikes.
     */
    cursor?: DailyChallengeResponseLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponseLikes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallengeResponseLikes.
     */
    distinct?: Enumerable<DailyChallengeResponseLikesScalarFieldEnum>
  }


  /**
   * DailyChallengeResponseLikes findMany
   */
  export type DailyChallengeResponseLikesFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponseLikes to fetch.
     */
    where?: DailyChallengeResponseLikesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponseLikes to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseLikesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyChallengeResponseLikes.
     */
    cursor?: DailyChallengeResponseLikesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponseLikes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponseLikes.
     */
    skip?: number
    distinct?: Enumerable<DailyChallengeResponseLikesScalarFieldEnum>
  }


  /**
   * DailyChallengeResponseLikes create
   */
  export type DailyChallengeResponseLikesCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyChallengeResponseLikes.
     */
    data: XOR<DailyChallengeResponseLikesCreateInput, DailyChallengeResponseLikesUncheckedCreateInput>
  }


  /**
   * DailyChallengeResponseLikes createMany
   */
  export type DailyChallengeResponseLikesCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyChallengeResponseLikes.
     */
    data: Enumerable<DailyChallengeResponseLikesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DailyChallengeResponseLikes update
   */
  export type DailyChallengeResponseLikesUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyChallengeResponseLikes.
     */
    data: XOR<DailyChallengeResponseLikesUpdateInput, DailyChallengeResponseLikesUncheckedUpdateInput>
    /**
     * Choose, which DailyChallengeResponseLikes to update.
     */
    where: DailyChallengeResponseLikesWhereUniqueInput
  }


  /**
   * DailyChallengeResponseLikes updateMany
   */
  export type DailyChallengeResponseLikesUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyChallengeResponseLikes.
     */
    data: XOR<DailyChallengeResponseLikesUpdateManyMutationInput, DailyChallengeResponseLikesUncheckedUpdateManyInput>
    /**
     * Filter which DailyChallengeResponseLikes to update
     */
    where?: DailyChallengeResponseLikesWhereInput
  }


  /**
   * DailyChallengeResponseLikes upsert
   */
  export type DailyChallengeResponseLikesUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyChallengeResponseLikes to update in case it exists.
     */
    where: DailyChallengeResponseLikesWhereUniqueInput
    /**
     * In case the DailyChallengeResponseLikes found by the `where` argument doesn't exist, create a new DailyChallengeResponseLikes with this data.
     */
    create: XOR<DailyChallengeResponseLikesCreateInput, DailyChallengeResponseLikesUncheckedCreateInput>
    /**
     * In case the DailyChallengeResponseLikes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyChallengeResponseLikesUpdateInput, DailyChallengeResponseLikesUncheckedUpdateInput>
  }


  /**
   * DailyChallengeResponseLikes delete
   */
  export type DailyChallengeResponseLikesDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    /**
     * Filter which DailyChallengeResponseLikes to delete.
     */
    where: DailyChallengeResponseLikesWhereUniqueInput
  }


  /**
   * DailyChallengeResponseLikes deleteMany
   */
  export type DailyChallengeResponseLikesDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallengeResponseLikes to delete
     */
    where?: DailyChallengeResponseLikesWhereInput
  }


  /**
   * DailyChallengeResponseLikes without action
   */
  export type DailyChallengeResponseLikesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
  }



  /**
   * Model DailyChallengeResponse
   */


  export type AggregateDailyChallengeResponse = {
    _count: DailyChallengeResponseCountAggregateOutputType | null
    _avg: DailyChallengeResponseAvgAggregateOutputType | null
    _sum: DailyChallengeResponseSumAggregateOutputType | null
    _min: DailyChallengeResponseMinAggregateOutputType | null
    _max: DailyChallengeResponseMaxAggregateOutputType | null
  }

  export type DailyChallengeResponseAvgAggregateOutputType = {
    dailyChallengeID: number | null
    wordCount: number | null
  }

  export type DailyChallengeResponseSumAggregateOutputType = {
    dailyChallengeID: number | null
    wordCount: number | null
  }

  export type DailyChallengeResponseMinAggregateOutputType = {
    userID: string | null
    dailyChallengeID: number | null
    dailyChallengeResponseID: string | null
    postedOn: Date | null
    wordCount: number | null
    completedOnTime: boolean | null
  }

  export type DailyChallengeResponseMaxAggregateOutputType = {
    userID: string | null
    dailyChallengeID: number | null
    dailyChallengeResponseID: string | null
    postedOn: Date | null
    wordCount: number | null
    completedOnTime: boolean | null
  }

  export type DailyChallengeResponseCountAggregateOutputType = {
    userID: number
    dailyChallengeID: number
    dailyChallengeResponseID: number
    content: number
    postedOn: number
    wordCount: number
    completedOnTime: number
    _all: number
  }


  export type DailyChallengeResponseAvgAggregateInputType = {
    dailyChallengeID?: true
    wordCount?: true
  }

  export type DailyChallengeResponseSumAggregateInputType = {
    dailyChallengeID?: true
    wordCount?: true
  }

  export type DailyChallengeResponseMinAggregateInputType = {
    userID?: true
    dailyChallengeID?: true
    dailyChallengeResponseID?: true
    postedOn?: true
    wordCount?: true
    completedOnTime?: true
  }

  export type DailyChallengeResponseMaxAggregateInputType = {
    userID?: true
    dailyChallengeID?: true
    dailyChallengeResponseID?: true
    postedOn?: true
    wordCount?: true
    completedOnTime?: true
  }

  export type DailyChallengeResponseCountAggregateInputType = {
    userID?: true
    dailyChallengeID?: true
    dailyChallengeResponseID?: true
    content?: true
    postedOn?: true
    wordCount?: true
    completedOnTime?: true
    _all?: true
  }

  export type DailyChallengeResponseAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallengeResponse to aggregate.
     */
    where?: DailyChallengeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponses to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyChallengeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyChallengeResponses
    **/
    _count?: true | DailyChallengeResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyChallengeResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyChallengeResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyChallengeResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyChallengeResponseMaxAggregateInputType
  }

  export type GetDailyChallengeResponseAggregateType<T extends DailyChallengeResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyChallengeResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyChallengeResponse[P]>
      : GetScalarType<T[P], AggregateDailyChallengeResponse[P]>
  }




  export type DailyChallengeResponseGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengeResponseWhereInput
    orderBy?: Enumerable<DailyChallengeResponseOrderByWithAggregationInput>
    by: DailyChallengeResponseScalarFieldEnum[]
    having?: DailyChallengeResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyChallengeResponseCountAggregateInputType | true
    _avg?: DailyChallengeResponseAvgAggregateInputType
    _sum?: DailyChallengeResponseSumAggregateInputType
    _min?: DailyChallengeResponseMinAggregateInputType
    _max?: DailyChallengeResponseMaxAggregateInputType
  }


  export type DailyChallengeResponseGroupByOutputType = {
    userID: string | null
    dailyChallengeID: number
    dailyChallengeResponseID: string
    content: JsonValue | null
    postedOn: Date | null
    wordCount: number
    completedOnTime: boolean
    _count: DailyChallengeResponseCountAggregateOutputType | null
    _avg: DailyChallengeResponseAvgAggregateOutputType | null
    _sum: DailyChallengeResponseSumAggregateOutputType | null
    _min: DailyChallengeResponseMinAggregateOutputType | null
    _max: DailyChallengeResponseMaxAggregateOutputType | null
  }

  type GetDailyChallengeResponseGroupByPayload<T extends DailyChallengeResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DailyChallengeResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyChallengeResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyChallengeResponseGroupByOutputType[P]>
            : GetScalarType<T[P], DailyChallengeResponseGroupByOutputType[P]>
        }
      >
    >


  export type DailyChallengeResponseSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userID?: boolean
    dailyChallengeID?: boolean
    dailyChallengeResponseID?: boolean
    content?: boolean
    postedOn?: boolean
    wordCount?: boolean
    completedOnTime?: boolean
    user?: boolean | UserArgs<ExtArgs>
    likes?: boolean | DailyChallengeResponse$likesArgs<ExtArgs>
    dailyChallenge?: boolean | DailyChallengeArgs<ExtArgs>
    dailyStatUnit?: boolean | DailyChallengeResponse$dailyStatUnitArgs<ExtArgs>
    _count?: boolean | DailyChallengeResponseCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["dailyChallengeResponse"]>

  export type DailyChallengeResponseSelectScalar = {
    userID?: boolean
    dailyChallengeID?: boolean
    dailyChallengeResponseID?: boolean
    content?: boolean
    postedOn?: boolean
    wordCount?: boolean
    completedOnTime?: boolean
  }

  export type DailyChallengeResponseInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
    likes?: boolean | DailyChallengeResponse$likesArgs<ExtArgs>
    dailyChallenge?: boolean | DailyChallengeArgs<ExtArgs>
    dailyStatUnit?: boolean | DailyChallengeResponse$dailyStatUnitArgs<ExtArgs>
    _count?: boolean | DailyChallengeResponseCountOutputTypeArgs<ExtArgs>
  }


  type DailyChallengeResponseGetPayload<S extends boolean | null | undefined | DailyChallengeResponseArgs> = $Types.GetResult<DailyChallengeResponsePayload, S>

  type DailyChallengeResponseCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DailyChallengeResponseFindManyArgs, 'select' | 'include'> & {
      select?: DailyChallengeResponseCountAggregateInputType | true
    }

  export interface DailyChallengeResponseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyChallengeResponse'], meta: { name: 'DailyChallengeResponse' } }
    /**
     * Find zero or one DailyChallengeResponse that matches the filter.
     * @param {DailyChallengeResponseFindUniqueArgs} args - Arguments to find a DailyChallengeResponse
     * @example
     * // Get one DailyChallengeResponse
     * const dailyChallengeResponse = await prisma.dailyChallengeResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyChallengeResponseFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyChallengeResponseFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyChallengeResponse'> extends True ? Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DailyChallengeResponse that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DailyChallengeResponseFindUniqueOrThrowArgs} args - Arguments to find a DailyChallengeResponse
     * @example
     * // Get one DailyChallengeResponse
     * const dailyChallengeResponse = await prisma.dailyChallengeResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DailyChallengeResponseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DailyChallengeResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseFindFirstArgs} args - Arguments to find a DailyChallengeResponse
     * @example
     * // Get one DailyChallengeResponse
     * const dailyChallengeResponse = await prisma.dailyChallengeResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyChallengeResponseFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyChallengeResponseFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyChallengeResponse'> extends True ? Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DailyChallengeResponse that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseFindFirstOrThrowArgs} args - Arguments to find a DailyChallengeResponse
     * @example
     * // Get one DailyChallengeResponse
     * const dailyChallengeResponse = await prisma.dailyChallengeResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DailyChallengeResponseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DailyChallengeResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyChallengeResponses
     * const dailyChallengeResponses = await prisma.dailyChallengeResponse.findMany()
     * 
     * // Get first 10 DailyChallengeResponses
     * const dailyChallengeResponses = await prisma.dailyChallengeResponse.findMany({ take: 10 })
     * 
     * // Only select the `userID`
     * const dailyChallengeResponseWithUserIDOnly = await prisma.dailyChallengeResponse.findMany({ select: { userID: true } })
     * 
    **/
    findMany<T extends DailyChallengeResponseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DailyChallengeResponse.
     * @param {DailyChallengeResponseCreateArgs} args - Arguments to create a DailyChallengeResponse.
     * @example
     * // Create one DailyChallengeResponse
     * const DailyChallengeResponse = await prisma.dailyChallengeResponse.create({
     *   data: {
     *     // ... data to create a DailyChallengeResponse
     *   }
     * })
     * 
    **/
    create<T extends DailyChallengeResponseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseCreateArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DailyChallengeResponses.
     *     @param {DailyChallengeResponseCreateManyArgs} args - Arguments to create many DailyChallengeResponses.
     *     @example
     *     // Create many DailyChallengeResponses
     *     const dailyChallengeResponse = await prisma.dailyChallengeResponse.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyChallengeResponseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyChallengeResponse.
     * @param {DailyChallengeResponseDeleteArgs} args - Arguments to delete one DailyChallengeResponse.
     * @example
     * // Delete one DailyChallengeResponse
     * const DailyChallengeResponse = await prisma.dailyChallengeResponse.delete({
     *   where: {
     *     // ... filter to delete one DailyChallengeResponse
     *   }
     * })
     * 
    **/
    delete<T extends DailyChallengeResponseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseDeleteArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DailyChallengeResponse.
     * @param {DailyChallengeResponseUpdateArgs} args - Arguments to update one DailyChallengeResponse.
     * @example
     * // Update one DailyChallengeResponse
     * const dailyChallengeResponse = await prisma.dailyChallengeResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyChallengeResponseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseUpdateArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DailyChallengeResponses.
     * @param {DailyChallengeResponseDeleteManyArgs} args - Arguments to filter DailyChallengeResponses to delete.
     * @example
     * // Delete a few DailyChallengeResponses
     * const { count } = await prisma.dailyChallengeResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyChallengeResponseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengeResponseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyChallengeResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyChallengeResponses
     * const dailyChallengeResponse = await prisma.dailyChallengeResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyChallengeResponseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyChallengeResponse.
     * @param {DailyChallengeResponseUpsertArgs} args - Arguments to update or create a DailyChallengeResponse.
     * @example
     * // Update or create a DailyChallengeResponse
     * const dailyChallengeResponse = await prisma.dailyChallengeResponse.upsert({
     *   create: {
     *     // ... data to create a DailyChallengeResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyChallengeResponse we want to update
     *   }
     * })
    **/
    upsert<T extends DailyChallengeResponseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengeResponseUpsertArgs<ExtArgs>>
    ): Prisma__DailyChallengeResponseClient<$Types.GetResult<DailyChallengeResponsePayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DailyChallengeResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseCountArgs} args - Arguments to filter DailyChallengeResponses to count.
     * @example
     * // Count the number of DailyChallengeResponses
     * const count = await prisma.dailyChallengeResponse.count({
     *   where: {
     *     // ... the filter for the DailyChallengeResponses we want to count
     *   }
     * })
    **/
    count<T extends DailyChallengeResponseCountArgs>(
      args?: Subset<T, DailyChallengeResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyChallengeResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyChallengeResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyChallengeResponseAggregateArgs>(args: Subset<T, DailyChallengeResponseAggregateArgs>): Prisma.PrismaPromise<GetDailyChallengeResponseAggregateType<T>>

    /**
     * Group by DailyChallengeResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengeResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyChallengeResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyChallengeResponseGroupByArgs['orderBy'] }
        : { orderBy?: DailyChallengeResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyChallengeResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyChallengeResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyChallengeResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyChallengeResponseClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    likes<T extends DailyChallengeResponse$likesArgs<ExtArgs> = {}>(args?: Subset<T, DailyChallengeResponse$likesArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyChallengeResponseLikesPayload<ExtArgs>, T, 'findMany', never>| Null>;

    dailyChallenge<T extends DailyChallengeArgs<ExtArgs> = {}>(args?: Subset<T, DailyChallengeArgs<ExtArgs>>): Prisma__DailyChallengeClient<$Types.GetResult<DailyChallengePayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    dailyStatUnit<T extends DailyChallengeResponse$dailyStatUnitArgs<ExtArgs> = {}>(args?: Subset<T, DailyChallengeResponse$dailyStatUnitArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<DailyStatUnitPayload<ExtArgs>, T, 'findMany', never>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DailyChallengeResponse base type for findUnique actions
   */
  export type DailyChallengeResponseFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponse to fetch.
     */
    where: DailyChallengeResponseWhereUniqueInput
  }

  /**
   * DailyChallengeResponse findUnique
   */
  export interface DailyChallengeResponseFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengeResponseFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallengeResponse findUniqueOrThrow
   */
  export type DailyChallengeResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponse to fetch.
     */
    where: DailyChallengeResponseWhereUniqueInput
  }


  /**
   * DailyChallengeResponse base type for findFirst actions
   */
  export type DailyChallengeResponseFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponse to fetch.
     */
    where?: DailyChallengeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponses to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallengeResponses.
     */
    cursor?: DailyChallengeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallengeResponses.
     */
    distinct?: Enumerable<DailyChallengeResponseScalarFieldEnum>
  }

  /**
   * DailyChallengeResponse findFirst
   */
  export interface DailyChallengeResponseFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengeResponseFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallengeResponse findFirstOrThrow
   */
  export type DailyChallengeResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponse to fetch.
     */
    where?: DailyChallengeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponses to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallengeResponses.
     */
    cursor?: DailyChallengeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallengeResponses.
     */
    distinct?: Enumerable<DailyChallengeResponseScalarFieldEnum>
  }


  /**
   * DailyChallengeResponse findMany
   */
  export type DailyChallengeResponseFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengeResponses to fetch.
     */
    where?: DailyChallengeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengeResponses to fetch.
     */
    orderBy?: Enumerable<DailyChallengeResponseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyChallengeResponses.
     */
    cursor?: DailyChallengeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengeResponses.
     */
    skip?: number
    distinct?: Enumerable<DailyChallengeResponseScalarFieldEnum>
  }


  /**
   * DailyChallengeResponse create
   */
  export type DailyChallengeResponseCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyChallengeResponse.
     */
    data: XOR<DailyChallengeResponseCreateInput, DailyChallengeResponseUncheckedCreateInput>
  }


  /**
   * DailyChallengeResponse createMany
   */
  export type DailyChallengeResponseCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyChallengeResponses.
     */
    data: Enumerable<DailyChallengeResponseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DailyChallengeResponse update
   */
  export type DailyChallengeResponseUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyChallengeResponse.
     */
    data: XOR<DailyChallengeResponseUpdateInput, DailyChallengeResponseUncheckedUpdateInput>
    /**
     * Choose, which DailyChallengeResponse to update.
     */
    where: DailyChallengeResponseWhereUniqueInput
  }


  /**
   * DailyChallengeResponse updateMany
   */
  export type DailyChallengeResponseUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyChallengeResponses.
     */
    data: XOR<DailyChallengeResponseUpdateManyMutationInput, DailyChallengeResponseUncheckedUpdateManyInput>
    /**
     * Filter which DailyChallengeResponses to update
     */
    where?: DailyChallengeResponseWhereInput
  }


  /**
   * DailyChallengeResponse upsert
   */
  export type DailyChallengeResponseUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyChallengeResponse to update in case it exists.
     */
    where: DailyChallengeResponseWhereUniqueInput
    /**
     * In case the DailyChallengeResponse found by the `where` argument doesn't exist, create a new DailyChallengeResponse with this data.
     */
    create: XOR<DailyChallengeResponseCreateInput, DailyChallengeResponseUncheckedCreateInput>
    /**
     * In case the DailyChallengeResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyChallengeResponseUpdateInput, DailyChallengeResponseUncheckedUpdateInput>
  }


  /**
   * DailyChallengeResponse delete
   */
  export type DailyChallengeResponseDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
    /**
     * Filter which DailyChallengeResponse to delete.
     */
    where: DailyChallengeResponseWhereUniqueInput
  }


  /**
   * DailyChallengeResponse deleteMany
   */
  export type DailyChallengeResponseDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallengeResponses to delete
     */
    where?: DailyChallengeResponseWhereInput
  }


  /**
   * DailyChallengeResponse.likes
   */
  export type DailyChallengeResponse$likesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponseLikes
     */
    select?: DailyChallengeResponseLikesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseLikesInclude<ExtArgs> | null
    where?: DailyChallengeResponseLikesWhereInput
    orderBy?: Enumerable<DailyChallengeResponseLikesOrderByWithRelationInput>
    cursor?: DailyChallengeResponseLikesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyChallengeResponseLikesScalarFieldEnum>
  }


  /**
   * DailyChallengeResponse.dailyStatUnit
   */
  export type DailyChallengeResponse$dailyStatUnitArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyStatUnit
     */
    select?: DailyStatUnitSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyStatUnitInclude<ExtArgs> | null
    where?: DailyStatUnitWhereInput
    orderBy?: Enumerable<DailyStatUnitOrderByWithRelationInput>
    cursor?: DailyStatUnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DailyStatUnitScalarFieldEnum>
  }


  /**
   * DailyChallengeResponse without action
   */
  export type DailyChallengeResponseArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengeResponse
     */
    select?: DailyChallengeResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengeResponseInclude<ExtArgs> | null
  }



  /**
   * Model DailyChallengePromptSuggestion
   */


  export type AggregateDailyChallengePromptSuggestion = {
    _count: DailyChallengePromptSuggestionCountAggregateOutputType | null
    _min: DailyChallengePromptSuggestionMinAggregateOutputType | null
    _max: DailyChallengePromptSuggestionMaxAggregateOutputType | null
  }

  export type DailyChallengePromptSuggestionMinAggregateOutputType = {
    promptSuggestionID: string | null
    prompt: string | null
    userID: string | null
    createdAt: Date | null
    usedOn: Date | null
  }

  export type DailyChallengePromptSuggestionMaxAggregateOutputType = {
    promptSuggestionID: string | null
    prompt: string | null
    userID: string | null
    createdAt: Date | null
    usedOn: Date | null
  }

  export type DailyChallengePromptSuggestionCountAggregateOutputType = {
    promptSuggestionID: number
    prompt: number
    userID: number
    createdAt: number
    usedOn: number
    _all: number
  }


  export type DailyChallengePromptSuggestionMinAggregateInputType = {
    promptSuggestionID?: true
    prompt?: true
    userID?: true
    createdAt?: true
    usedOn?: true
  }

  export type DailyChallengePromptSuggestionMaxAggregateInputType = {
    promptSuggestionID?: true
    prompt?: true
    userID?: true
    createdAt?: true
    usedOn?: true
  }

  export type DailyChallengePromptSuggestionCountAggregateInputType = {
    promptSuggestionID?: true
    prompt?: true
    userID?: true
    createdAt?: true
    usedOn?: true
    _all?: true
  }

  export type DailyChallengePromptSuggestionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallengePromptSuggestion to aggregate.
     */
    where?: DailyChallengePromptSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengePromptSuggestions to fetch.
     */
    orderBy?: Enumerable<DailyChallengePromptSuggestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyChallengePromptSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengePromptSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengePromptSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyChallengePromptSuggestions
    **/
    _count?: true | DailyChallengePromptSuggestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyChallengePromptSuggestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyChallengePromptSuggestionMaxAggregateInputType
  }

  export type GetDailyChallengePromptSuggestionAggregateType<T extends DailyChallengePromptSuggestionAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyChallengePromptSuggestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyChallengePromptSuggestion[P]>
      : GetScalarType<T[P], AggregateDailyChallengePromptSuggestion[P]>
  }




  export type DailyChallengePromptSuggestionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DailyChallengePromptSuggestionWhereInput
    orderBy?: Enumerable<DailyChallengePromptSuggestionOrderByWithAggregationInput>
    by: DailyChallengePromptSuggestionScalarFieldEnum[]
    having?: DailyChallengePromptSuggestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyChallengePromptSuggestionCountAggregateInputType | true
    _min?: DailyChallengePromptSuggestionMinAggregateInputType
    _max?: DailyChallengePromptSuggestionMaxAggregateInputType
  }


  export type DailyChallengePromptSuggestionGroupByOutputType = {
    promptSuggestionID: string
    prompt: string
    userID: string
    createdAt: Date
    usedOn: Date | null
    _count: DailyChallengePromptSuggestionCountAggregateOutputType | null
    _min: DailyChallengePromptSuggestionMinAggregateOutputType | null
    _max: DailyChallengePromptSuggestionMaxAggregateOutputType | null
  }

  type GetDailyChallengePromptSuggestionGroupByPayload<T extends DailyChallengePromptSuggestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DailyChallengePromptSuggestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyChallengePromptSuggestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyChallengePromptSuggestionGroupByOutputType[P]>
            : GetScalarType<T[P], DailyChallengePromptSuggestionGroupByOutputType[P]>
        }
      >
    >


  export type DailyChallengePromptSuggestionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    promptSuggestionID?: boolean
    prompt?: boolean
    userID?: boolean
    createdAt?: boolean
    usedOn?: boolean
    user?: boolean | UserArgs<ExtArgs>
  }, ExtArgs["result"]["dailyChallengePromptSuggestion"]>

  export type DailyChallengePromptSuggestionSelectScalar = {
    promptSuggestionID?: boolean
    prompt?: boolean
    userID?: boolean
    createdAt?: boolean
    usedOn?: boolean
  }

  export type DailyChallengePromptSuggestionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserArgs<ExtArgs>
  }


  type DailyChallengePromptSuggestionGetPayload<S extends boolean | null | undefined | DailyChallengePromptSuggestionArgs> = $Types.GetResult<DailyChallengePromptSuggestionPayload, S>

  type DailyChallengePromptSuggestionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DailyChallengePromptSuggestionFindManyArgs, 'select' | 'include'> & {
      select?: DailyChallengePromptSuggestionCountAggregateInputType | true
    }

  export interface DailyChallengePromptSuggestionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyChallengePromptSuggestion'], meta: { name: 'DailyChallengePromptSuggestion' } }
    /**
     * Find zero or one DailyChallengePromptSuggestion that matches the filter.
     * @param {DailyChallengePromptSuggestionFindUniqueArgs} args - Arguments to find a DailyChallengePromptSuggestion
     * @example
     * // Get one DailyChallengePromptSuggestion
     * const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DailyChallengePromptSuggestionFindUniqueArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DailyChallengePromptSuggestionFindUniqueArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DailyChallengePromptSuggestion'> extends True ? Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findUnique', never>, never, ExtArgs> : Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findUnique', never> | null, null, ExtArgs>

    /**
     * Find one DailyChallengePromptSuggestion that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DailyChallengePromptSuggestionFindUniqueOrThrowArgs} args - Arguments to find a DailyChallengePromptSuggestion
     * @example
     * // Get one DailyChallengePromptSuggestion
     * const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DailyChallengePromptSuggestionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengePromptSuggestionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findUniqueOrThrow', never>, never, ExtArgs>

    /**
     * Find the first DailyChallengePromptSuggestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengePromptSuggestionFindFirstArgs} args - Arguments to find a DailyChallengePromptSuggestion
     * @example
     * // Get one DailyChallengePromptSuggestion
     * const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DailyChallengePromptSuggestionFindFirstArgs<ExtArgs>, LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DailyChallengePromptSuggestionFindFirstArgs<ExtArgs>>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DailyChallengePromptSuggestion'> extends True ? Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findFirst', never>, never, ExtArgs> : Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findFirst', never> | null, null, ExtArgs>

    /**
     * Find the first DailyChallengePromptSuggestion that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengePromptSuggestionFindFirstOrThrowArgs} args - Arguments to find a DailyChallengePromptSuggestion
     * @example
     * // Get one DailyChallengePromptSuggestion
     * const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DailyChallengePromptSuggestionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengePromptSuggestionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findFirstOrThrow', never>, never, ExtArgs>

    /**
     * Find zero or more DailyChallengePromptSuggestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengePromptSuggestionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyChallengePromptSuggestions
     * const dailyChallengePromptSuggestions = await prisma.dailyChallengePromptSuggestion.findMany()
     * 
     * // Get first 10 DailyChallengePromptSuggestions
     * const dailyChallengePromptSuggestions = await prisma.dailyChallengePromptSuggestion.findMany({ take: 10 })
     * 
     * // Only select the `promptSuggestionID`
     * const dailyChallengePromptSuggestionWithPromptSuggestionIDOnly = await prisma.dailyChallengePromptSuggestion.findMany({ select: { promptSuggestionID: true } })
     * 
    **/
    findMany<T extends DailyChallengePromptSuggestionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengePromptSuggestionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'findMany', never>>

    /**
     * Create a DailyChallengePromptSuggestion.
     * @param {DailyChallengePromptSuggestionCreateArgs} args - Arguments to create a DailyChallengePromptSuggestion.
     * @example
     * // Create one DailyChallengePromptSuggestion
     * const DailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.create({
     *   data: {
     *     // ... data to create a DailyChallengePromptSuggestion
     *   }
     * })
     * 
    **/
    create<T extends DailyChallengePromptSuggestionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengePromptSuggestionCreateArgs<ExtArgs>>
    ): Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'create', never>, never, ExtArgs>

    /**
     * Create many DailyChallengePromptSuggestions.
     *     @param {DailyChallengePromptSuggestionCreateManyArgs} args - Arguments to create many DailyChallengePromptSuggestions.
     *     @example
     *     // Create many DailyChallengePromptSuggestions
     *     const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DailyChallengePromptSuggestionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengePromptSuggestionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DailyChallengePromptSuggestion.
     * @param {DailyChallengePromptSuggestionDeleteArgs} args - Arguments to delete one DailyChallengePromptSuggestion.
     * @example
     * // Delete one DailyChallengePromptSuggestion
     * const DailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.delete({
     *   where: {
     *     // ... filter to delete one DailyChallengePromptSuggestion
     *   }
     * })
     * 
    **/
    delete<T extends DailyChallengePromptSuggestionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengePromptSuggestionDeleteArgs<ExtArgs>>
    ): Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'delete', never>, never, ExtArgs>

    /**
     * Update one DailyChallengePromptSuggestion.
     * @param {DailyChallengePromptSuggestionUpdateArgs} args - Arguments to update one DailyChallengePromptSuggestion.
     * @example
     * // Update one DailyChallengePromptSuggestion
     * const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DailyChallengePromptSuggestionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengePromptSuggestionUpdateArgs<ExtArgs>>
    ): Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'update', never>, never, ExtArgs>

    /**
     * Delete zero or more DailyChallengePromptSuggestions.
     * @param {DailyChallengePromptSuggestionDeleteManyArgs} args - Arguments to filter DailyChallengePromptSuggestions to delete.
     * @example
     * // Delete a few DailyChallengePromptSuggestions
     * const { count } = await prisma.dailyChallengePromptSuggestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DailyChallengePromptSuggestionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DailyChallengePromptSuggestionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyChallengePromptSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengePromptSuggestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyChallengePromptSuggestions
     * const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DailyChallengePromptSuggestionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengePromptSuggestionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DailyChallengePromptSuggestion.
     * @param {DailyChallengePromptSuggestionUpsertArgs} args - Arguments to update or create a DailyChallengePromptSuggestion.
     * @example
     * // Update or create a DailyChallengePromptSuggestion
     * const dailyChallengePromptSuggestion = await prisma.dailyChallengePromptSuggestion.upsert({
     *   create: {
     *     // ... data to create a DailyChallengePromptSuggestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyChallengePromptSuggestion we want to update
     *   }
     * })
    **/
    upsert<T extends DailyChallengePromptSuggestionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DailyChallengePromptSuggestionUpsertArgs<ExtArgs>>
    ): Prisma__DailyChallengePromptSuggestionClient<$Types.GetResult<DailyChallengePromptSuggestionPayload<ExtArgs>, T, 'upsert', never>, never, ExtArgs>

    /**
     * Count the number of DailyChallengePromptSuggestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengePromptSuggestionCountArgs} args - Arguments to filter DailyChallengePromptSuggestions to count.
     * @example
     * // Count the number of DailyChallengePromptSuggestions
     * const count = await prisma.dailyChallengePromptSuggestion.count({
     *   where: {
     *     // ... the filter for the DailyChallengePromptSuggestions we want to count
     *   }
     * })
    **/
    count<T extends DailyChallengePromptSuggestionCountArgs>(
      args?: Subset<T, DailyChallengePromptSuggestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyChallengePromptSuggestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyChallengePromptSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengePromptSuggestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyChallengePromptSuggestionAggregateArgs>(args: Subset<T, DailyChallengePromptSuggestionAggregateArgs>): Prisma.PrismaPromise<GetDailyChallengePromptSuggestionAggregateType<T>>

    /**
     * Group by DailyChallengePromptSuggestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyChallengePromptSuggestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyChallengePromptSuggestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyChallengePromptSuggestionGroupByArgs['orderBy'] }
        : { orderBy?: DailyChallengePromptSuggestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyChallengePromptSuggestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyChallengePromptSuggestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyChallengePromptSuggestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DailyChallengePromptSuggestionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends UserArgs<ExtArgs> = {}>(args?: Subset<T, UserArgs<ExtArgs>>): Prisma__UserClient<$Types.GetResult<UserPayload<ExtArgs>, T, 'findUnique', never> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * DailyChallengePromptSuggestion base type for findUnique actions
   */
  export type DailyChallengePromptSuggestionFindUniqueArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengePromptSuggestion to fetch.
     */
    where: DailyChallengePromptSuggestionWhereUniqueInput
  }

  /**
   * DailyChallengePromptSuggestion findUnique
   */
  export interface DailyChallengePromptSuggestionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengePromptSuggestionFindUniqueArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallengePromptSuggestion findUniqueOrThrow
   */
  export type DailyChallengePromptSuggestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengePromptSuggestion to fetch.
     */
    where: DailyChallengePromptSuggestionWhereUniqueInput
  }


  /**
   * DailyChallengePromptSuggestion base type for findFirst actions
   */
  export type DailyChallengePromptSuggestionFindFirstArgsBase<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengePromptSuggestion to fetch.
     */
    where?: DailyChallengePromptSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengePromptSuggestions to fetch.
     */
    orderBy?: Enumerable<DailyChallengePromptSuggestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallengePromptSuggestions.
     */
    cursor?: DailyChallengePromptSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengePromptSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengePromptSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallengePromptSuggestions.
     */
    distinct?: Enumerable<DailyChallengePromptSuggestionScalarFieldEnum>
  }

  /**
   * DailyChallengePromptSuggestion findFirst
   */
  export interface DailyChallengePromptSuggestionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends DailyChallengePromptSuggestionFindFirstArgsBase<ExtArgs> {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * DailyChallengePromptSuggestion findFirstOrThrow
   */
  export type DailyChallengePromptSuggestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengePromptSuggestion to fetch.
     */
    where?: DailyChallengePromptSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengePromptSuggestions to fetch.
     */
    orderBy?: Enumerable<DailyChallengePromptSuggestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyChallengePromptSuggestions.
     */
    cursor?: DailyChallengePromptSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengePromptSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengePromptSuggestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyChallengePromptSuggestions.
     */
    distinct?: Enumerable<DailyChallengePromptSuggestionScalarFieldEnum>
  }


  /**
   * DailyChallengePromptSuggestion findMany
   */
  export type DailyChallengePromptSuggestionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * Filter, which DailyChallengePromptSuggestions to fetch.
     */
    where?: DailyChallengePromptSuggestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyChallengePromptSuggestions to fetch.
     */
    orderBy?: Enumerable<DailyChallengePromptSuggestionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyChallengePromptSuggestions.
     */
    cursor?: DailyChallengePromptSuggestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyChallengePromptSuggestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyChallengePromptSuggestions.
     */
    skip?: number
    distinct?: Enumerable<DailyChallengePromptSuggestionScalarFieldEnum>
  }


  /**
   * DailyChallengePromptSuggestion create
   */
  export type DailyChallengePromptSuggestionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyChallengePromptSuggestion.
     */
    data: XOR<DailyChallengePromptSuggestionCreateInput, DailyChallengePromptSuggestionUncheckedCreateInput>
  }


  /**
   * DailyChallengePromptSuggestion createMany
   */
  export type DailyChallengePromptSuggestionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyChallengePromptSuggestions.
     */
    data: Enumerable<DailyChallengePromptSuggestionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * DailyChallengePromptSuggestion update
   */
  export type DailyChallengePromptSuggestionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyChallengePromptSuggestion.
     */
    data: XOR<DailyChallengePromptSuggestionUpdateInput, DailyChallengePromptSuggestionUncheckedUpdateInput>
    /**
     * Choose, which DailyChallengePromptSuggestion to update.
     */
    where: DailyChallengePromptSuggestionWhereUniqueInput
  }


  /**
   * DailyChallengePromptSuggestion updateMany
   */
  export type DailyChallengePromptSuggestionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyChallengePromptSuggestions.
     */
    data: XOR<DailyChallengePromptSuggestionUpdateManyMutationInput, DailyChallengePromptSuggestionUncheckedUpdateManyInput>
    /**
     * Filter which DailyChallengePromptSuggestions to update
     */
    where?: DailyChallengePromptSuggestionWhereInput
  }


  /**
   * DailyChallengePromptSuggestion upsert
   */
  export type DailyChallengePromptSuggestionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyChallengePromptSuggestion to update in case it exists.
     */
    where: DailyChallengePromptSuggestionWhereUniqueInput
    /**
     * In case the DailyChallengePromptSuggestion found by the `where` argument doesn't exist, create a new DailyChallengePromptSuggestion with this data.
     */
    create: XOR<DailyChallengePromptSuggestionCreateInput, DailyChallengePromptSuggestionUncheckedCreateInput>
    /**
     * In case the DailyChallengePromptSuggestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyChallengePromptSuggestionUpdateInput, DailyChallengePromptSuggestionUncheckedUpdateInput>
  }


  /**
   * DailyChallengePromptSuggestion delete
   */
  export type DailyChallengePromptSuggestionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
    /**
     * Filter which DailyChallengePromptSuggestion to delete.
     */
    where: DailyChallengePromptSuggestionWhereUniqueInput
  }


  /**
   * DailyChallengePromptSuggestion deleteMany
   */
  export type DailyChallengePromptSuggestionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyChallengePromptSuggestions to delete
     */
    where?: DailyChallengePromptSuggestionWhereInput
  }


  /**
   * DailyChallengePromptSuggestion without action
   */
  export type DailyChallengePromptSuggestionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyChallengePromptSuggestion
     */
    select?: DailyChallengePromptSuggestionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DailyChallengePromptSuggestionInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    userID: 'userID',
    username: 'username',
    appDrawerNoteIDs: 'appDrawerNoteIDs',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    longestStreak: 'longestStreak',
    bio: 'bio',
    city: 'city',
    country: 'country',
    website: 'website',
    twitter: 'twitter',
    instagram: 'instagram',
    createdAt: 'createdAt',
    openAIAPICalls: 'openAIAPICalls'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FollowsScalarFieldEnum: {
    followerID: 'followerID',
    followingID: 'followingID'
  };

  export type FollowsScalarFieldEnum = (typeof FollowsScalarFieldEnum)[keyof typeof FollowsScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    noteID: 'noteID',
    title: 'title',
    content: 'content',
    icon: 'icon',
    updatedAt: 'updatedAt',
    documentID: 'documentID',
    personal: 'personal'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const DocumentVersionScalarFieldEnum: {
    documentVersionID: 'documentVersionID',
    content: 'content',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt',
    documentID: 'documentID',
    versionName: 'versionName',
    wordCount: 'wordCount'
  };

  export type DocumentVersionScalarFieldEnum = (typeof DocumentVersionScalarFieldEnum)[keyof typeof DocumentVersionScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    documentID: 'documentID',
    title: 'title',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const UserEnhancedDocumentPermissionsScalarFieldEnum: {
    userID: 'userID',
    enhancedDocumentID: 'enhancedDocumentID',
    role: 'role'
  };

  export type UserEnhancedDocumentPermissionsScalarFieldEnum = (typeof UserEnhancedDocumentPermissionsScalarFieldEnum)[keyof typeof UserEnhancedDocumentPermissionsScalarFieldEnum]


  export const EnhancedDocumentScalarFieldEnum: {
    enhancedDocumentID: 'enhancedDocumentID',
    notesContent: 'notesContent',
    embeddingsByNodeID: 'embeddingsByNodeID',
    title: 'title',
    updatedAt: 'updatedAt',
    draftContent: 'draftContent',
    draftCollapsed: 'draftCollapsed',
    ideas: 'ideas'
  };

  export type EnhancedDocumentScalarFieldEnum = (typeof EnhancedDocumentScalarFieldEnum)[keyof typeof EnhancedDocumentScalarFieldEnum]


  export const ThreadAttributesScalarFieldEnum: {
    threadID: 'threadID',
    userID: 'userID',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archivedAt: 'archivedAt',
    enhancedDocumentID: 'enhancedDocumentID',
    sectionData: 'sectionData'
  };

  export type ThreadAttributesScalarFieldEnum = (typeof ThreadAttributesScalarFieldEnum)[keyof typeof ThreadAttributesScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    chatMessageID: 'chatMessageID',
    content: 'content',
    author: 'author',
    createdAt: 'createdAt',
    threadID: 'threadID'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const PublishedDocumentScalarFieldEnum: {
    publishedDocumentID: 'publishedDocumentID',
    documentID: 'documentID',
    content: 'content',
    url: 'url',
    userID: 'userID',
    publishedAt: 'publishedAt',
    updatedAt: 'updatedAt',
    title: 'title',
    subtitle: 'subtitle'
  };

  export type PublishedDocumentScalarFieldEnum = (typeof PublishedDocumentScalarFieldEnum)[keyof typeof PublishedDocumentScalarFieldEnum]


  export const ScratchpadEntryScalarFieldEnum: {
    scratchpadEntryID: 'scratchpadEntryID',
    content: 'content',
    date: 'date',
    userID: 'userID'
  };

  export type ScratchpadEntryScalarFieldEnum = (typeof ScratchpadEntryScalarFieldEnum)[keyof typeof ScratchpadEntryScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    commentID: 'commentID',
    commentData: 'commentData',
    authorID: 'authorID',
    documentVersionID: 'documentVersionID',
    updatedAt: 'updatedAt',
    private: 'private',
    resolved: 'resolved',
    selectedText: 'selectedText'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const UserDocumentPermissionScalarFieldEnum: {
    userDocumentPermissionID: 'userDocumentPermissionID',
    userID: 'userID',
    documentVersionID: 'documentVersionID',
    role: 'role',
    documentID: 'documentID'
  };

  export type UserDocumentPermissionScalarFieldEnum = (typeof UserDocumentPermissionScalarFieldEnum)[keyof typeof UserDocumentPermissionScalarFieldEnum]


  export const UserNotePermissionScalarFieldEnum: {
    userNotePermissionID: 'userNotePermissionID',
    userID: 'userID',
    role: 'role',
    noteID: 'noteID'
  };

  export type UserNotePermissionScalarFieldEnum = (typeof UserNotePermissionScalarFieldEnum)[keyof typeof UserNotePermissionScalarFieldEnum]


  export const UserDocumentAttributesScalarFieldEnum: {
    documentID: 'documentID',
    userID: 'userID',
    lastOpenedDocumentVersionID: 'lastOpenedDocumentVersionID'
  };

  export type UserDocumentAttributesScalarFieldEnum = (typeof UserDocumentAttributesScalarFieldEnum)[keyof typeof UserDocumentAttributesScalarFieldEnum]


  export const DailyStatUnitScalarFieldEnum: {
    dailyStatUnitID: 'dailyStatUnitID',
    userID: 'userID',
    documentVersionID: 'documentVersionID',
    documentID: 'documentID',
    dailyChallengeResponseID: 'dailyChallengeResponseID',
    date: 'date',
    timeSpentSeconds: 'timeSpentSeconds',
    wordsAdded: 'wordsAdded',
    wordsRemoved: 'wordsRemoved'
  };

  export type DailyStatUnitScalarFieldEnum = (typeof DailyStatUnitScalarFieldEnum)[keyof typeof DailyStatUnitScalarFieldEnum]


  export const WritingSessionScalarFieldEnum: {
    writingSessionID: 'writingSessionID',
    userID: 'userID',
    segmentTime: 'segmentTime',
    wordsAdded: 'wordsAdded',
    wordsRemoved: 'wordsRemoved',
    timeSpentSeconds: 'timeSpentSeconds',
    startDateTime: 'startDateTime',
    title: 'title',
    documentID: 'documentID',
    inProgress: 'inProgress',
    updatedAt: 'updatedAt'
  };

  export type WritingSessionScalarFieldEnum = (typeof WritingSessionScalarFieldEnum)[keyof typeof WritingSessionScalarFieldEnum]


  export const DailyChallengeScalarFieldEnum: {
    prompt: 'prompt',
    date: 'date',
    id: 'id'
  };

  export type DailyChallengeScalarFieldEnum = (typeof DailyChallengeScalarFieldEnum)[keyof typeof DailyChallengeScalarFieldEnum]


  export const DailyChallengeResponseLikesScalarFieldEnum: {
    userID: 'userID',
    dailyChallengeResponseID: 'dailyChallengeResponseID',
    likeID: 'likeID'
  };

  export type DailyChallengeResponseLikesScalarFieldEnum = (typeof DailyChallengeResponseLikesScalarFieldEnum)[keyof typeof DailyChallengeResponseLikesScalarFieldEnum]


  export const DailyChallengeResponseScalarFieldEnum: {
    userID: 'userID',
    dailyChallengeID: 'dailyChallengeID',
    dailyChallengeResponseID: 'dailyChallengeResponseID',
    content: 'content',
    postedOn: 'postedOn',
    wordCount: 'wordCount',
    completedOnTime: 'completedOnTime'
  };

  export type DailyChallengeResponseScalarFieldEnum = (typeof DailyChallengeResponseScalarFieldEnum)[keyof typeof DailyChallengeResponseScalarFieldEnum]


  export const DailyChallengePromptSuggestionScalarFieldEnum: {
    promptSuggestionID: 'promptSuggestionID',
    prompt: 'prompt',
    userID: 'userID',
    createdAt: 'createdAt',
    usedOn: 'usedOn'
  };

  export type DailyChallengePromptSuggestionScalarFieldEnum = (typeof DailyChallengePromptSuggestionScalarFieldEnum)[keyof typeof DailyChallengePromptSuggestionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    userID?: StringFilter | string
    username?: StringNullableFilter | string | null
    appDrawerNoteIDs?: StringNullableListFilter
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    email?: StringFilter | string
    longestStreak?: IntFilter | number
    bio?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    website?: StringNullableFilter | string | null
    twitter?: StringNullableFilter | string | null
    instagram?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    openAIAPICalls?: IntFilter | number
    comments?: CommentListRelationFilter
    userDocumentPermissions?: UserDocumentPermissionListRelationFilter
    userNotePermission?: UserNotePermissionListRelationFilter
    statUnit?: DailyStatUnitListRelationFilter
    scratchpadEntry?: ScratchpadEntryListRelationFilter
    userDocumentAttributes?: UserDocumentAttributesListRelationFilter
    dailyChallengeResponse?: DailyChallengeResponseListRelationFilter
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesListRelationFilter
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionListRelationFilter
    followedBy?: FollowsListRelationFilter
    following?: FollowsListRelationFilter
    PublishedDocument?: PublishedDocumentListRelationFilter
    publishedDocumentLikes?: PublishedDocumentListRelationFilter
    writingSessions?: WritingSessionListRelationFilter
    writingSessionLikes?: WritingSessionListRelationFilter
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsListRelationFilter
    threadAttributes?: ThreadAttributesListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    userID?: SortOrder
    username?: SortOrderInput | SortOrder
    appDrawerNoteIDs?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    longestStreak?: SortOrder
    bio?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    openAIAPICalls?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    userDocumentPermissions?: UserDocumentPermissionOrderByRelationAggregateInput
    userNotePermission?: UserNotePermissionOrderByRelationAggregateInput
    statUnit?: DailyStatUnitOrderByRelationAggregateInput
    scratchpadEntry?: ScratchpadEntryOrderByRelationAggregateInput
    userDocumentAttributes?: UserDocumentAttributesOrderByRelationAggregateInput
    dailyChallengeResponse?: DailyChallengeResponseOrderByRelationAggregateInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesOrderByRelationAggregateInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionOrderByRelationAggregateInput
    followedBy?: FollowsOrderByRelationAggregateInput
    following?: FollowsOrderByRelationAggregateInput
    PublishedDocument?: PublishedDocumentOrderByRelationAggregateInput
    publishedDocumentLikes?: PublishedDocumentOrderByRelationAggregateInput
    writingSessions?: WritingSessionOrderByRelationAggregateInput
    writingSessionLikes?: WritingSessionOrderByRelationAggregateInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsOrderByRelationAggregateInput
    threadAttributes?: ThreadAttributesOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    userID?: string
    username?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    userID?: SortOrder
    username?: SortOrderInput | SortOrder
    appDrawerNoteIDs?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    longestStreak?: SortOrder
    bio?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    twitter?: SortOrderInput | SortOrder
    instagram?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    openAIAPICalls?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    userID?: StringWithAggregatesFilter | string
    username?: StringNullableWithAggregatesFilter | string | null
    appDrawerNoteIDs?: StringNullableListFilter
    firstName?: StringNullableWithAggregatesFilter | string | null
    lastName?: StringNullableWithAggregatesFilter | string | null
    email?: StringWithAggregatesFilter | string
    longestStreak?: IntWithAggregatesFilter | number
    bio?: StringNullableWithAggregatesFilter | string | null
    city?: StringNullableWithAggregatesFilter | string | null
    country?: StringNullableWithAggregatesFilter | string | null
    website?: StringNullableWithAggregatesFilter | string | null
    twitter?: StringNullableWithAggregatesFilter | string | null
    instagram?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    openAIAPICalls?: IntWithAggregatesFilter | number
  }

  export type FollowsWhereInput = {
    AND?: Enumerable<FollowsWhereInput>
    OR?: Enumerable<FollowsWhereInput>
    NOT?: Enumerable<FollowsWhereInput>
    followerID?: StringFilter | string
    followingID?: StringFilter | string
    follower?: XOR<UserRelationFilter, UserWhereInput>
    following?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FollowsOrderByWithRelationInput = {
    followerID?: SortOrder
    followingID?: SortOrder
    follower?: UserOrderByWithRelationInput
    following?: UserOrderByWithRelationInput
  }

  export type FollowsWhereUniqueInput = {
    followerID_followingID?: FollowsFollowerIDFollowingIDCompoundUniqueInput
  }

  export type FollowsOrderByWithAggregationInput = {
    followerID?: SortOrder
    followingID?: SortOrder
    _count?: FollowsCountOrderByAggregateInput
    _max?: FollowsMaxOrderByAggregateInput
    _min?: FollowsMinOrderByAggregateInput
  }

  export type FollowsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FollowsScalarWhereWithAggregatesInput>
    OR?: Enumerable<FollowsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FollowsScalarWhereWithAggregatesInput>
    followerID?: StringWithAggregatesFilter | string
    followingID?: StringWithAggregatesFilter | string
  }

  export type NoteWhereInput = {
    AND?: Enumerable<NoteWhereInput>
    OR?: Enumerable<NoteWhereInput>
    NOT?: Enumerable<NoteWhereInput>
    noteID?: StringFilter | string
    title?: StringNullableFilter | string | null
    content?: JsonNullableFilter
    icon?: StringNullableFilter | string | null
    updatedAt?: DateTimeFilter | Date | string
    documentID?: StringFilter | string
    personal?: BoolFilter | boolean
    userNotePermissions?: UserNotePermissionListRelationFilter
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
  }

  export type NoteOrderByWithRelationInput = {
    noteID?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    documentID?: SortOrder
    personal?: SortOrder
    userNotePermissions?: UserNotePermissionOrderByRelationAggregateInput
    document?: DocumentOrderByWithRelationInput
  }

  export type NoteWhereUniqueInput = {
    noteID?: string
  }

  export type NoteOrderByWithAggregationInput = {
    noteID?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    documentID?: SortOrder
    personal?: SortOrder
    _count?: NoteCountOrderByAggregateInput
    _max?: NoteMaxOrderByAggregateInput
    _min?: NoteMinOrderByAggregateInput
  }

  export type NoteScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NoteScalarWhereWithAggregatesInput>
    OR?: Enumerable<NoteScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NoteScalarWhereWithAggregatesInput>
    noteID?: StringWithAggregatesFilter | string
    title?: StringNullableWithAggregatesFilter | string | null
    content?: JsonNullableWithAggregatesFilter
    icon?: StringNullableWithAggregatesFilter | string | null
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    documentID?: StringWithAggregatesFilter | string
    personal?: BoolWithAggregatesFilter | boolean
  }

  export type DocumentVersionWhereInput = {
    AND?: Enumerable<DocumentVersionWhereInput>
    OR?: Enumerable<DocumentVersionWhereInput>
    NOT?: Enumerable<DocumentVersionWhereInput>
    documentVersionID?: StringFilter | string
    content?: JsonNullableFilter
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    documentID?: StringFilter | string
    versionName?: StringFilter | string
    wordCount?: IntFilter | number
    comments?: CommentListRelationFilter
    userDocumentPermissions?: UserDocumentPermissionListRelationFilter
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    statUnit?: DailyStatUnitListRelationFilter
    userDocumentAttributes?: UserDocumentAttributesListRelationFilter
  }

  export type DocumentVersionOrderByWithRelationInput = {
    documentVersionID?: SortOrder
    content?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    documentID?: SortOrder
    versionName?: SortOrder
    wordCount?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    userDocumentPermissions?: UserDocumentPermissionOrderByRelationAggregateInput
    document?: DocumentOrderByWithRelationInput
    statUnit?: DailyStatUnitOrderByRelationAggregateInput
    userDocumentAttributes?: UserDocumentAttributesOrderByRelationAggregateInput
  }

  export type DocumentVersionWhereUniqueInput = {
    documentVersionID?: string
  }

  export type DocumentVersionOrderByWithAggregationInput = {
    documentVersionID?: SortOrder
    content?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    documentID?: SortOrder
    versionName?: SortOrder
    wordCount?: SortOrder
    _count?: DocumentVersionCountOrderByAggregateInput
    _avg?: DocumentVersionAvgOrderByAggregateInput
    _max?: DocumentVersionMaxOrderByAggregateInput
    _min?: DocumentVersionMinOrderByAggregateInput
    _sum?: DocumentVersionSumOrderByAggregateInput
  }

  export type DocumentVersionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentVersionScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentVersionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentVersionScalarWhereWithAggregatesInput>
    documentVersionID?: StringWithAggregatesFilter | string
    content?: JsonNullableWithAggregatesFilter
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    documentID?: StringWithAggregatesFilter | string
    versionName?: StringWithAggregatesFilter | string
    wordCount?: IntWithAggregatesFilter | number
  }

  export type DocumentWhereInput = {
    AND?: Enumerable<DocumentWhereInput>
    OR?: Enumerable<DocumentWhereInput>
    NOT?: Enumerable<DocumentWhereInput>
    documentID?: StringFilter | string
    title?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    documentVersions?: DocumentVersionListRelationFilter
    userDocumentPermissions?: UserDocumentPermissionListRelationFilter
    notes?: NoteListRelationFilter
    statUnit?: DailyStatUnitListRelationFilter
    userDocumentAttributes?: UserDocumentAttributesListRelationFilter
    PublishedDocument?: PublishedDocumentListRelationFilter
    WritingSession?: WritingSessionListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    documentID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    documentVersions?: DocumentVersionOrderByRelationAggregateInput
    userDocumentPermissions?: UserDocumentPermissionOrderByRelationAggregateInput
    notes?: NoteOrderByRelationAggregateInput
    statUnit?: DailyStatUnitOrderByRelationAggregateInput
    userDocumentAttributes?: UserDocumentAttributesOrderByRelationAggregateInput
    PublishedDocument?: PublishedDocumentOrderByRelationAggregateInput
    WritingSession?: WritingSessionOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = {
    documentID?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    documentID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DocumentScalarWhereWithAggregatesInput>
    documentID?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserEnhancedDocumentPermissionsWhereInput = {
    AND?: Enumerable<UserEnhancedDocumentPermissionsWhereInput>
    OR?: Enumerable<UserEnhancedDocumentPermissionsWhereInput>
    NOT?: Enumerable<UserEnhancedDocumentPermissionsWhereInput>
    userID?: StringFilter | string
    enhancedDocumentID?: StringFilter | string
    role?: EnumEnhancedDocumentRoleFilter | EnhancedDocumentRole
    user?: XOR<UserRelationFilter, UserWhereInput>
    enhancedDocument?: XOR<EnhancedDocumentRelationFilter, EnhancedDocumentWhereInput>
  }

  export type UserEnhancedDocumentPermissionsOrderByWithRelationInput = {
    userID?: SortOrder
    enhancedDocumentID?: SortOrder
    role?: SortOrder
    user?: UserOrderByWithRelationInput
    enhancedDocument?: EnhancedDocumentOrderByWithRelationInput
  }

  export type UserEnhancedDocumentPermissionsWhereUniqueInput = {
    userID_enhancedDocumentID?: UserEnhancedDocumentPermissionsUserIDEnhancedDocumentIDCompoundUniqueInput
  }

  export type UserEnhancedDocumentPermissionsOrderByWithAggregationInput = {
    userID?: SortOrder
    enhancedDocumentID?: SortOrder
    role?: SortOrder
    _count?: UserEnhancedDocumentPermissionsCountOrderByAggregateInput
    _max?: UserEnhancedDocumentPermissionsMaxOrderByAggregateInput
    _min?: UserEnhancedDocumentPermissionsMinOrderByAggregateInput
  }

  export type UserEnhancedDocumentPermissionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereWithAggregatesInput>
    userID?: StringWithAggregatesFilter | string
    enhancedDocumentID?: StringWithAggregatesFilter | string
    role?: EnumEnhancedDocumentRoleWithAggregatesFilter | EnhancedDocumentRole
  }

  export type EnhancedDocumentWhereInput = {
    AND?: Enumerable<EnhancedDocumentWhereInput>
    OR?: Enumerable<EnhancedDocumentWhereInput>
    NOT?: Enumerable<EnhancedDocumentWhereInput>
    enhancedDocumentID?: StringFilter | string
    notesContent?: JsonFilter
    embeddingsByNodeID?: JsonNullableFilter
    title?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    draftContent?: JsonNullableFilter
    draftCollapsed?: BoolFilter | boolean
    ideas?: StringNullableListFilter
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsListRelationFilter
    threadAttributes?: ThreadAttributesListRelationFilter
  }

  export type EnhancedDocumentOrderByWithRelationInput = {
    enhancedDocumentID?: SortOrder
    notesContent?: SortOrder
    embeddingsByNodeID?: SortOrderInput | SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    draftContent?: SortOrderInput | SortOrder
    draftCollapsed?: SortOrder
    ideas?: SortOrder
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsOrderByRelationAggregateInput
    threadAttributes?: ThreadAttributesOrderByRelationAggregateInput
  }

  export type EnhancedDocumentWhereUniqueInput = {
    enhancedDocumentID?: string
  }

  export type EnhancedDocumentOrderByWithAggregationInput = {
    enhancedDocumentID?: SortOrder
    notesContent?: SortOrder
    embeddingsByNodeID?: SortOrderInput | SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    draftContent?: SortOrderInput | SortOrder
    draftCollapsed?: SortOrder
    ideas?: SortOrder
    _count?: EnhancedDocumentCountOrderByAggregateInput
    _max?: EnhancedDocumentMaxOrderByAggregateInput
    _min?: EnhancedDocumentMinOrderByAggregateInput
  }

  export type EnhancedDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EnhancedDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<EnhancedDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EnhancedDocumentScalarWhereWithAggregatesInput>
    enhancedDocumentID?: StringWithAggregatesFilter | string
    notesContent?: JsonWithAggregatesFilter
    embeddingsByNodeID?: JsonNullableWithAggregatesFilter
    title?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    draftContent?: JsonNullableWithAggregatesFilter
    draftCollapsed?: BoolWithAggregatesFilter | boolean
    ideas?: StringNullableListFilter
  }

  export type ThreadAttributesWhereInput = {
    AND?: Enumerable<ThreadAttributesWhereInput>
    OR?: Enumerable<ThreadAttributesWhereInput>
    NOT?: Enumerable<ThreadAttributesWhereInput>
    threadID?: StringFilter | string
    userID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    archivedAt?: DateTimeNullableFilter | Date | string | null
    enhancedDocumentID?: StringFilter | string
    sectionData?: JsonNullableFilter
    user?: XOR<UserRelationFilter, UserWhereInput>
    document?: XOR<EnhancedDocumentRelationFilter, EnhancedDocumentWhereInput>
    chatMessage?: ChatMessageListRelationFilter
  }

  export type ThreadAttributesOrderByWithRelationInput = {
    threadID?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    enhancedDocumentID?: SortOrder
    sectionData?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    document?: EnhancedDocumentOrderByWithRelationInput
    chatMessage?: ChatMessageOrderByRelationAggregateInput
  }

  export type ThreadAttributesWhereUniqueInput = {
    threadID?: string
  }

  export type ThreadAttributesOrderByWithAggregationInput = {
    threadID?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    enhancedDocumentID?: SortOrder
    sectionData?: SortOrderInput | SortOrder
    _count?: ThreadAttributesCountOrderByAggregateInput
    _max?: ThreadAttributesMaxOrderByAggregateInput
    _min?: ThreadAttributesMinOrderByAggregateInput
  }

  export type ThreadAttributesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ThreadAttributesScalarWhereWithAggregatesInput>
    OR?: Enumerable<ThreadAttributesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ThreadAttributesScalarWhereWithAggregatesInput>
    threadID?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    archivedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    enhancedDocumentID?: StringWithAggregatesFilter | string
    sectionData?: JsonNullableWithAggregatesFilter
  }

  export type ChatMessageWhereInput = {
    AND?: Enumerable<ChatMessageWhereInput>
    OR?: Enumerable<ChatMessageWhereInput>
    NOT?: Enumerable<ChatMessageWhereInput>
    chatMessageID?: StringFilter | string
    content?: StringFilter | string
    author?: EnumChatMessageAuthorFilter | ChatMessageAuthor
    createdAt?: DateTimeFilter | Date | string
    threadID?: StringFilter | string
    thread?: XOR<ThreadAttributesRelationFilter, ThreadAttributesWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    chatMessageID?: SortOrder
    content?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    threadID?: SortOrder
    thread?: ThreadAttributesOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = {
    chatMessageID?: string
  }

  export type ChatMessageOrderByWithAggregationInput = {
    chatMessageID?: SortOrder
    content?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    threadID?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChatMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChatMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChatMessageScalarWhereWithAggregatesInput>
    chatMessageID?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    author?: EnumChatMessageAuthorWithAggregatesFilter | ChatMessageAuthor
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    threadID?: StringWithAggregatesFilter | string
  }

  export type PublishedDocumentWhereInput = {
    AND?: Enumerable<PublishedDocumentWhereInput>
    OR?: Enumerable<PublishedDocumentWhereInput>
    NOT?: Enumerable<PublishedDocumentWhereInput>
    publishedDocumentID?: StringFilter | string
    documentID?: StringFilter | string
    content?: JsonNullableFilter
    url?: StringFilter | string
    userID?: StringFilter | string
    publishedAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    subtitle?: StringNullableFilter | string | null
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    likingUsers?: UserListRelationFilter
  }

  export type PublishedDocumentOrderByWithRelationInput = {
    publishedDocumentID?: SortOrder
    documentID?: SortOrder
    content?: SortOrderInput | SortOrder
    url?: SortOrder
    userID?: SortOrder
    publishedAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    document?: DocumentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    likingUsers?: UserOrderByRelationAggregateInput
  }

  export type PublishedDocumentWhereUniqueInput = {
    publishedDocumentID?: string
    documentID_userID?: PublishedDocumentDocumentIDUserIDCompoundUniqueInput
    userID_url?: PublishedDocumentUserIDUrlCompoundUniqueInput
  }

  export type PublishedDocumentOrderByWithAggregationInput = {
    publishedDocumentID?: SortOrder
    documentID?: SortOrder
    content?: SortOrderInput | SortOrder
    url?: SortOrder
    userID?: SortOrder
    publishedAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    _count?: PublishedDocumentCountOrderByAggregateInput
    _max?: PublishedDocumentMaxOrderByAggregateInput
    _min?: PublishedDocumentMinOrderByAggregateInput
  }

  export type PublishedDocumentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PublishedDocumentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PublishedDocumentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PublishedDocumentScalarWhereWithAggregatesInput>
    publishedDocumentID?: StringWithAggregatesFilter | string
    documentID?: StringWithAggregatesFilter | string
    content?: JsonNullableWithAggregatesFilter
    url?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    publishedAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    subtitle?: StringNullableWithAggregatesFilter | string | null
  }

  export type ScratchpadEntryWhereInput = {
    AND?: Enumerable<ScratchpadEntryWhereInput>
    OR?: Enumerable<ScratchpadEntryWhereInput>
    NOT?: Enumerable<ScratchpadEntryWhereInput>
    scratchpadEntryID?: StringFilter | string
    content?: JsonNullableFilter
    date?: DateTimeFilter | Date | string
    userID?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ScratchpadEntryOrderByWithRelationInput = {
    scratchpadEntryID?: SortOrder
    content?: SortOrderInput | SortOrder
    date?: SortOrder
    userID?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ScratchpadEntryWhereUniqueInput = {
    scratchpadEntryID?: string
  }

  export type ScratchpadEntryOrderByWithAggregationInput = {
    scratchpadEntryID?: SortOrder
    content?: SortOrderInput | SortOrder
    date?: SortOrder
    userID?: SortOrder
    _count?: ScratchpadEntryCountOrderByAggregateInput
    _max?: ScratchpadEntryMaxOrderByAggregateInput
    _min?: ScratchpadEntryMinOrderByAggregateInput
  }

  export type ScratchpadEntryScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ScratchpadEntryScalarWhereWithAggregatesInput>
    OR?: Enumerable<ScratchpadEntryScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ScratchpadEntryScalarWhereWithAggregatesInput>
    scratchpadEntryID?: StringWithAggregatesFilter | string
    content?: JsonNullableWithAggregatesFilter
    date?: DateTimeWithAggregatesFilter | Date | string
    userID?: StringWithAggregatesFilter | string
  }

  export type CommentWhereInput = {
    AND?: Enumerable<CommentWhereInput>
    OR?: Enumerable<CommentWhereInput>
    NOT?: Enumerable<CommentWhereInput>
    commentID?: StringFilter | string
    commentData?: JsonFilter
    authorID?: StringFilter | string
    documentVersionID?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    private?: BoolFilter | boolean
    resolved?: BoolFilter | boolean
    selectedText?: StringFilter | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    documentVersion?: XOR<DocumentVersionRelationFilter, DocumentVersionWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    commentID?: SortOrder
    commentData?: SortOrder
    authorID?: SortOrder
    documentVersionID?: SortOrder
    updatedAt?: SortOrder
    private?: SortOrder
    resolved?: SortOrder
    selectedText?: SortOrder
    author?: UserOrderByWithRelationInput
    documentVersion?: DocumentVersionOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = {
    commentID?: string
  }

  export type CommentOrderByWithAggregationInput = {
    commentID?: SortOrder
    commentData?: SortOrder
    authorID?: SortOrder
    documentVersionID?: SortOrder
    updatedAt?: SortOrder
    private?: SortOrder
    resolved?: SortOrder
    selectedText?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<CommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CommentScalarWhereWithAggregatesInput>
    commentID?: StringWithAggregatesFilter | string
    commentData?: JsonWithAggregatesFilter
    authorID?: StringWithAggregatesFilter | string
    documentVersionID?: StringWithAggregatesFilter | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    private?: BoolWithAggregatesFilter | boolean
    resolved?: BoolWithAggregatesFilter | boolean
    selectedText?: StringWithAggregatesFilter | string
  }

  export type UserDocumentPermissionWhereInput = {
    AND?: Enumerable<UserDocumentPermissionWhereInput>
    OR?: Enumerable<UserDocumentPermissionWhereInput>
    NOT?: Enumerable<UserDocumentPermissionWhereInput>
    userDocumentPermissionID?: StringFilter | string
    userID?: StringFilter | string
    documentVersionID?: StringNullableFilter | string | null
    role?: EnumRoleFilter | Role
    documentID?: StringNullableFilter | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    documentVersion?: XOR<DocumentVersionRelationFilter, DocumentVersionWhereInput> | null
    document?: XOR<DocumentRelationFilter, DocumentWhereInput> | null
  }

  export type UserDocumentPermissionOrderByWithRelationInput = {
    userDocumentPermissionID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrderInput | SortOrder
    role?: SortOrder
    documentID?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    documentVersion?: DocumentVersionOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
  }

  export type UserDocumentPermissionWhereUniqueInput = {
    userDocumentPermissionID?: string
  }

  export type UserDocumentPermissionOrderByWithAggregationInput = {
    userDocumentPermissionID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrderInput | SortOrder
    role?: SortOrder
    documentID?: SortOrderInput | SortOrder
    _count?: UserDocumentPermissionCountOrderByAggregateInput
    _max?: UserDocumentPermissionMaxOrderByAggregateInput
    _min?: UserDocumentPermissionMinOrderByAggregateInput
  }

  export type UserDocumentPermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserDocumentPermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserDocumentPermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserDocumentPermissionScalarWhereWithAggregatesInput>
    userDocumentPermissionID?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    documentVersionID?: StringNullableWithAggregatesFilter | string | null
    role?: EnumRoleWithAggregatesFilter | Role
    documentID?: StringNullableWithAggregatesFilter | string | null
  }

  export type UserNotePermissionWhereInput = {
    AND?: Enumerable<UserNotePermissionWhereInput>
    OR?: Enumerable<UserNotePermissionWhereInput>
    NOT?: Enumerable<UserNotePermissionWhereInput>
    userNotePermissionID?: StringFilter | string
    userID?: StringFilter | string
    role?: EnumNoteRoleFilter | NoteRole
    noteID?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    note?: XOR<NoteRelationFilter, NoteWhereInput>
  }

  export type UserNotePermissionOrderByWithRelationInput = {
    userNotePermissionID?: SortOrder
    userID?: SortOrder
    role?: SortOrder
    noteID?: SortOrder
    user?: UserOrderByWithRelationInput
    note?: NoteOrderByWithRelationInput
  }

  export type UserNotePermissionWhereUniqueInput = {
    userNotePermissionID?: string
  }

  export type UserNotePermissionOrderByWithAggregationInput = {
    userNotePermissionID?: SortOrder
    userID?: SortOrder
    role?: SortOrder
    noteID?: SortOrder
    _count?: UserNotePermissionCountOrderByAggregateInput
    _max?: UserNotePermissionMaxOrderByAggregateInput
    _min?: UserNotePermissionMinOrderByAggregateInput
  }

  export type UserNotePermissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserNotePermissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserNotePermissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserNotePermissionScalarWhereWithAggregatesInput>
    userNotePermissionID?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    role?: EnumNoteRoleWithAggregatesFilter | NoteRole
    noteID?: StringWithAggregatesFilter | string
  }

  export type UserDocumentAttributesWhereInput = {
    AND?: Enumerable<UserDocumentAttributesWhereInput>
    OR?: Enumerable<UserDocumentAttributesWhereInput>
    NOT?: Enumerable<UserDocumentAttributesWhereInput>
    documentID?: StringFilter | string
    userID?: StringFilter | string
    lastOpenedDocumentVersionID?: StringFilter | string
    document?: XOR<DocumentRelationFilter, DocumentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    lastOpenedDocumentVersion?: XOR<DocumentVersionRelationFilter, DocumentVersionWhereInput>
  }

  export type UserDocumentAttributesOrderByWithRelationInput = {
    documentID?: SortOrder
    userID?: SortOrder
    lastOpenedDocumentVersionID?: SortOrder
    document?: DocumentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    lastOpenedDocumentVersion?: DocumentVersionOrderByWithRelationInput
  }

  export type UserDocumentAttributesWhereUniqueInput = {
    documentID_userID?: UserDocumentAttributesDocumentIDUserIDCompoundUniqueInput
  }

  export type UserDocumentAttributesOrderByWithAggregationInput = {
    documentID?: SortOrder
    userID?: SortOrder
    lastOpenedDocumentVersionID?: SortOrder
    _count?: UserDocumentAttributesCountOrderByAggregateInput
    _max?: UserDocumentAttributesMaxOrderByAggregateInput
    _min?: UserDocumentAttributesMinOrderByAggregateInput
  }

  export type UserDocumentAttributesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserDocumentAttributesScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserDocumentAttributesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserDocumentAttributesScalarWhereWithAggregatesInput>
    documentID?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    lastOpenedDocumentVersionID?: StringWithAggregatesFilter | string
  }

  export type DailyStatUnitWhereInput = {
    AND?: Enumerable<DailyStatUnitWhereInput>
    OR?: Enumerable<DailyStatUnitWhereInput>
    NOT?: Enumerable<DailyStatUnitWhereInput>
    dailyStatUnitID?: StringFilter | string
    userID?: StringFilter | string
    documentVersionID?: StringNullableFilter | string | null
    documentID?: StringNullableFilter | string | null
    dailyChallengeResponseID?: StringNullableFilter | string | null
    date?: DateTimeFilter | Date | string
    timeSpentSeconds?: IntFilter | number
    wordsAdded?: IntFilter | number
    wordsRemoved?: IntFilter | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    documentVersion?: XOR<DocumentVersionRelationFilter, DocumentVersionWhereInput> | null
    document?: XOR<DocumentRelationFilter, DocumentWhereInput> | null
    dailyChallengeResponse?: XOR<DailyChallengeResponseRelationFilter, DailyChallengeResponseWhereInput> | null
  }

  export type DailyStatUnitOrderByWithRelationInput = {
    dailyStatUnitID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrderInput | SortOrder
    documentID?: SortOrderInput | SortOrder
    dailyChallengeResponseID?: SortOrderInput | SortOrder
    date?: SortOrder
    timeSpentSeconds?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    user?: UserOrderByWithRelationInput
    documentVersion?: DocumentVersionOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
    dailyChallengeResponse?: DailyChallengeResponseOrderByWithRelationInput
  }

  export type DailyStatUnitWhereUniqueInput = {
    dailyStatUnitID?: string
    userID_date_documentVersionID?: DailyStatUnitUserIDDateDocumentVersionIDCompoundUniqueInput
    date_dailyChallengeResponseID?: DailyStatUnitDateDailyChallengeResponseIDCompoundUniqueInput
  }

  export type DailyStatUnitOrderByWithAggregationInput = {
    dailyStatUnitID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrderInput | SortOrder
    documentID?: SortOrderInput | SortOrder
    dailyChallengeResponseID?: SortOrderInput | SortOrder
    date?: SortOrder
    timeSpentSeconds?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    _count?: DailyStatUnitCountOrderByAggregateInput
    _avg?: DailyStatUnitAvgOrderByAggregateInput
    _max?: DailyStatUnitMaxOrderByAggregateInput
    _min?: DailyStatUnitMinOrderByAggregateInput
    _sum?: DailyStatUnitSumOrderByAggregateInput
  }

  export type DailyStatUnitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyStatUnitScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyStatUnitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyStatUnitScalarWhereWithAggregatesInput>
    dailyStatUnitID?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    documentVersionID?: StringNullableWithAggregatesFilter | string | null
    documentID?: StringNullableWithAggregatesFilter | string | null
    dailyChallengeResponseID?: StringNullableWithAggregatesFilter | string | null
    date?: DateTimeWithAggregatesFilter | Date | string
    timeSpentSeconds?: IntWithAggregatesFilter | number
    wordsAdded?: IntWithAggregatesFilter | number
    wordsRemoved?: IntWithAggregatesFilter | number
  }

  export type WritingSessionWhereInput = {
    AND?: Enumerable<WritingSessionWhereInput>
    OR?: Enumerable<WritingSessionWhereInput>
    NOT?: Enumerable<WritingSessionWhereInput>
    writingSessionID?: StringFilter | string
    userID?: StringFilter | string
    segmentTime?: IntNullableListFilter
    wordsAdded?: IntFilter | number
    wordsRemoved?: IntFilter | number
    timeSpentSeconds?: IntFilter | number
    startDateTime?: DateTimeFilter | Date | string
    title?: StringFilter | string
    documentID?: StringNullableFilter | string | null
    inProgress?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    document?: XOR<DocumentRelationFilter, DocumentWhereInput> | null
    likes?: UserListRelationFilter
  }

  export type WritingSessionOrderByWithRelationInput = {
    writingSessionID?: SortOrder
    userID?: SortOrder
    segmentTime?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    timeSpentSeconds?: SortOrder
    startDateTime?: SortOrder
    title?: SortOrder
    documentID?: SortOrderInput | SortOrder
    inProgress?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
    likes?: UserOrderByRelationAggregateInput
  }

  export type WritingSessionWhereUniqueInput = {
    writingSessionID?: string
  }

  export type WritingSessionOrderByWithAggregationInput = {
    writingSessionID?: SortOrder
    userID?: SortOrder
    segmentTime?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    timeSpentSeconds?: SortOrder
    startDateTime?: SortOrder
    title?: SortOrder
    documentID?: SortOrderInput | SortOrder
    inProgress?: SortOrder
    updatedAt?: SortOrder
    _count?: WritingSessionCountOrderByAggregateInput
    _avg?: WritingSessionAvgOrderByAggregateInput
    _max?: WritingSessionMaxOrderByAggregateInput
    _min?: WritingSessionMinOrderByAggregateInput
    _sum?: WritingSessionSumOrderByAggregateInput
  }

  export type WritingSessionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WritingSessionScalarWhereWithAggregatesInput>
    OR?: Enumerable<WritingSessionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WritingSessionScalarWhereWithAggregatesInput>
    writingSessionID?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    segmentTime?: IntNullableListFilter
    wordsAdded?: IntWithAggregatesFilter | number
    wordsRemoved?: IntWithAggregatesFilter | number
    timeSpentSeconds?: IntWithAggregatesFilter | number
    startDateTime?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    documentID?: StringNullableWithAggregatesFilter | string | null
    inProgress?: BoolWithAggregatesFilter | boolean
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DailyChallengeWhereInput = {
    AND?: Enumerable<DailyChallengeWhereInput>
    OR?: Enumerable<DailyChallengeWhereInput>
    NOT?: Enumerable<DailyChallengeWhereInput>
    prompt?: StringFilter | string
    date?: DateTimeFilter | Date | string
    id?: IntFilter | number
    dailyChallengeResponse?: DailyChallengeResponseListRelationFilter
  }

  export type DailyChallengeOrderByWithRelationInput = {
    prompt?: SortOrder
    date?: SortOrder
    id?: SortOrder
    dailyChallengeResponse?: DailyChallengeResponseOrderByRelationAggregateInput
  }

  export type DailyChallengeWhereUniqueInput = {
    date?: Date | string
    id?: number
  }

  export type DailyChallengeOrderByWithAggregationInput = {
    prompt?: SortOrder
    date?: SortOrder
    id?: SortOrder
    _count?: DailyChallengeCountOrderByAggregateInput
    _avg?: DailyChallengeAvgOrderByAggregateInput
    _max?: DailyChallengeMaxOrderByAggregateInput
    _min?: DailyChallengeMinOrderByAggregateInput
    _sum?: DailyChallengeSumOrderByAggregateInput
  }

  export type DailyChallengeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyChallengeScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyChallengeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyChallengeScalarWhereWithAggregatesInput>
    prompt?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    id?: IntWithAggregatesFilter | number
  }

  export type DailyChallengeResponseLikesWhereInput = {
    AND?: Enumerable<DailyChallengeResponseLikesWhereInput>
    OR?: Enumerable<DailyChallengeResponseLikesWhereInput>
    NOT?: Enumerable<DailyChallengeResponseLikesWhereInput>
    userID?: StringFilter | string
    dailyChallengeResponseID?: StringFilter | string
    likeID?: StringFilter | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    dailyChallengeResponse?: XOR<DailyChallengeResponseRelationFilter, DailyChallengeResponseWhereInput>
  }

  export type DailyChallengeResponseLikesOrderByWithRelationInput = {
    userID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    likeID?: SortOrder
    user?: UserOrderByWithRelationInput
    dailyChallengeResponse?: DailyChallengeResponseOrderByWithRelationInput
  }

  export type DailyChallengeResponseLikesWhereUniqueInput = {
    likeID?: string
    userID_dailyChallengeResponseID?: DailyChallengeResponseLikesUserIDDailyChallengeResponseIDCompoundUniqueInput
  }

  export type DailyChallengeResponseLikesOrderByWithAggregationInput = {
    userID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    likeID?: SortOrder
    _count?: DailyChallengeResponseLikesCountOrderByAggregateInput
    _max?: DailyChallengeResponseLikesMaxOrderByAggregateInput
    _min?: DailyChallengeResponseLikesMinOrderByAggregateInput
  }

  export type DailyChallengeResponseLikesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyChallengeResponseLikesScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyChallengeResponseLikesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyChallengeResponseLikesScalarWhereWithAggregatesInput>
    userID?: StringWithAggregatesFilter | string
    dailyChallengeResponseID?: StringWithAggregatesFilter | string
    likeID?: StringWithAggregatesFilter | string
  }

  export type DailyChallengeResponseWhereInput = {
    AND?: Enumerable<DailyChallengeResponseWhereInput>
    OR?: Enumerable<DailyChallengeResponseWhereInput>
    NOT?: Enumerable<DailyChallengeResponseWhereInput>
    userID?: StringNullableFilter | string | null
    dailyChallengeID?: IntFilter | number
    dailyChallengeResponseID?: StringFilter | string
    content?: JsonNullableFilter
    postedOn?: DateTimeNullableFilter | Date | string | null
    wordCount?: IntFilter | number
    completedOnTime?: BoolFilter | boolean
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    likes?: DailyChallengeResponseLikesListRelationFilter
    dailyChallenge?: XOR<DailyChallengeRelationFilter, DailyChallengeWhereInput>
    dailyStatUnit?: DailyStatUnitListRelationFilter
  }

  export type DailyChallengeResponseOrderByWithRelationInput = {
    userID?: SortOrderInput | SortOrder
    dailyChallengeID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    content?: SortOrderInput | SortOrder
    postedOn?: SortOrderInput | SortOrder
    wordCount?: SortOrder
    completedOnTime?: SortOrder
    user?: UserOrderByWithRelationInput
    likes?: DailyChallengeResponseLikesOrderByRelationAggregateInput
    dailyChallenge?: DailyChallengeOrderByWithRelationInput
    dailyStatUnit?: DailyStatUnitOrderByRelationAggregateInput
  }

  export type DailyChallengeResponseWhereUniqueInput = {
    dailyChallengeResponseID?: string
    userID_dailyChallengeID?: DailyChallengeResponseUserIDDailyChallengeIDCompoundUniqueInput
  }

  export type DailyChallengeResponseOrderByWithAggregationInput = {
    userID?: SortOrderInput | SortOrder
    dailyChallengeID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    content?: SortOrderInput | SortOrder
    postedOn?: SortOrderInput | SortOrder
    wordCount?: SortOrder
    completedOnTime?: SortOrder
    _count?: DailyChallengeResponseCountOrderByAggregateInput
    _avg?: DailyChallengeResponseAvgOrderByAggregateInput
    _max?: DailyChallengeResponseMaxOrderByAggregateInput
    _min?: DailyChallengeResponseMinOrderByAggregateInput
    _sum?: DailyChallengeResponseSumOrderByAggregateInput
  }

  export type DailyChallengeResponseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyChallengeResponseScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyChallengeResponseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyChallengeResponseScalarWhereWithAggregatesInput>
    userID?: StringNullableWithAggregatesFilter | string | null
    dailyChallengeID?: IntWithAggregatesFilter | number
    dailyChallengeResponseID?: StringWithAggregatesFilter | string
    content?: JsonNullableWithAggregatesFilter
    postedOn?: DateTimeNullableWithAggregatesFilter | Date | string | null
    wordCount?: IntWithAggregatesFilter | number
    completedOnTime?: BoolWithAggregatesFilter | boolean
  }

  export type DailyChallengePromptSuggestionWhereInput = {
    AND?: Enumerable<DailyChallengePromptSuggestionWhereInput>
    OR?: Enumerable<DailyChallengePromptSuggestionWhereInput>
    NOT?: Enumerable<DailyChallengePromptSuggestionWhereInput>
    promptSuggestionID?: StringFilter | string
    prompt?: StringFilter | string
    userID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    usedOn?: DateTimeNullableFilter | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DailyChallengePromptSuggestionOrderByWithRelationInput = {
    promptSuggestionID?: SortOrder
    prompt?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    usedOn?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyChallengePromptSuggestionWhereUniqueInput = {
    promptSuggestionID?: string
  }

  export type DailyChallengePromptSuggestionOrderByWithAggregationInput = {
    promptSuggestionID?: SortOrder
    prompt?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    usedOn?: SortOrderInput | SortOrder
    _count?: DailyChallengePromptSuggestionCountOrderByAggregateInput
    _max?: DailyChallengePromptSuggestionMaxOrderByAggregateInput
    _min?: DailyChallengePromptSuggestionMinOrderByAggregateInput
  }

  export type DailyChallengePromptSuggestionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DailyChallengePromptSuggestionScalarWhereWithAggregatesInput>
    OR?: Enumerable<DailyChallengePromptSuggestionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DailyChallengePromptSuggestionScalarWhereWithAggregatesInput>
    promptSuggestionID?: StringWithAggregatesFilter | string
    prompt?: StringWithAggregatesFilter | string
    userID?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    usedOn?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type UserCreateInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
  }

  export type UserUpdateManyMutationInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
  }

  export type FollowsCreateInput = {
    follower: UserCreateNestedOneWithoutFollowingInput
    following: UserCreateNestedOneWithoutFollowedByInput
  }

  export type FollowsUncheckedCreateInput = {
    followerID: string
    followingID: string
  }

  export type FollowsUpdateInput = {
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
    following?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type FollowsUncheckedUpdateInput = {
    followerID?: StringFieldUpdateOperationsInput | string
    followingID?: StringFieldUpdateOperationsInput | string
  }

  export type FollowsCreateManyInput = {
    followerID: string
    followingID: string
  }

  export type FollowsUpdateManyMutationInput = {

  }

  export type FollowsUncheckedUpdateManyInput = {
    followerID?: StringFieldUpdateOperationsInput | string
    followingID?: StringFieldUpdateOperationsInput | string
  }

  export type NoteCreateInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    personal?: boolean
    userNotePermissions?: UserNotePermissionCreateNestedManyWithoutNoteInput
    document: DocumentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    documentID: string
    personal?: boolean
    userNotePermissions?: UserNotePermissionUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteUpdateInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: BoolFieldUpdateOperationsInput | boolean
    userNotePermissions?: UserNotePermissionUpdateManyWithoutNoteNestedInput
    document?: DocumentUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    personal?: BoolFieldUpdateOperationsInput | boolean
    userNotePermissions?: UserNotePermissionUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteCreateManyInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    documentID: string
    personal?: boolean
  }

  export type NoteUpdateManyMutationInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NoteUncheckedUpdateManyInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    personal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentVersionCreateInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
    comments?: CommentCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentVersionInput
    document: DocumentCreateNestedOneWithoutDocumentVersionsInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    documentID: string
    versionName: string
    wordCount?: number
    comments?: CommentUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentVersionInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionUpdateInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentVersionNestedInput
    document?: DocumentUpdateOneRequiredWithoutDocumentVersionsNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentVersionNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentVersionCreateManyInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    documentID: string
    versionName: string
    wordCount?: number
  }

  export type DocumentVersionUpdateManyMutationInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentVersionUncheckedUpdateManyInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
  }

  export type DocumentCreateInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentInput
    notes?: NoteCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
    notes?: NoteUncheckedCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentNestedInput
    notes?: NoteUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEnhancedDocumentPermissionsCreateInput = {
    role: EnhancedDocumentRole
    user: UserCreateNestedOneWithoutUserEnhancedDocumentPermissionsInput
    enhancedDocument: EnhancedDocumentCreateNestedOneWithoutUserEnhancedDocumentPermissionsInput
  }

  export type UserEnhancedDocumentPermissionsUncheckedCreateInput = {
    userID: string
    enhancedDocumentID: string
    role: EnhancedDocumentRole
  }

  export type UserEnhancedDocumentPermissionsUpdateInput = {
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
    user?: UserUpdateOneRequiredWithoutUserEnhancedDocumentPermissionsNestedInput
    enhancedDocument?: EnhancedDocumentUpdateOneRequiredWithoutUserEnhancedDocumentPermissionsNestedInput
  }

  export type UserEnhancedDocumentPermissionsUncheckedUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
  }

  export type UserEnhancedDocumentPermissionsCreateManyInput = {
    userID: string
    enhancedDocumentID: string
    role: EnhancedDocumentRole
  }

  export type UserEnhancedDocumentPermissionsUpdateManyMutationInput = {
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
  }

  export type UserEnhancedDocumentPermissionsUncheckedUpdateManyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
  }

  export type EnhancedDocumentCreateInput = {
    enhancedDocumentID?: string
    notesContent: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title: string
    updatedAt?: Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: boolean
    ideas?: EnhancedDocumentCreateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutEnhancedDocumentInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutDocumentInput
  }

  export type EnhancedDocumentUncheckedCreateInput = {
    enhancedDocumentID?: string
    notesContent: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title: string
    updatedAt?: Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: boolean
    ideas?: EnhancedDocumentCreateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutEnhancedDocumentInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type EnhancedDocumentUpdateInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutEnhancedDocumentNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutDocumentNestedInput
  }

  export type EnhancedDocumentUncheckedUpdateInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutEnhancedDocumentNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type EnhancedDocumentCreateManyInput = {
    enhancedDocumentID?: string
    notesContent: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title: string
    updatedAt?: Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: boolean
    ideas?: EnhancedDocumentCreateideasInput | Enumerable<string>
  }

  export type EnhancedDocumentUpdateManyMutationInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
  }

  export type EnhancedDocumentUncheckedUpdateManyInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
  }

  export type ThreadAttributesCreateInput = {
    threadID?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutThreadAttributesInput
    document: EnhancedDocumentCreateNestedOneWithoutThreadAttributesInput
    chatMessage?: ChatMessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadAttributesUncheckedCreateInput = {
    threadID?: string
    userID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    enhancedDocumentID: string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    chatMessage?: ChatMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadAttributesUpdateInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutThreadAttributesNestedInput
    document?: EnhancedDocumentUpdateOneRequiredWithoutThreadAttributesNestedInput
    chatMessage?: ChatMessageUpdateManyWithoutThreadNestedInput
  }

  export type ThreadAttributesUncheckedUpdateInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    chatMessage?: ChatMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadAttributesCreateManyInput = {
    threadID?: string
    userID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    enhancedDocumentID: string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ThreadAttributesUpdateManyMutationInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ThreadAttributesUncheckedUpdateManyInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ChatMessageCreateInput = {
    chatMessageID?: string
    content: string
    author: ChatMessageAuthor
    createdAt?: Date | string
    thread: ThreadAttributesCreateNestedOneWithoutChatMessageInput
  }

  export type ChatMessageUncheckedCreateInput = {
    chatMessageID?: string
    content: string
    author: ChatMessageAuthor
    createdAt?: Date | string
    threadID: string
  }

  export type ChatMessageUpdateInput = {
    chatMessageID?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: EnumChatMessageAuthorFieldUpdateOperationsInput | ChatMessageAuthor
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: ThreadAttributesUpdateOneRequiredWithoutChatMessageNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    chatMessageID?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: EnumChatMessageAuthorFieldUpdateOperationsInput | ChatMessageAuthor
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    threadID?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateManyInput = {
    chatMessageID?: string
    content: string
    author: ChatMessageAuthor
    createdAt?: Date | string
    threadID: string
  }

  export type ChatMessageUpdateManyMutationInput = {
    chatMessageID?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: EnumChatMessageAuthorFieldUpdateOperationsInput | ChatMessageAuthor
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    chatMessageID?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: EnumChatMessageAuthorFieldUpdateOperationsInput | ChatMessageAuthor
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    threadID?: StringFieldUpdateOperationsInput | string
  }

  export type PublishedDocumentCreateInput = {
    publishedDocumentID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
    document: DocumentCreateNestedOneWithoutPublishedDocumentInput
    user: UserCreateNestedOneWithoutPublishedDocumentInput
    likingUsers?: UserCreateNestedManyWithoutPublishedDocumentLikesInput
  }

  export type PublishedDocumentUncheckedCreateInput = {
    publishedDocumentID?: string
    documentID: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    userID: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
    likingUsers?: UserUncheckedCreateNestedManyWithoutPublishedDocumentLikesInput
  }

  export type PublishedDocumentUpdateInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentUpdateOneRequiredWithoutPublishedDocumentNestedInput
    user?: UserUpdateOneRequiredWithoutPublishedDocumentNestedInput
    likingUsers?: UserUpdateManyWithoutPublishedDocumentLikesNestedInput
  }

  export type PublishedDocumentUncheckedUpdateInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    documentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    likingUsers?: UserUncheckedUpdateManyWithoutPublishedDocumentLikesNestedInput
  }

  export type PublishedDocumentCreateManyInput = {
    publishedDocumentID?: string
    documentID: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    userID: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
  }

  export type PublishedDocumentUpdateManyMutationInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublishedDocumentUncheckedUpdateManyInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    documentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScratchpadEntryCreateInput = {
    scratchpadEntryID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    date: Date | string
    user: UserCreateNestedOneWithoutScratchpadEntryInput
  }

  export type ScratchpadEntryUncheckedCreateInput = {
    scratchpadEntryID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    date: Date | string
    userID: string
  }

  export type ScratchpadEntryUpdateInput = {
    scratchpadEntryID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutScratchpadEntryNestedInput
  }

  export type ScratchpadEntryUncheckedUpdateInput = {
    scratchpadEntryID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type ScratchpadEntryCreateManyInput = {
    scratchpadEntryID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    date: Date | string
    userID: string
  }

  export type ScratchpadEntryUpdateManyMutationInput = {
    scratchpadEntryID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScratchpadEntryUncheckedUpdateManyInput = {
    scratchpadEntryID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
    author: UserCreateNestedOneWithoutCommentsInput
    documentVersion: DocumentVersionCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    authorID: string
    documentVersionID: string
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
  }

  export type CommentUpdateInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    documentVersion?: DocumentVersionUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    authorID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    authorID: string
    documentVersionID: string
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
  }

  export type CommentUpdateManyMutationInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    authorID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
  }

  export type UserDocumentPermissionCreateInput = {
    userDocumentPermissionID?: string
    role: Role
    user: UserCreateNestedOneWithoutUserDocumentPermissionsInput
    documentVersion?: DocumentVersionCreateNestedOneWithoutUserDocumentPermissionsInput
    document?: DocumentCreateNestedOneWithoutUserDocumentPermissionsInput
  }

  export type UserDocumentPermissionUncheckedCreateInput = {
    userDocumentPermissionID?: string
    userID: string
    documentVersionID?: string | null
    role: Role
    documentID?: string | null
  }

  export type UserDocumentPermissionUpdateInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    user?: UserUpdateOneRequiredWithoutUserDocumentPermissionsNestedInput
    documentVersion?: DocumentVersionUpdateOneWithoutUserDocumentPermissionsNestedInput
    document?: DocumentUpdateOneWithoutUserDocumentPermissionsNestedInput
  }

  export type UserDocumentPermissionUncheckedUpdateInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDocumentPermissionCreateManyInput = {
    userDocumentPermissionID?: string
    userID: string
    documentVersionID?: string | null
    role: Role
    documentID?: string | null
  }

  export type UserDocumentPermissionUpdateManyMutationInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type UserDocumentPermissionUncheckedUpdateManyInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserNotePermissionCreateInput = {
    userNotePermissionID?: string
    role: NoteRole
    user: UserCreateNestedOneWithoutUserNotePermissionInput
    note: NoteCreateNestedOneWithoutUserNotePermissionsInput
  }

  export type UserNotePermissionUncheckedCreateInput = {
    userNotePermissionID?: string
    userID: string
    role: NoteRole
    noteID: string
  }

  export type UserNotePermissionUpdateInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
    user?: UserUpdateOneRequiredWithoutUserNotePermissionNestedInput
    note?: NoteUpdateOneRequiredWithoutUserNotePermissionsNestedInput
  }

  export type UserNotePermissionUncheckedUpdateInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
    noteID?: StringFieldUpdateOperationsInput | string
  }

  export type UserNotePermissionCreateManyInput = {
    userNotePermissionID?: string
    userID: string
    role: NoteRole
    noteID: string
  }

  export type UserNotePermissionUpdateManyMutationInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
  }

  export type UserNotePermissionUncheckedUpdateManyInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
    noteID?: StringFieldUpdateOperationsInput | string
  }

  export type UserDocumentAttributesCreateInput = {
    document: DocumentCreateNestedOneWithoutUserDocumentAttributesInput
    user: UserCreateNestedOneWithoutUserDocumentAttributesInput
    lastOpenedDocumentVersion: DocumentVersionCreateNestedOneWithoutUserDocumentAttributesInput
  }

  export type UserDocumentAttributesUncheckedCreateInput = {
    documentID: string
    userID: string
    lastOpenedDocumentVersionID: string
  }

  export type UserDocumentAttributesUpdateInput = {
    document?: DocumentUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
    user?: UserUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
    lastOpenedDocumentVersion?: DocumentVersionUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
  }

  export type UserDocumentAttributesUncheckedUpdateInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    lastOpenedDocumentVersionID?: StringFieldUpdateOperationsInput | string
  }

  export type UserDocumentAttributesCreateManyInput = {
    documentID: string
    userID: string
    lastOpenedDocumentVersionID: string
  }

  export type UserDocumentAttributesUpdateManyMutationInput = {

  }

  export type UserDocumentAttributesUncheckedUpdateManyInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    lastOpenedDocumentVersionID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyStatUnitCreateInput = {
    dailyStatUnitID?: string
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
    user: UserCreateNestedOneWithoutStatUnitInput
    documentVersion?: DocumentVersionCreateNestedOneWithoutStatUnitInput
    document?: DocumentCreateNestedOneWithoutStatUnitInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedOneWithoutDailyStatUnitInput
  }

  export type DailyStatUnitUncheckedCreateInput = {
    dailyStatUnitID?: string
    userID: string
    documentVersionID?: string | null
    documentID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type DailyStatUnitUpdateInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStatUnitNestedInput
    documentVersion?: DocumentVersionUpdateOneWithoutStatUnitNestedInput
    document?: DocumentUpdateOneWithoutStatUnitNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateOneWithoutDailyStatUnitNestedInput
  }

  export type DailyStatUnitUncheckedUpdateInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeResponseID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type DailyStatUnitCreateManyInput = {
    dailyStatUnitID?: string
    userID: string
    documentVersionID?: string | null
    documentID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type DailyStatUnitUpdateManyMutationInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type DailyStatUnitUncheckedUpdateManyInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeResponseID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type WritingSessionCreateInput = {
    writingSessionID?: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    inProgress?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWritingSessionsInput
    document?: DocumentCreateNestedOneWithoutWritingSessionInput
    likes?: UserCreateNestedManyWithoutWritingSessionLikesInput
  }

  export type WritingSessionUncheckedCreateInput = {
    writingSessionID?: string
    userID: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    documentID?: string | null
    inProgress?: boolean
    updatedAt?: Date | string
    likes?: UserUncheckedCreateNestedManyWithoutWritingSessionLikesInput
  }

  export type WritingSessionUpdateInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWritingSessionsNestedInput
    document?: DocumentUpdateOneWithoutWritingSessionNestedInput
    likes?: UserUpdateManyWithoutWritingSessionLikesNestedInput
  }

  export type WritingSessionUncheckedUpdateInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserUncheckedUpdateManyWithoutWritingSessionLikesNestedInput
  }

  export type WritingSessionCreateManyInput = {
    writingSessionID?: string
    userID: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    documentID?: string | null
    inProgress?: boolean
    updatedAt?: Date | string
  }

  export type WritingSessionUpdateManyMutationInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WritingSessionUncheckedUpdateManyInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyChallengeCreateInput = {
    prompt: string
    date?: Date | string
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutDailyChallengeInput
  }

  export type DailyChallengeUncheckedCreateInput = {
    prompt: string
    date?: Date | string
    id?: number
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutDailyChallengeInput
  }

  export type DailyChallengeUpdateInput = {
    prompt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutDailyChallengeNestedInput
  }

  export type DailyChallengeUncheckedUpdateInput = {
    prompt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutDailyChallengeNestedInput
  }

  export type DailyChallengeCreateManyInput = {
    prompt: string
    date?: Date | string
    id?: number
  }

  export type DailyChallengeUpdateManyMutationInput = {
    prompt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyChallengeUncheckedUpdateManyInput = {
    prompt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type DailyChallengeResponseLikesCreateInput = {
    likeID?: string
    user: UserCreateNestedOneWithoutDailyChallengeResponseLikesInput
    dailyChallengeResponse: DailyChallengeResponseCreateNestedOneWithoutLikesInput
  }

  export type DailyChallengeResponseLikesUncheckedCreateInput = {
    userID: string
    dailyChallengeResponseID: string
    likeID?: string
  }

  export type DailyChallengeResponseLikesUpdateInput = {
    likeID?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDailyChallengeResponseLikesNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateOneRequiredWithoutLikesNestedInput
  }

  export type DailyChallengeResponseLikesUncheckedUpdateInput = {
    userID?: StringFieldUpdateOperationsInput | string
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    likeID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengeResponseLikesCreateManyInput = {
    userID: string
    dailyChallengeResponseID: string
    likeID?: string
  }

  export type DailyChallengeResponseLikesUpdateManyMutationInput = {
    likeID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengeResponseLikesUncheckedUpdateManyInput = {
    userID?: StringFieldUpdateOperationsInput | string
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    likeID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengeResponseCreateInput = {
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    user?: UserCreateNestedOneWithoutDailyChallengeResponseInput
    likes?: DailyChallengeResponseLikesCreateNestedManyWithoutDailyChallengeResponseInput
    dailyChallenge: DailyChallengeCreateNestedOneWithoutDailyChallengeResponseInput
    dailyStatUnit?: DailyStatUnitCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseUncheckedCreateInput = {
    userID?: string | null
    dailyChallengeID: number
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    likes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
    dailyStatUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseUpdateInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutDailyChallengeResponseNestedInput
    likes?: DailyChallengeResponseLikesUpdateManyWithoutDailyChallengeResponseNestedInput
    dailyChallenge?: DailyChallengeUpdateOneRequiredWithoutDailyChallengeResponseNestedInput
    dailyStatUnit?: DailyStatUnitUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseUncheckedUpdateInput = {
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeID?: IntFieldUpdateOperationsInput | number
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    likes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
    dailyStatUnit?: DailyStatUnitUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseCreateManyInput = {
    userID?: string | null
    dailyChallengeID: number
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
  }

  export type DailyChallengeResponseUpdateManyMutationInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyChallengeResponseUncheckedUpdateManyInput = {
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeID?: IntFieldUpdateOperationsInput | number
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyChallengePromptSuggestionCreateInput = {
    promptSuggestionID?: string
    prompt: string
    createdAt?: Date | string
    usedOn?: Date | string | null
    user: UserCreateNestedOneWithoutDailyChallengePromptSuggestionInput
  }

  export type DailyChallengePromptSuggestionUncheckedCreateInput = {
    promptSuggestionID?: string
    prompt: string
    userID: string
    createdAt?: Date | string
    usedOn?: Date | string | null
  }

  export type DailyChallengePromptSuggestionUpdateInput = {
    promptSuggestionID?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutDailyChallengePromptSuggestionNestedInput
  }

  export type DailyChallengePromptSuggestionUncheckedUpdateInput = {
    promptSuggestionID?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengePromptSuggestionCreateManyInput = {
    promptSuggestionID?: string
    prompt: string
    userID: string
    createdAt?: Date | string
    usedOn?: Date | string | null
  }

  export type DailyChallengePromptSuggestionUpdateManyMutationInput = {
    promptSuggestionID?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengePromptSuggestionUncheckedUpdateManyInput = {
    promptSuggestionID?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type UserDocumentPermissionListRelationFilter = {
    every?: UserDocumentPermissionWhereInput
    some?: UserDocumentPermissionWhereInput
    none?: UserDocumentPermissionWhereInput
  }

  export type UserNotePermissionListRelationFilter = {
    every?: UserNotePermissionWhereInput
    some?: UserNotePermissionWhereInput
    none?: UserNotePermissionWhereInput
  }

  export type DailyStatUnitListRelationFilter = {
    every?: DailyStatUnitWhereInput
    some?: DailyStatUnitWhereInput
    none?: DailyStatUnitWhereInput
  }

  export type ScratchpadEntryListRelationFilter = {
    every?: ScratchpadEntryWhereInput
    some?: ScratchpadEntryWhereInput
    none?: ScratchpadEntryWhereInput
  }

  export type UserDocumentAttributesListRelationFilter = {
    every?: UserDocumentAttributesWhereInput
    some?: UserDocumentAttributesWhereInput
    none?: UserDocumentAttributesWhereInput
  }

  export type DailyChallengeResponseListRelationFilter = {
    every?: DailyChallengeResponseWhereInput
    some?: DailyChallengeResponseWhereInput
    none?: DailyChallengeResponseWhereInput
  }

  export type DailyChallengeResponseLikesListRelationFilter = {
    every?: DailyChallengeResponseLikesWhereInput
    some?: DailyChallengeResponseLikesWhereInput
    none?: DailyChallengeResponseLikesWhereInput
  }

  export type DailyChallengePromptSuggestionListRelationFilter = {
    every?: DailyChallengePromptSuggestionWhereInput
    some?: DailyChallengePromptSuggestionWhereInput
    none?: DailyChallengePromptSuggestionWhereInput
  }

  export type FollowsListRelationFilter = {
    every?: FollowsWhereInput
    some?: FollowsWhereInput
    none?: FollowsWhereInput
  }

  export type PublishedDocumentListRelationFilter = {
    every?: PublishedDocumentWhereInput
    some?: PublishedDocumentWhereInput
    none?: PublishedDocumentWhereInput
  }

  export type WritingSessionListRelationFilter = {
    every?: WritingSessionWhereInput
    some?: WritingSessionWhereInput
    none?: WritingSessionWhereInput
  }

  export type UserEnhancedDocumentPermissionsListRelationFilter = {
    every?: UserEnhancedDocumentPermissionsWhereInput
    some?: UserEnhancedDocumentPermissionsWhereInput
    none?: UserEnhancedDocumentPermissionsWhereInput
  }

  export type ThreadAttributesListRelationFilter = {
    every?: ThreadAttributesWhereInput
    some?: ThreadAttributesWhereInput
    none?: ThreadAttributesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDocumentPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserNotePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyStatUnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScratchpadEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDocumentAttributesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyChallengeResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyChallengeResponseLikesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DailyChallengePromptSuggestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublishedDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WritingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserEnhancedDocumentPermissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadAttributesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    userID?: SortOrder
    username?: SortOrder
    appDrawerNoteIDs?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    longestStreak?: SortOrder
    bio?: SortOrder
    city?: SortOrder
    country?: SortOrder
    website?: SortOrder
    twitter?: SortOrder
    instagram?: SortOrder
    createdAt?: SortOrder
    openAIAPICalls?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    longestStreak?: SortOrder
    openAIAPICalls?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    userID?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    longestStreak?: SortOrder
    bio?: SortOrder
    city?: SortOrder
    country?: SortOrder
    website?: SortOrder
    twitter?: SortOrder
    instagram?: SortOrder
    createdAt?: SortOrder
    openAIAPICalls?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    userID?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    longestStreak?: SortOrder
    bio?: SortOrder
    city?: SortOrder
    country?: SortOrder
    website?: SortOrder
    twitter?: SortOrder
    instagram?: SortOrder
    createdAt?: SortOrder
    openAIAPICalls?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    longestStreak?: SortOrder
    openAIAPICalls?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type FollowsFollowerIDFollowingIDCompoundUniqueInput = {
    followerID: string
    followingID: string
  }

  export type FollowsCountOrderByAggregateInput = {
    followerID?: SortOrder
    followingID?: SortOrder
  }

  export type FollowsMaxOrderByAggregateInput = {
    followerID?: SortOrder
    followingID?: SortOrder
  }

  export type FollowsMinOrderByAggregateInput = {
    followerID?: SortOrder
    followingID?: SortOrder
  }
  export type JsonNullableFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase>, Exclude<keyof Required<JsonNullableFilterBase>, 'path'>>,
        Required<JsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase>, 'path'>>

  export type JsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type DocumentRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type NoteCountOrderByAggregateInput = {
    noteID?: SortOrder
    title?: SortOrder
    content?: SortOrder
    icon?: SortOrder
    updatedAt?: SortOrder
    documentID?: SortOrder
    personal?: SortOrder
  }

  export type NoteMaxOrderByAggregateInput = {
    noteID?: SortOrder
    title?: SortOrder
    icon?: SortOrder
    updatedAt?: SortOrder
    documentID?: SortOrder
    personal?: SortOrder
  }

  export type NoteMinOrderByAggregateInput = {
    noteID?: SortOrder
    title?: SortOrder
    icon?: SortOrder
    updatedAt?: SortOrder
    documentID?: SortOrder
    personal?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntNullableFilter
    _min?: NestedJsonNullableFilter
    _max?: NestedJsonNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type DocumentVersionCountOrderByAggregateInput = {
    documentVersionID?: SortOrder
    content?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    documentID?: SortOrder
    versionName?: SortOrder
    wordCount?: SortOrder
  }

  export type DocumentVersionAvgOrderByAggregateInput = {
    wordCount?: SortOrder
  }

  export type DocumentVersionMaxOrderByAggregateInput = {
    documentVersionID?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    documentID?: SortOrder
    versionName?: SortOrder
    wordCount?: SortOrder
  }

  export type DocumentVersionMinOrderByAggregateInput = {
    documentVersionID?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    documentID?: SortOrder
    versionName?: SortOrder
    wordCount?: SortOrder
  }

  export type DocumentVersionSumOrderByAggregateInput = {
    wordCount?: SortOrder
  }

  export type DocumentVersionListRelationFilter = {
    every?: DocumentVersionWhereInput
    some?: DocumentVersionWhereInput
    none?: DocumentVersionWhereInput
  }

  export type NoteListRelationFilter = {
    every?: NoteWhereInput
    some?: NoteWhereInput
    none?: NoteWhereInput
  }

  export type DocumentVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    documentID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    documentID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    documentID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEnhancedDocumentRoleFilter = {
    equals?: EnhancedDocumentRole
    in?: Enumerable<EnhancedDocumentRole>
    notIn?: Enumerable<EnhancedDocumentRole>
    not?: NestedEnumEnhancedDocumentRoleFilter | EnhancedDocumentRole
  }

  export type EnhancedDocumentRelationFilter = {
    is?: EnhancedDocumentWhereInput | null
    isNot?: EnhancedDocumentWhereInput | null
  }

  export type UserEnhancedDocumentPermissionsUserIDEnhancedDocumentIDCompoundUniqueInput = {
    userID: string
    enhancedDocumentID: string
  }

  export type UserEnhancedDocumentPermissionsCountOrderByAggregateInput = {
    userID?: SortOrder
    enhancedDocumentID?: SortOrder
    role?: SortOrder
  }

  export type UserEnhancedDocumentPermissionsMaxOrderByAggregateInput = {
    userID?: SortOrder
    enhancedDocumentID?: SortOrder
    role?: SortOrder
  }

  export type UserEnhancedDocumentPermissionsMinOrderByAggregateInput = {
    userID?: SortOrder
    enhancedDocumentID?: SortOrder
    role?: SortOrder
  }

  export type EnumEnhancedDocumentRoleWithAggregatesFilter = {
    equals?: EnhancedDocumentRole
    in?: Enumerable<EnhancedDocumentRole>
    notIn?: Enumerable<EnhancedDocumentRole>
    not?: NestedEnumEnhancedDocumentRoleWithAggregatesFilter | EnhancedDocumentRole
    _count?: NestedIntFilter
    _min?: NestedEnumEnhancedDocumentRoleFilter
    _max?: NestedEnumEnhancedDocumentRoleFilter
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type EnhancedDocumentCountOrderByAggregateInput = {
    enhancedDocumentID?: SortOrder
    notesContent?: SortOrder
    embeddingsByNodeID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    draftContent?: SortOrder
    draftCollapsed?: SortOrder
    ideas?: SortOrder
  }

  export type EnhancedDocumentMaxOrderByAggregateInput = {
    enhancedDocumentID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    draftCollapsed?: SortOrder
  }

  export type EnhancedDocumentMinOrderByAggregateInput = {
    enhancedDocumentID?: SortOrder
    title?: SortOrder
    updatedAt?: SortOrder
    draftCollapsed?: SortOrder
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadAttributesCountOrderByAggregateInput = {
    threadID?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrder
    enhancedDocumentID?: SortOrder
    sectionData?: SortOrder
  }

  export type ThreadAttributesMaxOrderByAggregateInput = {
    threadID?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrder
    enhancedDocumentID?: SortOrder
  }

  export type ThreadAttributesMinOrderByAggregateInput = {
    threadID?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrder
    enhancedDocumentID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type EnumChatMessageAuthorFilter = {
    equals?: ChatMessageAuthor
    in?: Enumerable<ChatMessageAuthor>
    notIn?: Enumerable<ChatMessageAuthor>
    not?: NestedEnumChatMessageAuthorFilter | ChatMessageAuthor
  }

  export type ThreadAttributesRelationFilter = {
    is?: ThreadAttributesWhereInput | null
    isNot?: ThreadAttributesWhereInput | null
  }

  export type ChatMessageCountOrderByAggregateInput = {
    chatMessageID?: SortOrder
    content?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    threadID?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    chatMessageID?: SortOrder
    content?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    threadID?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    chatMessageID?: SortOrder
    content?: SortOrder
    author?: SortOrder
    createdAt?: SortOrder
    threadID?: SortOrder
  }

  export type EnumChatMessageAuthorWithAggregatesFilter = {
    equals?: ChatMessageAuthor
    in?: Enumerable<ChatMessageAuthor>
    notIn?: Enumerable<ChatMessageAuthor>
    not?: NestedEnumChatMessageAuthorWithAggregatesFilter | ChatMessageAuthor
    _count?: NestedIntFilter
    _min?: NestedEnumChatMessageAuthorFilter
    _max?: NestedEnumChatMessageAuthorFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublishedDocumentDocumentIDUserIDCompoundUniqueInput = {
    documentID: string
    userID: string
  }

  export type PublishedDocumentUserIDUrlCompoundUniqueInput = {
    userID: string
    url: string
  }

  export type PublishedDocumentCountOrderByAggregateInput = {
    publishedDocumentID?: SortOrder
    documentID?: SortOrder
    content?: SortOrder
    url?: SortOrder
    userID?: SortOrder
    publishedAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
  }

  export type PublishedDocumentMaxOrderByAggregateInput = {
    publishedDocumentID?: SortOrder
    documentID?: SortOrder
    url?: SortOrder
    userID?: SortOrder
    publishedAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
  }

  export type PublishedDocumentMinOrderByAggregateInput = {
    publishedDocumentID?: SortOrder
    documentID?: SortOrder
    url?: SortOrder
    userID?: SortOrder
    publishedAt?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
  }

  export type ScratchpadEntryCountOrderByAggregateInput = {
    scratchpadEntryID?: SortOrder
    content?: SortOrder
    date?: SortOrder
    userID?: SortOrder
  }

  export type ScratchpadEntryMaxOrderByAggregateInput = {
    scratchpadEntryID?: SortOrder
    date?: SortOrder
    userID?: SortOrder
  }

  export type ScratchpadEntryMinOrderByAggregateInput = {
    scratchpadEntryID?: SortOrder
    date?: SortOrder
    userID?: SortOrder
  }

  export type DocumentVersionRelationFilter = {
    is?: DocumentVersionWhereInput | null
    isNot?: DocumentVersionWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    commentID?: SortOrder
    commentData?: SortOrder
    authorID?: SortOrder
    documentVersionID?: SortOrder
    updatedAt?: SortOrder
    private?: SortOrder
    resolved?: SortOrder
    selectedText?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    commentID?: SortOrder
    authorID?: SortOrder
    documentVersionID?: SortOrder
    updatedAt?: SortOrder
    private?: SortOrder
    resolved?: SortOrder
    selectedText?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    commentID?: SortOrder
    authorID?: SortOrder
    documentVersionID?: SortOrder
    updatedAt?: SortOrder
    private?: SortOrder
    resolved?: SortOrder
    selectedText?: SortOrder
  }

  export type EnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type UserDocumentPermissionCountOrderByAggregateInput = {
    userDocumentPermissionID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrder
    role?: SortOrder
    documentID?: SortOrder
  }

  export type UserDocumentPermissionMaxOrderByAggregateInput = {
    userDocumentPermissionID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrder
    role?: SortOrder
    documentID?: SortOrder
  }

  export type UserDocumentPermissionMinOrderByAggregateInput = {
    userDocumentPermissionID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrder
    role?: SortOrder
    documentID?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type EnumNoteRoleFilter = {
    equals?: NoteRole
    in?: Enumerable<NoteRole>
    notIn?: Enumerable<NoteRole>
    not?: NestedEnumNoteRoleFilter | NoteRole
  }

  export type NoteRelationFilter = {
    is?: NoteWhereInput | null
    isNot?: NoteWhereInput | null
  }

  export type UserNotePermissionCountOrderByAggregateInput = {
    userNotePermissionID?: SortOrder
    userID?: SortOrder
    role?: SortOrder
    noteID?: SortOrder
  }

  export type UserNotePermissionMaxOrderByAggregateInput = {
    userNotePermissionID?: SortOrder
    userID?: SortOrder
    role?: SortOrder
    noteID?: SortOrder
  }

  export type UserNotePermissionMinOrderByAggregateInput = {
    userNotePermissionID?: SortOrder
    userID?: SortOrder
    role?: SortOrder
    noteID?: SortOrder
  }

  export type EnumNoteRoleWithAggregatesFilter = {
    equals?: NoteRole
    in?: Enumerable<NoteRole>
    notIn?: Enumerable<NoteRole>
    not?: NestedEnumNoteRoleWithAggregatesFilter | NoteRole
    _count?: NestedIntFilter
    _min?: NestedEnumNoteRoleFilter
    _max?: NestedEnumNoteRoleFilter
  }

  export type UserDocumentAttributesDocumentIDUserIDCompoundUniqueInput = {
    documentID: string
    userID: string
  }

  export type UserDocumentAttributesCountOrderByAggregateInput = {
    documentID?: SortOrder
    userID?: SortOrder
    lastOpenedDocumentVersionID?: SortOrder
  }

  export type UserDocumentAttributesMaxOrderByAggregateInput = {
    documentID?: SortOrder
    userID?: SortOrder
    lastOpenedDocumentVersionID?: SortOrder
  }

  export type UserDocumentAttributesMinOrderByAggregateInput = {
    documentID?: SortOrder
    userID?: SortOrder
    lastOpenedDocumentVersionID?: SortOrder
  }

  export type DailyChallengeResponseRelationFilter = {
    is?: DailyChallengeResponseWhereInput | null
    isNot?: DailyChallengeResponseWhereInput | null
  }

  export type DailyStatUnitUserIDDateDocumentVersionIDCompoundUniqueInput = {
    userID: string
    date: Date | string
    documentVersionID: string
  }

  export type DailyStatUnitDateDailyChallengeResponseIDCompoundUniqueInput = {
    date: Date | string
    dailyChallengeResponseID: string
  }

  export type DailyStatUnitCountOrderByAggregateInput = {
    dailyStatUnitID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrder
    documentID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    date?: SortOrder
    timeSpentSeconds?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
  }

  export type DailyStatUnitAvgOrderByAggregateInput = {
    timeSpentSeconds?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
  }

  export type DailyStatUnitMaxOrderByAggregateInput = {
    dailyStatUnitID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrder
    documentID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    date?: SortOrder
    timeSpentSeconds?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
  }

  export type DailyStatUnitMinOrderByAggregateInput = {
    dailyStatUnitID?: SortOrder
    userID?: SortOrder
    documentVersionID?: SortOrder
    documentID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    date?: SortOrder
    timeSpentSeconds?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
  }

  export type DailyStatUnitSumOrderByAggregateInput = {
    timeSpentSeconds?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
  }

  export type IntNullableListFilter = {
    equals?: Enumerable<number> | null
    has?: number | null
    hasEvery?: Enumerable<number>
    hasSome?: Enumerable<number>
    isEmpty?: boolean
  }

  export type WritingSessionCountOrderByAggregateInput = {
    writingSessionID?: SortOrder
    userID?: SortOrder
    segmentTime?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    timeSpentSeconds?: SortOrder
    startDateTime?: SortOrder
    title?: SortOrder
    documentID?: SortOrder
    inProgress?: SortOrder
    updatedAt?: SortOrder
  }

  export type WritingSessionAvgOrderByAggregateInput = {
    segmentTime?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    timeSpentSeconds?: SortOrder
  }

  export type WritingSessionMaxOrderByAggregateInput = {
    writingSessionID?: SortOrder
    userID?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    timeSpentSeconds?: SortOrder
    startDateTime?: SortOrder
    title?: SortOrder
    documentID?: SortOrder
    inProgress?: SortOrder
    updatedAt?: SortOrder
  }

  export type WritingSessionMinOrderByAggregateInput = {
    writingSessionID?: SortOrder
    userID?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    timeSpentSeconds?: SortOrder
    startDateTime?: SortOrder
    title?: SortOrder
    documentID?: SortOrder
    inProgress?: SortOrder
    updatedAt?: SortOrder
  }

  export type WritingSessionSumOrderByAggregateInput = {
    segmentTime?: SortOrder
    wordsAdded?: SortOrder
    wordsRemoved?: SortOrder
    timeSpentSeconds?: SortOrder
  }

  export type DailyChallengeCountOrderByAggregateInput = {
    prompt?: SortOrder
    date?: SortOrder
    id?: SortOrder
  }

  export type DailyChallengeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DailyChallengeMaxOrderByAggregateInput = {
    prompt?: SortOrder
    date?: SortOrder
    id?: SortOrder
  }

  export type DailyChallengeMinOrderByAggregateInput = {
    prompt?: SortOrder
    date?: SortOrder
    id?: SortOrder
  }

  export type DailyChallengeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DailyChallengeResponseLikesUserIDDailyChallengeResponseIDCompoundUniqueInput = {
    userID: string
    dailyChallengeResponseID: string
  }

  export type DailyChallengeResponseLikesCountOrderByAggregateInput = {
    userID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    likeID?: SortOrder
  }

  export type DailyChallengeResponseLikesMaxOrderByAggregateInput = {
    userID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    likeID?: SortOrder
  }

  export type DailyChallengeResponseLikesMinOrderByAggregateInput = {
    userID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    likeID?: SortOrder
  }

  export type DailyChallengeRelationFilter = {
    is?: DailyChallengeWhereInput | null
    isNot?: DailyChallengeWhereInput | null
  }

  export type DailyChallengeResponseUserIDDailyChallengeIDCompoundUniqueInput = {
    userID: string
    dailyChallengeID: number
  }

  export type DailyChallengeResponseCountOrderByAggregateInput = {
    userID?: SortOrder
    dailyChallengeID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    content?: SortOrder
    postedOn?: SortOrder
    wordCount?: SortOrder
    completedOnTime?: SortOrder
  }

  export type DailyChallengeResponseAvgOrderByAggregateInput = {
    dailyChallengeID?: SortOrder
    wordCount?: SortOrder
  }

  export type DailyChallengeResponseMaxOrderByAggregateInput = {
    userID?: SortOrder
    dailyChallengeID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    postedOn?: SortOrder
    wordCount?: SortOrder
    completedOnTime?: SortOrder
  }

  export type DailyChallengeResponseMinOrderByAggregateInput = {
    userID?: SortOrder
    dailyChallengeID?: SortOrder
    dailyChallengeResponseID?: SortOrder
    postedOn?: SortOrder
    wordCount?: SortOrder
    completedOnTime?: SortOrder
  }

  export type DailyChallengeResponseSumOrderByAggregateInput = {
    dailyChallengeID?: SortOrder
    wordCount?: SortOrder
  }

  export type DailyChallengePromptSuggestionCountOrderByAggregateInput = {
    promptSuggestionID?: SortOrder
    prompt?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    usedOn?: SortOrder
  }

  export type DailyChallengePromptSuggestionMaxOrderByAggregateInput = {
    promptSuggestionID?: SortOrder
    prompt?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    usedOn?: SortOrder
  }

  export type DailyChallengePromptSuggestionMinOrderByAggregateInput = {
    promptSuggestionID?: SortOrder
    prompt?: SortOrder
    userID?: SortOrder
    createdAt?: SortOrder
    usedOn?: SortOrder
  }

  export type UserCreateappDrawerNoteIDsInput = {
    set: Enumerable<string>
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserDocumentPermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutUserInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutUserInput>
    createMany?: UserDocumentPermissionCreateManyUserInputEnvelope
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
  }

  export type UserNotePermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutUserInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutUserInput>
    createMany?: UserNotePermissionCreateManyUserInputEnvelope
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
  }

  export type DailyStatUnitCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutUserInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutUserInput>
    createMany?: DailyStatUnitCreateManyUserInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type ScratchpadEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ScratchpadEntryCreateWithoutUserInput>, Enumerable<ScratchpadEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScratchpadEntryCreateOrConnectWithoutUserInput>
    createMany?: ScratchpadEntryCreateManyUserInputEnvelope
    connect?: Enumerable<ScratchpadEntryWhereUniqueInput>
  }

  export type UserDocumentAttributesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutUserInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutUserInput>
    createMany?: UserDocumentAttributesCreateManyUserInputEnvelope
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
  }

  export type DailyChallengeResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutUserInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutUserInput>
    createMany?: DailyChallengeResponseCreateManyUserInputEnvelope
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
  }

  export type DailyChallengeResponseLikesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutUserInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutUserInput>
    createMany?: DailyChallengeResponseLikesCreateManyUserInputEnvelope
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
  }

  export type DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyChallengePromptSuggestionCreateWithoutUserInput>, Enumerable<DailyChallengePromptSuggestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengePromptSuggestionCreateOrConnectWithoutUserInput>
    createMany?: DailyChallengePromptSuggestionCreateManyUserInputEnvelope
    connect?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
  }

  export type FollowsCreateNestedManyWithoutFollowingInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowingInput>, Enumerable<FollowsUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowingInput>
    createMany?: FollowsCreateManyFollowingInputEnvelope
    connect?: Enumerable<FollowsWhereUniqueInput>
  }

  export type FollowsCreateNestedManyWithoutFollowerInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowerInput>, Enumerable<FollowsUncheckedCreateWithoutFollowerInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowerInput>
    createMany?: FollowsCreateManyFollowerInputEnvelope
    connect?: Enumerable<FollowsWhereUniqueInput>
  }

  export type PublishedDocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutUserInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutUserInput>
    createMany?: PublishedDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
  }

  export type PublishedDocumentCreateNestedManyWithoutLikingUsersInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutLikingUsersInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutLikingUsersInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutLikingUsersInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
  }

  export type WritingSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutUserInput>, Enumerable<WritingSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutUserInput>
    createMany?: WritingSessionCreateManyUserInputEnvelope
    connect?: Enumerable<WritingSessionWhereUniqueInput>
  }

  export type WritingSessionCreateNestedManyWithoutLikesInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutLikesInput>, Enumerable<WritingSessionUncheckedCreateWithoutLikesInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutLikesInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
  }

  export type UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutUserInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutUserInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyUserInputEnvelope
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
  }

  export type ThreadAttributesCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutUserInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutUserInput>
    createMany?: ThreadAttributesCreateManyUserInputEnvelope
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutUserInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutUserInput>
    createMany?: UserDocumentPermissionCreateManyUserInputEnvelope
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
  }

  export type UserNotePermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutUserInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutUserInput>
    createMany?: UserNotePermissionCreateManyUserInputEnvelope
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
  }

  export type DailyStatUnitUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutUserInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutUserInput>
    createMany?: DailyStatUnitCreateManyUserInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ScratchpadEntryCreateWithoutUserInput>, Enumerable<ScratchpadEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScratchpadEntryCreateOrConnectWithoutUserInput>
    createMany?: ScratchpadEntryCreateManyUserInputEnvelope
    connect?: Enumerable<ScratchpadEntryWhereUniqueInput>
  }

  export type UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutUserInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutUserInput>
    createMany?: UserDocumentAttributesCreateManyUserInputEnvelope
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
  }

  export type DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutUserInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutUserInput>
    createMany?: DailyChallengeResponseCreateManyUserInputEnvelope
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
  }

  export type DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutUserInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutUserInput>
    createMany?: DailyChallengeResponseLikesCreateManyUserInputEnvelope
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
  }

  export type DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<DailyChallengePromptSuggestionCreateWithoutUserInput>, Enumerable<DailyChallengePromptSuggestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengePromptSuggestionCreateOrConnectWithoutUserInput>
    createMany?: DailyChallengePromptSuggestionCreateManyUserInputEnvelope
    connect?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
  }

  export type FollowsUncheckedCreateNestedManyWithoutFollowingInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowingInput>, Enumerable<FollowsUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowingInput>
    createMany?: FollowsCreateManyFollowingInputEnvelope
    connect?: Enumerable<FollowsWhereUniqueInput>
  }

  export type FollowsUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowerInput>, Enumerable<FollowsUncheckedCreateWithoutFollowerInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowerInput>
    createMany?: FollowsCreateManyFollowerInputEnvelope
    connect?: Enumerable<FollowsWhereUniqueInput>
  }

  export type PublishedDocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutUserInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutUserInput>
    createMany?: PublishedDocumentCreateManyUserInputEnvelope
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
  }

  export type PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutLikingUsersInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutLikingUsersInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutLikingUsersInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
  }

  export type WritingSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutUserInput>, Enumerable<WritingSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutUserInput>
    createMany?: WritingSessionCreateManyUserInputEnvelope
    connect?: Enumerable<WritingSessionWhereUniqueInput>
  }

  export type WritingSessionUncheckedCreateNestedManyWithoutLikesInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutLikesInput>, Enumerable<WritingSessionUncheckedCreateWithoutLikesInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutLikesInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
  }

  export type UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutUserInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutUserInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyUserInputEnvelope
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
  }

  export type ThreadAttributesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutUserInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutUserInput>
    createMany?: ThreadAttributesCreateManyUserInputEnvelope
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateappDrawerNoteIDsInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserDocumentPermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutUserInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDocumentPermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDocumentPermissionCreateManyUserInputEnvelope
    set?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    delete?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    update?: Enumerable<UserDocumentPermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDocumentPermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDocumentPermissionScalarWhereInput>
  }

  export type UserNotePermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutUserInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserNotePermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserNotePermissionCreateManyUserInputEnvelope
    set?: Enumerable<UserNotePermissionWhereUniqueInput>
    disconnect?: Enumerable<UserNotePermissionWhereUniqueInput>
    delete?: Enumerable<UserNotePermissionWhereUniqueInput>
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
    update?: Enumerable<UserNotePermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserNotePermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserNotePermissionScalarWhereInput>
  }

  export type DailyStatUnitUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutUserInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyStatUnitCreateManyUserInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type ScratchpadEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ScratchpadEntryCreateWithoutUserInput>, Enumerable<ScratchpadEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScratchpadEntryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ScratchpadEntryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ScratchpadEntryCreateManyUserInputEnvelope
    set?: Enumerable<ScratchpadEntryWhereUniqueInput>
    disconnect?: Enumerable<ScratchpadEntryWhereUniqueInput>
    delete?: Enumerable<ScratchpadEntryWhereUniqueInput>
    connect?: Enumerable<ScratchpadEntryWhereUniqueInput>
    update?: Enumerable<ScratchpadEntryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ScratchpadEntryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ScratchpadEntryScalarWhereInput>
  }

  export type UserDocumentAttributesUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutUserInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDocumentAttributesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDocumentAttributesCreateManyUserInputEnvelope
    set?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    delete?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    update?: Enumerable<UserDocumentAttributesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDocumentAttributesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDocumentAttributesScalarWhereInput>
  }

  export type DailyChallengeResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutUserInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyChallengeResponseUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyChallengeResponseCreateManyUserInputEnvelope
    set?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyChallengeResponseUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyChallengeResponseScalarWhereInput>
  }

  export type DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutUserInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyChallengeResponseLikesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyChallengeResponseLikesCreateManyUserInputEnvelope
    set?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseLikesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyChallengeResponseLikesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyChallengeResponseLikesScalarWhereInput>
  }

  export type DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyChallengePromptSuggestionCreateWithoutUserInput>, Enumerable<DailyChallengePromptSuggestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengePromptSuggestionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyChallengePromptSuggestionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyChallengePromptSuggestionCreateManyUserInputEnvelope
    set?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    delete?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    connect?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    update?: Enumerable<DailyChallengePromptSuggestionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyChallengePromptSuggestionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyChallengePromptSuggestionScalarWhereInput>
  }

  export type FollowsUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowingInput>, Enumerable<FollowsUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowingInput>
    upsert?: Enumerable<FollowsUpsertWithWhereUniqueWithoutFollowingInput>
    createMany?: FollowsCreateManyFollowingInputEnvelope
    set?: Enumerable<FollowsWhereUniqueInput>
    disconnect?: Enumerable<FollowsWhereUniqueInput>
    delete?: Enumerable<FollowsWhereUniqueInput>
    connect?: Enumerable<FollowsWhereUniqueInput>
    update?: Enumerable<FollowsUpdateWithWhereUniqueWithoutFollowingInput>
    updateMany?: Enumerable<FollowsUpdateManyWithWhereWithoutFollowingInput>
    deleteMany?: Enumerable<FollowsScalarWhereInput>
  }

  export type FollowsUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowerInput>, Enumerable<FollowsUncheckedCreateWithoutFollowerInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowerInput>
    upsert?: Enumerable<FollowsUpsertWithWhereUniqueWithoutFollowerInput>
    createMany?: FollowsCreateManyFollowerInputEnvelope
    set?: Enumerable<FollowsWhereUniqueInput>
    disconnect?: Enumerable<FollowsWhereUniqueInput>
    delete?: Enumerable<FollowsWhereUniqueInput>
    connect?: Enumerable<FollowsWhereUniqueInput>
    update?: Enumerable<FollowsUpdateWithWhereUniqueWithoutFollowerInput>
    updateMany?: Enumerable<FollowsUpdateManyWithWhereWithoutFollowerInput>
    deleteMany?: Enumerable<FollowsScalarWhereInput>
  }

  export type PublishedDocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutUserInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PublishedDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PublishedDocumentCreateManyUserInputEnvelope
    set?: Enumerable<PublishedDocumentWhereUniqueInput>
    disconnect?: Enumerable<PublishedDocumentWhereUniqueInput>
    delete?: Enumerable<PublishedDocumentWhereUniqueInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
    update?: Enumerable<PublishedDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PublishedDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PublishedDocumentScalarWhereInput>
  }

  export type PublishedDocumentUpdateManyWithoutLikingUsersNestedInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutLikingUsersInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutLikingUsersInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutLikingUsersInput>
    upsert?: Enumerable<PublishedDocumentUpsertWithWhereUniqueWithoutLikingUsersInput>
    set?: Enumerable<PublishedDocumentWhereUniqueInput>
    disconnect?: Enumerable<PublishedDocumentWhereUniqueInput>
    delete?: Enumerable<PublishedDocumentWhereUniqueInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
    update?: Enumerable<PublishedDocumentUpdateWithWhereUniqueWithoutLikingUsersInput>
    updateMany?: Enumerable<PublishedDocumentUpdateManyWithWhereWithoutLikingUsersInput>
    deleteMany?: Enumerable<PublishedDocumentScalarWhereInput>
  }

  export type WritingSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutUserInput>, Enumerable<WritingSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WritingSessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WritingSessionCreateManyUserInputEnvelope
    set?: Enumerable<WritingSessionWhereUniqueInput>
    disconnect?: Enumerable<WritingSessionWhereUniqueInput>
    delete?: Enumerable<WritingSessionWhereUniqueInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
    update?: Enumerable<WritingSessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WritingSessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WritingSessionScalarWhereInput>
  }

  export type WritingSessionUpdateManyWithoutLikesNestedInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutLikesInput>, Enumerable<WritingSessionUncheckedCreateWithoutLikesInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutLikesInput>
    upsert?: Enumerable<WritingSessionUpsertWithWhereUniqueWithoutLikesInput>
    set?: Enumerable<WritingSessionWhereUniqueInput>
    disconnect?: Enumerable<WritingSessionWhereUniqueInput>
    delete?: Enumerable<WritingSessionWhereUniqueInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
    update?: Enumerable<WritingSessionUpdateWithWhereUniqueWithoutLikesInput>
    updateMany?: Enumerable<WritingSessionUpdateManyWithWhereWithoutLikesInput>
    deleteMany?: Enumerable<WritingSessionScalarWhereInput>
  }

  export type UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutUserInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserEnhancedDocumentPermissionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyUserInputEnvelope
    set?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    disconnect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    delete?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    update?: Enumerable<UserEnhancedDocumentPermissionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserEnhancedDocumentPermissionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereInput>
  }

  export type ThreadAttributesUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutUserInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ThreadAttributesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ThreadAttributesCreateManyUserInputEnvelope
    set?: Enumerable<ThreadAttributesWhereUniqueInput>
    disconnect?: Enumerable<ThreadAttributesWhereUniqueInput>
    delete?: Enumerable<ThreadAttributesWhereUniqueInput>
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
    update?: Enumerable<ThreadAttributesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ThreadAttributesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ThreadAttributesScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutAuthorInput>, Enumerable<CommentUncheckedCreateWithoutAuthorInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutAuthorInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutAuthorInput>
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutAuthorInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutAuthorInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutUserInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDocumentPermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDocumentPermissionCreateManyUserInputEnvelope
    set?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    delete?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    update?: Enumerable<UserDocumentPermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDocumentPermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDocumentPermissionScalarWhereInput>
  }

  export type UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutUserInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserNotePermissionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserNotePermissionCreateManyUserInputEnvelope
    set?: Enumerable<UserNotePermissionWhereUniqueInput>
    disconnect?: Enumerable<UserNotePermissionWhereUniqueInput>
    delete?: Enumerable<UserNotePermissionWhereUniqueInput>
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
    update?: Enumerable<UserNotePermissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserNotePermissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserNotePermissionScalarWhereInput>
  }

  export type DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutUserInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyStatUnitCreateManyUserInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ScratchpadEntryCreateWithoutUserInput>, Enumerable<ScratchpadEntryUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ScratchpadEntryCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ScratchpadEntryUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ScratchpadEntryCreateManyUserInputEnvelope
    set?: Enumerable<ScratchpadEntryWhereUniqueInput>
    disconnect?: Enumerable<ScratchpadEntryWhereUniqueInput>
    delete?: Enumerable<ScratchpadEntryWhereUniqueInput>
    connect?: Enumerable<ScratchpadEntryWhereUniqueInput>
    update?: Enumerable<ScratchpadEntryUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ScratchpadEntryUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ScratchpadEntryScalarWhereInput>
  }

  export type UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutUserInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserDocumentAttributesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserDocumentAttributesCreateManyUserInputEnvelope
    set?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    delete?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    update?: Enumerable<UserDocumentAttributesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserDocumentAttributesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserDocumentAttributesScalarWhereInput>
  }

  export type DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutUserInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyChallengeResponseUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyChallengeResponseCreateManyUserInputEnvelope
    set?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyChallengeResponseUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyChallengeResponseScalarWhereInput>
  }

  export type DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutUserInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyChallengeResponseLikesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyChallengeResponseLikesCreateManyUserInputEnvelope
    set?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseLikesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyChallengeResponseLikesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyChallengeResponseLikesScalarWhereInput>
  }

  export type DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<DailyChallengePromptSuggestionCreateWithoutUserInput>, Enumerable<DailyChallengePromptSuggestionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<DailyChallengePromptSuggestionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<DailyChallengePromptSuggestionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: DailyChallengePromptSuggestionCreateManyUserInputEnvelope
    set?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    delete?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    connect?: Enumerable<DailyChallengePromptSuggestionWhereUniqueInput>
    update?: Enumerable<DailyChallengePromptSuggestionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<DailyChallengePromptSuggestionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<DailyChallengePromptSuggestionScalarWhereInput>
  }

  export type FollowsUncheckedUpdateManyWithoutFollowingNestedInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowingInput>, Enumerable<FollowsUncheckedCreateWithoutFollowingInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowingInput>
    upsert?: Enumerable<FollowsUpsertWithWhereUniqueWithoutFollowingInput>
    createMany?: FollowsCreateManyFollowingInputEnvelope
    set?: Enumerable<FollowsWhereUniqueInput>
    disconnect?: Enumerable<FollowsWhereUniqueInput>
    delete?: Enumerable<FollowsWhereUniqueInput>
    connect?: Enumerable<FollowsWhereUniqueInput>
    update?: Enumerable<FollowsUpdateWithWhereUniqueWithoutFollowingInput>
    updateMany?: Enumerable<FollowsUpdateManyWithWhereWithoutFollowingInput>
    deleteMany?: Enumerable<FollowsScalarWhereInput>
  }

  export type FollowsUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<Enumerable<FollowsCreateWithoutFollowerInput>, Enumerable<FollowsUncheckedCreateWithoutFollowerInput>>
    connectOrCreate?: Enumerable<FollowsCreateOrConnectWithoutFollowerInput>
    upsert?: Enumerable<FollowsUpsertWithWhereUniqueWithoutFollowerInput>
    createMany?: FollowsCreateManyFollowerInputEnvelope
    set?: Enumerable<FollowsWhereUniqueInput>
    disconnect?: Enumerable<FollowsWhereUniqueInput>
    delete?: Enumerable<FollowsWhereUniqueInput>
    connect?: Enumerable<FollowsWhereUniqueInput>
    update?: Enumerable<FollowsUpdateWithWhereUniqueWithoutFollowerInput>
    updateMany?: Enumerable<FollowsUpdateManyWithWhereWithoutFollowerInput>
    deleteMany?: Enumerable<FollowsScalarWhereInput>
  }

  export type PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutUserInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PublishedDocumentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PublishedDocumentCreateManyUserInputEnvelope
    set?: Enumerable<PublishedDocumentWhereUniqueInput>
    disconnect?: Enumerable<PublishedDocumentWhereUniqueInput>
    delete?: Enumerable<PublishedDocumentWhereUniqueInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
    update?: Enumerable<PublishedDocumentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PublishedDocumentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PublishedDocumentScalarWhereInput>
  }

  export type PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutLikingUsersInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutLikingUsersInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutLikingUsersInput>
    upsert?: Enumerable<PublishedDocumentUpsertWithWhereUniqueWithoutLikingUsersInput>
    set?: Enumerable<PublishedDocumentWhereUniqueInput>
    disconnect?: Enumerable<PublishedDocumentWhereUniqueInput>
    delete?: Enumerable<PublishedDocumentWhereUniqueInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
    update?: Enumerable<PublishedDocumentUpdateWithWhereUniqueWithoutLikingUsersInput>
    updateMany?: Enumerable<PublishedDocumentUpdateManyWithWhereWithoutLikingUsersInput>
    deleteMany?: Enumerable<PublishedDocumentScalarWhereInput>
  }

  export type WritingSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutUserInput>, Enumerable<WritingSessionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WritingSessionUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WritingSessionCreateManyUserInputEnvelope
    set?: Enumerable<WritingSessionWhereUniqueInput>
    disconnect?: Enumerable<WritingSessionWhereUniqueInput>
    delete?: Enumerable<WritingSessionWhereUniqueInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
    update?: Enumerable<WritingSessionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WritingSessionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WritingSessionScalarWhereInput>
  }

  export type WritingSessionUncheckedUpdateManyWithoutLikesNestedInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutLikesInput>, Enumerable<WritingSessionUncheckedCreateWithoutLikesInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutLikesInput>
    upsert?: Enumerable<WritingSessionUpsertWithWhereUniqueWithoutLikesInput>
    set?: Enumerable<WritingSessionWhereUniqueInput>
    disconnect?: Enumerable<WritingSessionWhereUniqueInput>
    delete?: Enumerable<WritingSessionWhereUniqueInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
    update?: Enumerable<WritingSessionUpdateWithWhereUniqueWithoutLikesInput>
    updateMany?: Enumerable<WritingSessionUpdateManyWithWhereWithoutLikesInput>
    deleteMany?: Enumerable<WritingSessionScalarWhereInput>
  }

  export type UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutUserInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<UserEnhancedDocumentPermissionsUpsertWithWhereUniqueWithoutUserInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyUserInputEnvelope
    set?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    disconnect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    delete?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    update?: Enumerable<UserEnhancedDocumentPermissionsUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<UserEnhancedDocumentPermissionsUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereInput>
  }

  export type ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutUserInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ThreadAttributesUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ThreadAttributesCreateManyUserInputEnvelope
    set?: Enumerable<ThreadAttributesWhereUniqueInput>
    disconnect?: Enumerable<ThreadAttributesWhereUniqueInput>
    delete?: Enumerable<ThreadAttributesWhereUniqueInput>
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
    update?: Enumerable<ThreadAttributesUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ThreadAttributesUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ThreadAttributesScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutFollowingInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFollowedByInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFollowingNestedInput = {
    create?: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowingInput
    upsert?: UserUpsertWithoutFollowingInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
  }

  export type UserUpdateOneRequiredWithoutFollowedByNestedInput = {
    create?: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowedByInput
    upsert?: UserUpsertWithoutFollowedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
  }

  export type UserNotePermissionCreateNestedManyWithoutNoteInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutNoteInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutNoteInput>
    createMany?: UserNotePermissionCreateManyNoteInputEnvelope
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
  }

  export type DocumentCreateNestedOneWithoutNotesInput = {
    create?: XOR<DocumentCreateWithoutNotesInput, DocumentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutNotesInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserNotePermissionUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutNoteInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutNoteInput>
    createMany?: UserNotePermissionCreateManyNoteInputEnvelope
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserNotePermissionUpdateManyWithoutNoteNestedInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutNoteInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutNoteInput>
    upsert?: Enumerable<UserNotePermissionUpsertWithWhereUniqueWithoutNoteInput>
    createMany?: UserNotePermissionCreateManyNoteInputEnvelope
    set?: Enumerable<UserNotePermissionWhereUniqueInput>
    disconnect?: Enumerable<UserNotePermissionWhereUniqueInput>
    delete?: Enumerable<UserNotePermissionWhereUniqueInput>
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
    update?: Enumerable<UserNotePermissionUpdateWithWhereUniqueWithoutNoteInput>
    updateMany?: Enumerable<UserNotePermissionUpdateManyWithWhereWithoutNoteInput>
    deleteMany?: Enumerable<UserNotePermissionScalarWhereInput>
  }

  export type DocumentUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<DocumentCreateWithoutNotesInput, DocumentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutNotesInput
    upsert?: DocumentUpsertWithoutNotesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutNotesInput, DocumentUncheckedUpdateWithoutNotesInput>
  }

  export type UserNotePermissionUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<Enumerable<UserNotePermissionCreateWithoutNoteInput>, Enumerable<UserNotePermissionUncheckedCreateWithoutNoteInput>>
    connectOrCreate?: Enumerable<UserNotePermissionCreateOrConnectWithoutNoteInput>
    upsert?: Enumerable<UserNotePermissionUpsertWithWhereUniqueWithoutNoteInput>
    createMany?: UserNotePermissionCreateManyNoteInputEnvelope
    set?: Enumerable<UserNotePermissionWhereUniqueInput>
    disconnect?: Enumerable<UserNotePermissionWhereUniqueInput>
    delete?: Enumerable<UserNotePermissionWhereUniqueInput>
    connect?: Enumerable<UserNotePermissionWhereUniqueInput>
    update?: Enumerable<UserNotePermissionUpdateWithWhereUniqueWithoutNoteInput>
    updateMany?: Enumerable<UserNotePermissionUpdateManyWithWhereWithoutNoteInput>
    deleteMany?: Enumerable<UserNotePermissionScalarWhereInput>
  }

  export type CommentCreateNestedManyWithoutDocumentVersionInput = {
    create?: XOR<Enumerable<CommentCreateWithoutDocumentVersionInput>, Enumerable<CommentUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutDocumentVersionInput>
    createMany?: CommentCreateManyDocumentVersionInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserDocumentPermissionCreateNestedManyWithoutDocumentVersionInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentVersionInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentVersionInput>
    createMany?: UserDocumentPermissionCreateManyDocumentVersionInputEnvelope
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
  }

  export type DocumentCreateNestedOneWithoutDocumentVersionsInput = {
    create?: XOR<DocumentCreateWithoutDocumentVersionsInput, DocumentUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutDocumentVersionsInput
    connect?: DocumentWhereUniqueInput
  }

  export type DailyStatUnitCreateNestedManyWithoutDocumentVersionInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentVersionInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentVersionInput>
    createMany?: DailyStatUnitCreateManyDocumentVersionInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type UserDocumentAttributesCreateNestedManyWithoutLastOpenedDocumentVersionInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutLastOpenedDocumentVersionInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutLastOpenedDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutLastOpenedDocumentVersionInput>
    createMany?: UserDocumentAttributesCreateManyLastOpenedDocumentVersionInputEnvelope
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
  }

  export type CommentUncheckedCreateNestedManyWithoutDocumentVersionInput = {
    create?: XOR<Enumerable<CommentCreateWithoutDocumentVersionInput>, Enumerable<CommentUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutDocumentVersionInput>
    createMany?: CommentCreateManyDocumentVersionInputEnvelope
    connect?: Enumerable<CommentWhereUniqueInput>
  }

  export type UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentVersionInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentVersionInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentVersionInput>
    createMany?: UserDocumentPermissionCreateManyDocumentVersionInputEnvelope
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
  }

  export type DailyStatUnitUncheckedCreateNestedManyWithoutDocumentVersionInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentVersionInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentVersionInput>
    createMany?: DailyStatUnitCreateManyDocumentVersionInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type UserDocumentAttributesUncheckedCreateNestedManyWithoutLastOpenedDocumentVersionInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutLastOpenedDocumentVersionInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutLastOpenedDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutLastOpenedDocumentVersionInput>
    createMany?: UserDocumentAttributesCreateManyLastOpenedDocumentVersionInputEnvelope
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
  }

  export type CommentUpdateManyWithoutDocumentVersionNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutDocumentVersionInput>, Enumerable<CommentUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutDocumentVersionInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutDocumentVersionInput>
    createMany?: CommentCreateManyDocumentVersionInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutDocumentVersionInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutDocumentVersionInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserDocumentPermissionUpdateManyWithoutDocumentVersionNestedInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentVersionInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentVersionInput>
    upsert?: Enumerable<UserDocumentPermissionUpsertWithWhereUniqueWithoutDocumentVersionInput>
    createMany?: UserDocumentPermissionCreateManyDocumentVersionInputEnvelope
    set?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    delete?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    update?: Enumerable<UserDocumentPermissionUpdateWithWhereUniqueWithoutDocumentVersionInput>
    updateMany?: Enumerable<UserDocumentPermissionUpdateManyWithWhereWithoutDocumentVersionInput>
    deleteMany?: Enumerable<UserDocumentPermissionScalarWhereInput>
  }

  export type DocumentUpdateOneRequiredWithoutDocumentVersionsNestedInput = {
    create?: XOR<DocumentCreateWithoutDocumentVersionsInput, DocumentUncheckedCreateWithoutDocumentVersionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutDocumentVersionsInput
    upsert?: DocumentUpsertWithoutDocumentVersionsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutDocumentVersionsInput, DocumentUncheckedUpdateWithoutDocumentVersionsInput>
  }

  export type DailyStatUnitUpdateManyWithoutDocumentVersionNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentVersionInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentVersionInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutDocumentVersionInput>
    createMany?: DailyStatUnitCreateManyDocumentVersionInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutDocumentVersionInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutDocumentVersionInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type UserDocumentAttributesUpdateManyWithoutLastOpenedDocumentVersionNestedInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutLastOpenedDocumentVersionInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutLastOpenedDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutLastOpenedDocumentVersionInput>
    upsert?: Enumerable<UserDocumentAttributesUpsertWithWhereUniqueWithoutLastOpenedDocumentVersionInput>
    createMany?: UserDocumentAttributesCreateManyLastOpenedDocumentVersionInputEnvelope
    set?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    delete?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    update?: Enumerable<UserDocumentAttributesUpdateWithWhereUniqueWithoutLastOpenedDocumentVersionInput>
    updateMany?: Enumerable<UserDocumentAttributesUpdateManyWithWhereWithoutLastOpenedDocumentVersionInput>
    deleteMany?: Enumerable<UserDocumentAttributesScalarWhereInput>
  }

  export type CommentUncheckedUpdateManyWithoutDocumentVersionNestedInput = {
    create?: XOR<Enumerable<CommentCreateWithoutDocumentVersionInput>, Enumerable<CommentUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<CommentCreateOrConnectWithoutDocumentVersionInput>
    upsert?: Enumerable<CommentUpsertWithWhereUniqueWithoutDocumentVersionInput>
    createMany?: CommentCreateManyDocumentVersionInputEnvelope
    set?: Enumerable<CommentWhereUniqueInput>
    disconnect?: Enumerable<CommentWhereUniqueInput>
    delete?: Enumerable<CommentWhereUniqueInput>
    connect?: Enumerable<CommentWhereUniqueInput>
    update?: Enumerable<CommentUpdateWithWhereUniqueWithoutDocumentVersionInput>
    updateMany?: Enumerable<CommentUpdateManyWithWhereWithoutDocumentVersionInput>
    deleteMany?: Enumerable<CommentScalarWhereInput>
  }

  export type UserDocumentPermissionUncheckedUpdateManyWithoutDocumentVersionNestedInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentVersionInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentVersionInput>
    upsert?: Enumerable<UserDocumentPermissionUpsertWithWhereUniqueWithoutDocumentVersionInput>
    createMany?: UserDocumentPermissionCreateManyDocumentVersionInputEnvelope
    set?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    delete?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    update?: Enumerable<UserDocumentPermissionUpdateWithWhereUniqueWithoutDocumentVersionInput>
    updateMany?: Enumerable<UserDocumentPermissionUpdateManyWithWhereWithoutDocumentVersionInput>
    deleteMany?: Enumerable<UserDocumentPermissionScalarWhereInput>
  }

  export type DailyStatUnitUncheckedUpdateManyWithoutDocumentVersionNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentVersionInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentVersionInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentVersionInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutDocumentVersionInput>
    createMany?: DailyStatUnitCreateManyDocumentVersionInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutDocumentVersionInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutDocumentVersionInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type UserDocumentAttributesUncheckedUpdateManyWithoutLastOpenedDocumentVersionNestedInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutLastOpenedDocumentVersionInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutLastOpenedDocumentVersionInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutLastOpenedDocumentVersionInput>
    upsert?: Enumerable<UserDocumentAttributesUpsertWithWhereUniqueWithoutLastOpenedDocumentVersionInput>
    createMany?: UserDocumentAttributesCreateManyLastOpenedDocumentVersionInputEnvelope
    set?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    delete?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    update?: Enumerable<UserDocumentAttributesUpdateWithWhereUniqueWithoutLastOpenedDocumentVersionInput>
    updateMany?: Enumerable<UserDocumentAttributesUpdateManyWithWhereWithoutLastOpenedDocumentVersionInput>
    deleteMany?: Enumerable<UserDocumentAttributesScalarWhereInput>
  }

  export type DocumentVersionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<DocumentVersionCreateWithoutDocumentInput>, Enumerable<DocumentVersionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentVersionCreateOrConnectWithoutDocumentInput>
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    connect?: Enumerable<DocumentVersionWhereUniqueInput>
  }

  export type UserDocumentPermissionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentInput>
    createMany?: UserDocumentPermissionCreateManyDocumentInputEnvelope
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
  }

  export type NoteCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<NoteCreateWithoutDocumentInput>, Enumerable<NoteUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<NoteCreateOrConnectWithoutDocumentInput>
    createMany?: NoteCreateManyDocumentInputEnvelope
    connect?: Enumerable<NoteWhereUniqueInput>
  }

  export type DailyStatUnitCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentInput>
    createMany?: DailyStatUnitCreateManyDocumentInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type UserDocumentAttributesCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutDocumentInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutDocumentInput>
    createMany?: UserDocumentAttributesCreateManyDocumentInputEnvelope
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
  }

  export type PublishedDocumentCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutDocumentInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutDocumentInput>
    createMany?: PublishedDocumentCreateManyDocumentInputEnvelope
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
  }

  export type WritingSessionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutDocumentInput>, Enumerable<WritingSessionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutDocumentInput>
    createMany?: WritingSessionCreateManyDocumentInputEnvelope
    connect?: Enumerable<WritingSessionWhereUniqueInput>
  }

  export type DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<DocumentVersionCreateWithoutDocumentInput>, Enumerable<DocumentVersionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentVersionCreateOrConnectWithoutDocumentInput>
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    connect?: Enumerable<DocumentVersionWhereUniqueInput>
  }

  export type UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentInput>
    createMany?: UserDocumentPermissionCreateManyDocumentInputEnvelope
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
  }

  export type NoteUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<NoteCreateWithoutDocumentInput>, Enumerable<NoteUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<NoteCreateOrConnectWithoutDocumentInput>
    createMany?: NoteCreateManyDocumentInputEnvelope
    connect?: Enumerable<NoteWhereUniqueInput>
  }

  export type DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentInput>
    createMany?: DailyStatUnitCreateManyDocumentInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutDocumentInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutDocumentInput>
    createMany?: UserDocumentAttributesCreateManyDocumentInputEnvelope
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
  }

  export type PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutDocumentInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutDocumentInput>
    createMany?: PublishedDocumentCreateManyDocumentInputEnvelope
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
  }

  export type WritingSessionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutDocumentInput>, Enumerable<WritingSessionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutDocumentInput>
    createMany?: WritingSessionCreateManyDocumentInputEnvelope
    connect?: Enumerable<WritingSessionWhereUniqueInput>
  }

  export type DocumentVersionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<DocumentVersionCreateWithoutDocumentInput>, Enumerable<DocumentVersionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentVersionCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    set?: Enumerable<DocumentVersionWhereUniqueInput>
    disconnect?: Enumerable<DocumentVersionWhereUniqueInput>
    delete?: Enumerable<DocumentVersionWhereUniqueInput>
    connect?: Enumerable<DocumentVersionWhereUniqueInput>
    update?: Enumerable<DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<DocumentVersionUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<DocumentVersionScalarWhereInput>
  }

  export type UserDocumentPermissionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<UserDocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: UserDocumentPermissionCreateManyDocumentInputEnvelope
    set?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    delete?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    update?: Enumerable<UserDocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<UserDocumentPermissionUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<UserDocumentPermissionScalarWhereInput>
  }

  export type NoteUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<NoteCreateWithoutDocumentInput>, Enumerable<NoteUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<NoteCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<NoteUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: NoteCreateManyDocumentInputEnvelope
    set?: Enumerable<NoteWhereUniqueInput>
    disconnect?: Enumerable<NoteWhereUniqueInput>
    delete?: Enumerable<NoteWhereUniqueInput>
    connect?: Enumerable<NoteWhereUniqueInput>
    update?: Enumerable<NoteUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<NoteUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<NoteScalarWhereInput>
  }

  export type DailyStatUnitUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: DailyStatUnitCreateManyDocumentInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type UserDocumentAttributesUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutDocumentInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<UserDocumentAttributesUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: UserDocumentAttributesCreateManyDocumentInputEnvelope
    set?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    delete?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    update?: Enumerable<UserDocumentAttributesUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<UserDocumentAttributesUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<UserDocumentAttributesScalarWhereInput>
  }

  export type PublishedDocumentUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutDocumentInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<PublishedDocumentUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: PublishedDocumentCreateManyDocumentInputEnvelope
    set?: Enumerable<PublishedDocumentWhereUniqueInput>
    disconnect?: Enumerable<PublishedDocumentWhereUniqueInput>
    delete?: Enumerable<PublishedDocumentWhereUniqueInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
    update?: Enumerable<PublishedDocumentUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<PublishedDocumentUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<PublishedDocumentScalarWhereInput>
  }

  export type WritingSessionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutDocumentInput>, Enumerable<WritingSessionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<WritingSessionUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: WritingSessionCreateManyDocumentInputEnvelope
    set?: Enumerable<WritingSessionWhereUniqueInput>
    disconnect?: Enumerable<WritingSessionWhereUniqueInput>
    delete?: Enumerable<WritingSessionWhereUniqueInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
    update?: Enumerable<WritingSessionUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<WritingSessionUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<WritingSessionScalarWhereInput>
  }

  export type DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<DocumentVersionCreateWithoutDocumentInput>, Enumerable<DocumentVersionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DocumentVersionCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: DocumentVersionCreateManyDocumentInputEnvelope
    set?: Enumerable<DocumentVersionWhereUniqueInput>
    disconnect?: Enumerable<DocumentVersionWhereUniqueInput>
    delete?: Enumerable<DocumentVersionWhereUniqueInput>
    connect?: Enumerable<DocumentVersionWhereUniqueInput>
    update?: Enumerable<DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<DocumentVersionUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<DocumentVersionScalarWhereInput>
  }

  export type UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<UserDocumentPermissionCreateWithoutDocumentInput>, Enumerable<UserDocumentPermissionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentPermissionCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<UserDocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: UserDocumentPermissionCreateManyDocumentInputEnvelope
    set?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    delete?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    connect?: Enumerable<UserDocumentPermissionWhereUniqueInput>
    update?: Enumerable<UserDocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<UserDocumentPermissionUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<UserDocumentPermissionScalarWhereInput>
  }

  export type NoteUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<NoteCreateWithoutDocumentInput>, Enumerable<NoteUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<NoteCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<NoteUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: NoteCreateManyDocumentInputEnvelope
    set?: Enumerable<NoteWhereUniqueInput>
    disconnect?: Enumerable<NoteWhereUniqueInput>
    delete?: Enumerable<NoteWhereUniqueInput>
    connect?: Enumerable<NoteWhereUniqueInput>
    update?: Enumerable<NoteUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<NoteUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<NoteScalarWhereInput>
  }

  export type DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDocumentInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: DailyStatUnitCreateManyDocumentInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<UserDocumentAttributesCreateWithoutDocumentInput>, Enumerable<UserDocumentAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<UserDocumentAttributesCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<UserDocumentAttributesUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: UserDocumentAttributesCreateManyDocumentInputEnvelope
    set?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    disconnect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    delete?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    connect?: Enumerable<UserDocumentAttributesWhereUniqueInput>
    update?: Enumerable<UserDocumentAttributesUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<UserDocumentAttributesUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<UserDocumentAttributesScalarWhereInput>
  }

  export type PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<PublishedDocumentCreateWithoutDocumentInput>, Enumerable<PublishedDocumentUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<PublishedDocumentCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<PublishedDocumentUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: PublishedDocumentCreateManyDocumentInputEnvelope
    set?: Enumerable<PublishedDocumentWhereUniqueInput>
    disconnect?: Enumerable<PublishedDocumentWhereUniqueInput>
    delete?: Enumerable<PublishedDocumentWhereUniqueInput>
    connect?: Enumerable<PublishedDocumentWhereUniqueInput>
    update?: Enumerable<PublishedDocumentUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<PublishedDocumentUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<PublishedDocumentScalarWhereInput>
  }

  export type WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<WritingSessionCreateWithoutDocumentInput>, Enumerable<WritingSessionUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<WritingSessionCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<WritingSessionUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: WritingSessionCreateManyDocumentInputEnvelope
    set?: Enumerable<WritingSessionWhereUniqueInput>
    disconnect?: Enumerable<WritingSessionWhereUniqueInput>
    delete?: Enumerable<WritingSessionWhereUniqueInput>
    connect?: Enumerable<WritingSessionWhereUniqueInput>
    update?: Enumerable<WritingSessionUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<WritingSessionUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<WritingSessionScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutUserEnhancedDocumentPermissionsInput = {
    create?: XOR<UserCreateWithoutUserEnhancedDocumentPermissionsInput, UserUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEnhancedDocumentPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnhancedDocumentCreateNestedOneWithoutUserEnhancedDocumentPermissionsInput = {
    create?: XOR<EnhancedDocumentCreateWithoutUserEnhancedDocumentPermissionsInput, EnhancedDocumentUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
    connectOrCreate?: EnhancedDocumentCreateOrConnectWithoutUserEnhancedDocumentPermissionsInput
    connect?: EnhancedDocumentWhereUniqueInput
  }

  export type EnumEnhancedDocumentRoleFieldUpdateOperationsInput = {
    set?: EnhancedDocumentRole
  }

  export type UserUpdateOneRequiredWithoutUserEnhancedDocumentPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutUserEnhancedDocumentPermissionsInput, UserUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserEnhancedDocumentPermissionsInput
    upsert?: UserUpsertWithoutUserEnhancedDocumentPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserEnhancedDocumentPermissionsInput, UserUncheckedUpdateWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type EnhancedDocumentUpdateOneRequiredWithoutUserEnhancedDocumentPermissionsNestedInput = {
    create?: XOR<EnhancedDocumentCreateWithoutUserEnhancedDocumentPermissionsInput, EnhancedDocumentUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
    connectOrCreate?: EnhancedDocumentCreateOrConnectWithoutUserEnhancedDocumentPermissionsInput
    upsert?: EnhancedDocumentUpsertWithoutUserEnhancedDocumentPermissionsInput
    connect?: EnhancedDocumentWhereUniqueInput
    update?: XOR<EnhancedDocumentUpdateWithoutUserEnhancedDocumentPermissionsInput, EnhancedDocumentUncheckedUpdateWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type EnhancedDocumentCreateideasInput = {
    set: Enumerable<string>
  }

  export type UserEnhancedDocumentPermissionsCreateNestedManyWithoutEnhancedDocumentInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutEnhancedDocumentInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutEnhancedDocumentInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutEnhancedDocumentInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyEnhancedDocumentInputEnvelope
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
  }

  export type ThreadAttributesCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutDocumentInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutDocumentInput>
    createMany?: ThreadAttributesCreateManyDocumentInputEnvelope
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
  }

  export type UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutEnhancedDocumentInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutEnhancedDocumentInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutEnhancedDocumentInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutEnhancedDocumentInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyEnhancedDocumentInputEnvelope
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
  }

  export type ThreadAttributesUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutDocumentInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutDocumentInput>
    createMany?: ThreadAttributesCreateManyDocumentInputEnvelope
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
  }

  export type EnhancedDocumentUpdateideasInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type UserEnhancedDocumentPermissionsUpdateManyWithoutEnhancedDocumentNestedInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutEnhancedDocumentInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutEnhancedDocumentInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutEnhancedDocumentInput>
    upsert?: Enumerable<UserEnhancedDocumentPermissionsUpsertWithWhereUniqueWithoutEnhancedDocumentInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyEnhancedDocumentInputEnvelope
    set?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    disconnect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    delete?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    update?: Enumerable<UserEnhancedDocumentPermissionsUpdateWithWhereUniqueWithoutEnhancedDocumentInput>
    updateMany?: Enumerable<UserEnhancedDocumentPermissionsUpdateManyWithWhereWithoutEnhancedDocumentInput>
    deleteMany?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereInput>
  }

  export type ThreadAttributesUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutDocumentInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<ThreadAttributesUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: ThreadAttributesCreateManyDocumentInputEnvelope
    set?: Enumerable<ThreadAttributesWhereUniqueInput>
    disconnect?: Enumerable<ThreadAttributesWhereUniqueInput>
    delete?: Enumerable<ThreadAttributesWhereUniqueInput>
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
    update?: Enumerable<ThreadAttributesUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<ThreadAttributesUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<ThreadAttributesScalarWhereInput>
  }

  export type UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutEnhancedDocumentNestedInput = {
    create?: XOR<Enumerable<UserEnhancedDocumentPermissionsCreateWithoutEnhancedDocumentInput>, Enumerable<UserEnhancedDocumentPermissionsUncheckedCreateWithoutEnhancedDocumentInput>>
    connectOrCreate?: Enumerable<UserEnhancedDocumentPermissionsCreateOrConnectWithoutEnhancedDocumentInput>
    upsert?: Enumerable<UserEnhancedDocumentPermissionsUpsertWithWhereUniqueWithoutEnhancedDocumentInput>
    createMany?: UserEnhancedDocumentPermissionsCreateManyEnhancedDocumentInputEnvelope
    set?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    disconnect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    delete?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    connect?: Enumerable<UserEnhancedDocumentPermissionsWhereUniqueInput>
    update?: Enumerable<UserEnhancedDocumentPermissionsUpdateWithWhereUniqueWithoutEnhancedDocumentInput>
    updateMany?: Enumerable<UserEnhancedDocumentPermissionsUpdateManyWithWhereWithoutEnhancedDocumentInput>
    deleteMany?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereInput>
  }

  export type ThreadAttributesUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Enumerable<ThreadAttributesCreateWithoutDocumentInput>, Enumerable<ThreadAttributesUncheckedCreateWithoutDocumentInput>>
    connectOrCreate?: Enumerable<ThreadAttributesCreateOrConnectWithoutDocumentInput>
    upsert?: Enumerable<ThreadAttributesUpsertWithWhereUniqueWithoutDocumentInput>
    createMany?: ThreadAttributesCreateManyDocumentInputEnvelope
    set?: Enumerable<ThreadAttributesWhereUniqueInput>
    disconnect?: Enumerable<ThreadAttributesWhereUniqueInput>
    delete?: Enumerable<ThreadAttributesWhereUniqueInput>
    connect?: Enumerable<ThreadAttributesWhereUniqueInput>
    update?: Enumerable<ThreadAttributesUpdateWithWhereUniqueWithoutDocumentInput>
    updateMany?: Enumerable<ThreadAttributesUpdateManyWithWhereWithoutDocumentInput>
    deleteMany?: Enumerable<ThreadAttributesScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutThreadAttributesInput = {
    create?: XOR<UserCreateWithoutThreadAttributesInput, UserUncheckedCreateWithoutThreadAttributesInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadAttributesInput
    connect?: UserWhereUniqueInput
  }

  export type EnhancedDocumentCreateNestedOneWithoutThreadAttributesInput = {
    create?: XOR<EnhancedDocumentCreateWithoutThreadAttributesInput, EnhancedDocumentUncheckedCreateWithoutThreadAttributesInput>
    connectOrCreate?: EnhancedDocumentCreateOrConnectWithoutThreadAttributesInput
    connect?: EnhancedDocumentWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutThreadInput>, Enumerable<ChatMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutThreadInput>
    createMany?: ChatMessageCreateManyThreadInputEnvelope
    connect?: Enumerable<ChatMessageWhereUniqueInput>
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutThreadInput>, Enumerable<ChatMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutThreadInput>
    createMany?: ChatMessageCreateManyThreadInputEnvelope
    connect?: Enumerable<ChatMessageWhereUniqueInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutThreadAttributesNestedInput = {
    create?: XOR<UserCreateWithoutThreadAttributesInput, UserUncheckedCreateWithoutThreadAttributesInput>
    connectOrCreate?: UserCreateOrConnectWithoutThreadAttributesInput
    upsert?: UserUpsertWithoutThreadAttributesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutThreadAttributesInput, UserUncheckedUpdateWithoutThreadAttributesInput>
  }

  export type EnhancedDocumentUpdateOneRequiredWithoutThreadAttributesNestedInput = {
    create?: XOR<EnhancedDocumentCreateWithoutThreadAttributesInput, EnhancedDocumentUncheckedCreateWithoutThreadAttributesInput>
    connectOrCreate?: EnhancedDocumentCreateOrConnectWithoutThreadAttributesInput
    upsert?: EnhancedDocumentUpsertWithoutThreadAttributesInput
    connect?: EnhancedDocumentWhereUniqueInput
    update?: XOR<EnhancedDocumentUpdateWithoutThreadAttributesInput, EnhancedDocumentUncheckedUpdateWithoutThreadAttributesInput>
  }

  export type ChatMessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutThreadInput>, Enumerable<ChatMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<ChatMessageUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: ChatMessageCreateManyThreadInputEnvelope
    set?: Enumerable<ChatMessageWhereUniqueInput>
    disconnect?: Enumerable<ChatMessageWhereUniqueInput>
    delete?: Enumerable<ChatMessageWhereUniqueInput>
    connect?: Enumerable<ChatMessageWhereUniqueInput>
    update?: Enumerable<ChatMessageUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<ChatMessageUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<ChatMessageScalarWhereInput>
  }

  export type ChatMessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<Enumerable<ChatMessageCreateWithoutThreadInput>, Enumerable<ChatMessageUncheckedCreateWithoutThreadInput>>
    connectOrCreate?: Enumerable<ChatMessageCreateOrConnectWithoutThreadInput>
    upsert?: Enumerable<ChatMessageUpsertWithWhereUniqueWithoutThreadInput>
    createMany?: ChatMessageCreateManyThreadInputEnvelope
    set?: Enumerable<ChatMessageWhereUniqueInput>
    disconnect?: Enumerable<ChatMessageWhereUniqueInput>
    delete?: Enumerable<ChatMessageWhereUniqueInput>
    connect?: Enumerable<ChatMessageWhereUniqueInput>
    update?: Enumerable<ChatMessageUpdateWithWhereUniqueWithoutThreadInput>
    updateMany?: Enumerable<ChatMessageUpdateManyWithWhereWithoutThreadInput>
    deleteMany?: Enumerable<ChatMessageScalarWhereInput>
  }

  export type ThreadAttributesCreateNestedOneWithoutChatMessageInput = {
    create?: XOR<ThreadAttributesCreateWithoutChatMessageInput, ThreadAttributesUncheckedCreateWithoutChatMessageInput>
    connectOrCreate?: ThreadAttributesCreateOrConnectWithoutChatMessageInput
    connect?: ThreadAttributesWhereUniqueInput
  }

  export type EnumChatMessageAuthorFieldUpdateOperationsInput = {
    set?: ChatMessageAuthor
  }

  export type ThreadAttributesUpdateOneRequiredWithoutChatMessageNestedInput = {
    create?: XOR<ThreadAttributesCreateWithoutChatMessageInput, ThreadAttributesUncheckedCreateWithoutChatMessageInput>
    connectOrCreate?: ThreadAttributesCreateOrConnectWithoutChatMessageInput
    upsert?: ThreadAttributesUpsertWithoutChatMessageInput
    connect?: ThreadAttributesWhereUniqueInput
    update?: XOR<ThreadAttributesUpdateWithoutChatMessageInput, ThreadAttributesUncheckedUpdateWithoutChatMessageInput>
  }

  export type DocumentCreateNestedOneWithoutPublishedDocumentInput = {
    create?: XOR<DocumentCreateWithoutPublishedDocumentInput, DocumentUncheckedCreateWithoutPublishedDocumentInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPublishedDocumentInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPublishedDocumentInput = {
    create?: XOR<UserCreateWithoutPublishedDocumentInput, UserUncheckedCreateWithoutPublishedDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedDocumentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutPublishedDocumentLikesInput = {
    create?: XOR<Enumerable<UserCreateWithoutPublishedDocumentLikesInput>, Enumerable<UserUncheckedCreateWithoutPublishedDocumentLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPublishedDocumentLikesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutPublishedDocumentLikesInput = {
    create?: XOR<Enumerable<UserCreateWithoutPublishedDocumentLikesInput>, Enumerable<UserUncheckedCreateWithoutPublishedDocumentLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPublishedDocumentLikesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type DocumentUpdateOneRequiredWithoutPublishedDocumentNestedInput = {
    create?: XOR<DocumentCreateWithoutPublishedDocumentInput, DocumentUncheckedCreateWithoutPublishedDocumentInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutPublishedDocumentInput
    upsert?: DocumentUpsertWithoutPublishedDocumentInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutPublishedDocumentInput, DocumentUncheckedUpdateWithoutPublishedDocumentInput>
  }

  export type UserUpdateOneRequiredWithoutPublishedDocumentNestedInput = {
    create?: XOR<UserCreateWithoutPublishedDocumentInput, UserUncheckedCreateWithoutPublishedDocumentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublishedDocumentInput
    upsert?: UserUpsertWithoutPublishedDocumentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPublishedDocumentInput, UserUncheckedUpdateWithoutPublishedDocumentInput>
  }

  export type UserUpdateManyWithoutPublishedDocumentLikesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutPublishedDocumentLikesInput>, Enumerable<UserUncheckedCreateWithoutPublishedDocumentLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPublishedDocumentLikesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutPublishedDocumentLikesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutPublishedDocumentLikesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutPublishedDocumentLikesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutPublishedDocumentLikesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutPublishedDocumentLikesInput>, Enumerable<UserUncheckedCreateWithoutPublishedDocumentLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutPublishedDocumentLikesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutPublishedDocumentLikesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutPublishedDocumentLikesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutPublishedDocumentLikesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutScratchpadEntryInput = {
    create?: XOR<UserCreateWithoutScratchpadEntryInput, UserUncheckedCreateWithoutScratchpadEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutScratchpadEntryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutScratchpadEntryNestedInput = {
    create?: XOR<UserCreateWithoutScratchpadEntryInput, UserUncheckedCreateWithoutScratchpadEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutScratchpadEntryInput
    upsert?: UserUpsertWithoutScratchpadEntryInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutScratchpadEntryInput, UserUncheckedUpdateWithoutScratchpadEntryInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentVersionCreateNestedOneWithoutCommentsInput = {
    create?: XOR<DocumentVersionCreateWithoutCommentsInput, DocumentVersionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutCommentsInput
    connect?: DocumentVersionWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type DocumentVersionUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutCommentsInput, DocumentVersionUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutCommentsInput
    upsert?: DocumentVersionUpsertWithoutCommentsInput
    connect?: DocumentVersionWhereUniqueInput
    update?: XOR<DocumentVersionUpdateWithoutCommentsInput, DocumentVersionUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutUserDocumentPermissionsInput = {
    create?: XOR<UserCreateWithoutUserDocumentPermissionsInput, UserUncheckedCreateWithoutUserDocumentPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDocumentPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentVersionCreateNestedOneWithoutUserDocumentPermissionsInput = {
    create?: XOR<DocumentVersionCreateWithoutUserDocumentPermissionsInput, DocumentVersionUncheckedCreateWithoutUserDocumentPermissionsInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserDocumentPermissionsInput
    connect?: DocumentVersionWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutUserDocumentPermissionsInput = {
    create?: XOR<DocumentCreateWithoutUserDocumentPermissionsInput, DocumentUncheckedCreateWithoutUserDocumentPermissionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutUserDocumentPermissionsInput
    connect?: DocumentWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: Role
  }

  export type UserUpdateOneRequiredWithoutUserDocumentPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutUserDocumentPermissionsInput, UserUncheckedCreateWithoutUserDocumentPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDocumentPermissionsInput
    upsert?: UserUpsertWithoutUserDocumentPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserDocumentPermissionsInput, UserUncheckedUpdateWithoutUserDocumentPermissionsInput>
  }

  export type DocumentVersionUpdateOneWithoutUserDocumentPermissionsNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutUserDocumentPermissionsInput, DocumentVersionUncheckedCreateWithoutUserDocumentPermissionsInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserDocumentPermissionsInput
    upsert?: DocumentVersionUpsertWithoutUserDocumentPermissionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentVersionWhereUniqueInput
    update?: XOR<DocumentVersionUpdateWithoutUserDocumentPermissionsInput, DocumentVersionUncheckedUpdateWithoutUserDocumentPermissionsInput>
  }

  export type DocumentUpdateOneWithoutUserDocumentPermissionsNestedInput = {
    create?: XOR<DocumentCreateWithoutUserDocumentPermissionsInput, DocumentUncheckedCreateWithoutUserDocumentPermissionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutUserDocumentPermissionsInput
    upsert?: DocumentUpsertWithoutUserDocumentPermissionsInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutUserDocumentPermissionsInput, DocumentUncheckedUpdateWithoutUserDocumentPermissionsInput>
  }

  export type UserCreateNestedOneWithoutUserNotePermissionInput = {
    create?: XOR<UserCreateWithoutUserNotePermissionInput, UserUncheckedCreateWithoutUserNotePermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNotePermissionInput
    connect?: UserWhereUniqueInput
  }

  export type NoteCreateNestedOneWithoutUserNotePermissionsInput = {
    create?: XOR<NoteCreateWithoutUserNotePermissionsInput, NoteUncheckedCreateWithoutUserNotePermissionsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutUserNotePermissionsInput
    connect?: NoteWhereUniqueInput
  }

  export type EnumNoteRoleFieldUpdateOperationsInput = {
    set?: NoteRole
  }

  export type UserUpdateOneRequiredWithoutUserNotePermissionNestedInput = {
    create?: XOR<UserCreateWithoutUserNotePermissionInput, UserUncheckedCreateWithoutUserNotePermissionInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserNotePermissionInput
    upsert?: UserUpsertWithoutUserNotePermissionInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserNotePermissionInput, UserUncheckedUpdateWithoutUserNotePermissionInput>
  }

  export type NoteUpdateOneRequiredWithoutUserNotePermissionsNestedInput = {
    create?: XOR<NoteCreateWithoutUserNotePermissionsInput, NoteUncheckedCreateWithoutUserNotePermissionsInput>
    connectOrCreate?: NoteCreateOrConnectWithoutUserNotePermissionsInput
    upsert?: NoteUpsertWithoutUserNotePermissionsInput
    connect?: NoteWhereUniqueInput
    update?: XOR<NoteUpdateWithoutUserNotePermissionsInput, NoteUncheckedUpdateWithoutUserNotePermissionsInput>
  }

  export type DocumentCreateNestedOneWithoutUserDocumentAttributesInput = {
    create?: XOR<DocumentCreateWithoutUserDocumentAttributesInput, DocumentUncheckedCreateWithoutUserDocumentAttributesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutUserDocumentAttributesInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserDocumentAttributesInput = {
    create?: XOR<UserCreateWithoutUserDocumentAttributesInput, UserUncheckedCreateWithoutUserDocumentAttributesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDocumentAttributesInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentVersionCreateNestedOneWithoutUserDocumentAttributesInput = {
    create?: XOR<DocumentVersionCreateWithoutUserDocumentAttributesInput, DocumentVersionUncheckedCreateWithoutUserDocumentAttributesInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserDocumentAttributesInput
    connect?: DocumentVersionWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutUserDocumentAttributesNestedInput = {
    create?: XOR<DocumentCreateWithoutUserDocumentAttributesInput, DocumentUncheckedCreateWithoutUserDocumentAttributesInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutUserDocumentAttributesInput
    upsert?: DocumentUpsertWithoutUserDocumentAttributesInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutUserDocumentAttributesInput, DocumentUncheckedUpdateWithoutUserDocumentAttributesInput>
  }

  export type UserUpdateOneRequiredWithoutUserDocumentAttributesNestedInput = {
    create?: XOR<UserCreateWithoutUserDocumentAttributesInput, UserUncheckedCreateWithoutUserDocumentAttributesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserDocumentAttributesInput
    upsert?: UserUpsertWithoutUserDocumentAttributesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutUserDocumentAttributesInput, UserUncheckedUpdateWithoutUserDocumentAttributesInput>
  }

  export type DocumentVersionUpdateOneRequiredWithoutUserDocumentAttributesNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutUserDocumentAttributesInput, DocumentVersionUncheckedCreateWithoutUserDocumentAttributesInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserDocumentAttributesInput
    upsert?: DocumentVersionUpsertWithoutUserDocumentAttributesInput
    connect?: DocumentVersionWhereUniqueInput
    update?: XOR<DocumentVersionUpdateWithoutUserDocumentAttributesInput, DocumentVersionUncheckedUpdateWithoutUserDocumentAttributesInput>
  }

  export type UserCreateNestedOneWithoutStatUnitInput = {
    create?: XOR<UserCreateWithoutStatUnitInput, UserUncheckedCreateWithoutStatUnitInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatUnitInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentVersionCreateNestedOneWithoutStatUnitInput = {
    create?: XOR<DocumentVersionCreateWithoutStatUnitInput, DocumentVersionUncheckedCreateWithoutStatUnitInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutStatUnitInput
    connect?: DocumentVersionWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutStatUnitInput = {
    create?: XOR<DocumentCreateWithoutStatUnitInput, DocumentUncheckedCreateWithoutStatUnitInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutStatUnitInput
    connect?: DocumentWhereUniqueInput
  }

  export type DailyChallengeResponseCreateNestedOneWithoutDailyStatUnitInput = {
    create?: XOR<DailyChallengeResponseCreateWithoutDailyStatUnitInput, DailyChallengeResponseUncheckedCreateWithoutDailyStatUnitInput>
    connectOrCreate?: DailyChallengeResponseCreateOrConnectWithoutDailyStatUnitInput
    connect?: DailyChallengeResponseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStatUnitNestedInput = {
    create?: XOR<UserCreateWithoutStatUnitInput, UserUncheckedCreateWithoutStatUnitInput>
    connectOrCreate?: UserCreateOrConnectWithoutStatUnitInput
    upsert?: UserUpsertWithoutStatUnitInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutStatUnitInput, UserUncheckedUpdateWithoutStatUnitInput>
  }

  export type DocumentVersionUpdateOneWithoutStatUnitNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutStatUnitInput, DocumentVersionUncheckedCreateWithoutStatUnitInput>
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutStatUnitInput
    upsert?: DocumentVersionUpsertWithoutStatUnitInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentVersionWhereUniqueInput
    update?: XOR<DocumentVersionUpdateWithoutStatUnitInput, DocumentVersionUncheckedUpdateWithoutStatUnitInput>
  }

  export type DocumentUpdateOneWithoutStatUnitNestedInput = {
    create?: XOR<DocumentCreateWithoutStatUnitInput, DocumentUncheckedCreateWithoutStatUnitInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutStatUnitInput
    upsert?: DocumentUpsertWithoutStatUnitInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutStatUnitInput, DocumentUncheckedUpdateWithoutStatUnitInput>
  }

  export type DailyChallengeResponseUpdateOneWithoutDailyStatUnitNestedInput = {
    create?: XOR<DailyChallengeResponseCreateWithoutDailyStatUnitInput, DailyChallengeResponseUncheckedCreateWithoutDailyStatUnitInput>
    connectOrCreate?: DailyChallengeResponseCreateOrConnectWithoutDailyStatUnitInput
    upsert?: DailyChallengeResponseUpsertWithoutDailyStatUnitInput
    disconnect?: boolean
    delete?: boolean
    connect?: DailyChallengeResponseWhereUniqueInput
    update?: XOR<DailyChallengeResponseUpdateWithoutDailyStatUnitInput, DailyChallengeResponseUncheckedUpdateWithoutDailyStatUnitInput>
  }

  export type WritingSessionCreatesegmentTimeInput = {
    set: Enumerable<number>
  }

  export type UserCreateNestedOneWithoutWritingSessionsInput = {
    create?: XOR<UserCreateWithoutWritingSessionsInput, UserUncheckedCreateWithoutWritingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWritingSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutWritingSessionInput = {
    create?: XOR<DocumentCreateWithoutWritingSessionInput, DocumentUncheckedCreateWithoutWritingSessionInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutWritingSessionInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutWritingSessionLikesInput = {
    create?: XOR<Enumerable<UserCreateWithoutWritingSessionLikesInput>, Enumerable<UserUncheckedCreateWithoutWritingSessionLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWritingSessionLikesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutWritingSessionLikesInput = {
    create?: XOR<Enumerable<UserCreateWithoutWritingSessionLikesInput>, Enumerable<UserUncheckedCreateWithoutWritingSessionLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWritingSessionLikesInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type WritingSessionUpdatesegmentTimeInput = {
    set?: Enumerable<number>
    push?: number | Enumerable<number>
  }

  export type UserUpdateOneRequiredWithoutWritingSessionsNestedInput = {
    create?: XOR<UserCreateWithoutWritingSessionsInput, UserUncheckedCreateWithoutWritingSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWritingSessionsInput
    upsert?: UserUpsertWithoutWritingSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWritingSessionsInput, UserUncheckedUpdateWithoutWritingSessionsInput>
  }

  export type DocumentUpdateOneWithoutWritingSessionNestedInput = {
    create?: XOR<DocumentCreateWithoutWritingSessionInput, DocumentUncheckedCreateWithoutWritingSessionInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutWritingSessionInput
    upsert?: DocumentUpsertWithoutWritingSessionInput
    disconnect?: boolean
    delete?: boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<DocumentUpdateWithoutWritingSessionInput, DocumentUncheckedUpdateWithoutWritingSessionInput>
  }

  export type UserUpdateManyWithoutWritingSessionLikesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutWritingSessionLikesInput>, Enumerable<UserUncheckedCreateWithoutWritingSessionLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWritingSessionLikesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutWritingSessionLikesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutWritingSessionLikesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutWritingSessionLikesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutWritingSessionLikesNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutWritingSessionLikesInput>, Enumerable<UserUncheckedCreateWithoutWritingSessionLikesInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutWritingSessionLikesInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutWritingSessionLikesInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutWritingSessionLikesInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutWritingSessionLikesInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type DailyChallengeResponseCreateNestedManyWithoutDailyChallengeInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutDailyChallengeInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutDailyChallengeInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutDailyChallengeInput>
    createMany?: DailyChallengeResponseCreateManyDailyChallengeInputEnvelope
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
  }

  export type DailyChallengeResponseUncheckedCreateNestedManyWithoutDailyChallengeInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutDailyChallengeInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutDailyChallengeInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutDailyChallengeInput>
    createMany?: DailyChallengeResponseCreateManyDailyChallengeInputEnvelope
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
  }

  export type DailyChallengeResponseUpdateManyWithoutDailyChallengeNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutDailyChallengeInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutDailyChallengeInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutDailyChallengeInput>
    upsert?: Enumerable<DailyChallengeResponseUpsertWithWhereUniqueWithoutDailyChallengeInput>
    createMany?: DailyChallengeResponseCreateManyDailyChallengeInputEnvelope
    set?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseUpdateWithWhereUniqueWithoutDailyChallengeInput>
    updateMany?: Enumerable<DailyChallengeResponseUpdateManyWithWhereWithoutDailyChallengeInput>
    deleteMany?: Enumerable<DailyChallengeResponseScalarWhereInput>
  }

  export type DailyChallengeResponseUncheckedUpdateManyWithoutDailyChallengeNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseCreateWithoutDailyChallengeInput>, Enumerable<DailyChallengeResponseUncheckedCreateWithoutDailyChallengeInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseCreateOrConnectWithoutDailyChallengeInput>
    upsert?: Enumerable<DailyChallengeResponseUpsertWithWhereUniqueWithoutDailyChallengeInput>
    createMany?: DailyChallengeResponseCreateManyDailyChallengeInputEnvelope
    set?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseUpdateWithWhereUniqueWithoutDailyChallengeInput>
    updateMany?: Enumerable<DailyChallengeResponseUpdateManyWithWhereWithoutDailyChallengeInput>
    deleteMany?: Enumerable<DailyChallengeResponseScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDailyChallengeResponseLikesInput = {
    create?: XOR<UserCreateWithoutDailyChallengeResponseLikesInput, UserUncheckedCreateWithoutDailyChallengeResponseLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengeResponseLikesInput
    connect?: UserWhereUniqueInput
  }

  export type DailyChallengeResponseCreateNestedOneWithoutLikesInput = {
    create?: XOR<DailyChallengeResponseCreateWithoutLikesInput, DailyChallengeResponseUncheckedCreateWithoutLikesInput>
    connectOrCreate?: DailyChallengeResponseCreateOrConnectWithoutLikesInput
    connect?: DailyChallengeResponseWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyChallengeResponseLikesNestedInput = {
    create?: XOR<UserCreateWithoutDailyChallengeResponseLikesInput, UserUncheckedCreateWithoutDailyChallengeResponseLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengeResponseLikesInput
    upsert?: UserUpsertWithoutDailyChallengeResponseLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDailyChallengeResponseLikesInput, UserUncheckedUpdateWithoutDailyChallengeResponseLikesInput>
  }

  export type DailyChallengeResponseUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<DailyChallengeResponseCreateWithoutLikesInput, DailyChallengeResponseUncheckedCreateWithoutLikesInput>
    connectOrCreate?: DailyChallengeResponseCreateOrConnectWithoutLikesInput
    upsert?: DailyChallengeResponseUpsertWithoutLikesInput
    connect?: DailyChallengeResponseWhereUniqueInput
    update?: XOR<DailyChallengeResponseUpdateWithoutLikesInput, DailyChallengeResponseUncheckedUpdateWithoutLikesInput>
  }

  export type UserCreateNestedOneWithoutDailyChallengeResponseInput = {
    create?: XOR<UserCreateWithoutDailyChallengeResponseInput, UserUncheckedCreateWithoutDailyChallengeResponseInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengeResponseInput
    connect?: UserWhereUniqueInput
  }

  export type DailyChallengeResponseLikesCreateNestedManyWithoutDailyChallengeResponseInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutDailyChallengeResponseInput>
    createMany?: DailyChallengeResponseLikesCreateManyDailyChallengeResponseInputEnvelope
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
  }

  export type DailyChallengeCreateNestedOneWithoutDailyChallengeResponseInput = {
    create?: XOR<DailyChallengeCreateWithoutDailyChallengeResponseInput, DailyChallengeUncheckedCreateWithoutDailyChallengeResponseInput>
    connectOrCreate?: DailyChallengeCreateOrConnectWithoutDailyChallengeResponseInput
    connect?: DailyChallengeWhereUniqueInput
  }

  export type DailyStatUnitCreateNestedManyWithoutDailyChallengeResponseInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDailyChallengeResponseInput>
    createMany?: DailyStatUnitCreateManyDailyChallengeResponseInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutDailyChallengeResponseInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutDailyChallengeResponseInput>
    createMany?: DailyChallengeResponseLikesCreateManyDailyChallengeResponseInputEnvelope
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
  }

  export type DailyStatUnitUncheckedCreateNestedManyWithoutDailyChallengeResponseInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDailyChallengeResponseInput>
    createMany?: DailyStatUnitCreateManyDailyChallengeResponseInputEnvelope
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
  }

  export type UserUpdateOneWithoutDailyChallengeResponseNestedInput = {
    create?: XOR<UserCreateWithoutDailyChallengeResponseInput, UserUncheckedCreateWithoutDailyChallengeResponseInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengeResponseInput
    upsert?: UserUpsertWithoutDailyChallengeResponseInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDailyChallengeResponseInput, UserUncheckedUpdateWithoutDailyChallengeResponseInput>
  }

  export type DailyChallengeResponseLikesUpdateManyWithoutDailyChallengeResponseNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutDailyChallengeResponseInput>
    upsert?: Enumerable<DailyChallengeResponseLikesUpsertWithWhereUniqueWithoutDailyChallengeResponseInput>
    createMany?: DailyChallengeResponseLikesCreateManyDailyChallengeResponseInputEnvelope
    set?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseLikesUpdateWithWhereUniqueWithoutDailyChallengeResponseInput>
    updateMany?: Enumerable<DailyChallengeResponseLikesUpdateManyWithWhereWithoutDailyChallengeResponseInput>
    deleteMany?: Enumerable<DailyChallengeResponseLikesScalarWhereInput>
  }

  export type DailyChallengeUpdateOneRequiredWithoutDailyChallengeResponseNestedInput = {
    create?: XOR<DailyChallengeCreateWithoutDailyChallengeResponseInput, DailyChallengeUncheckedCreateWithoutDailyChallengeResponseInput>
    connectOrCreate?: DailyChallengeCreateOrConnectWithoutDailyChallengeResponseInput
    upsert?: DailyChallengeUpsertWithoutDailyChallengeResponseInput
    connect?: DailyChallengeWhereUniqueInput
    update?: XOR<DailyChallengeUpdateWithoutDailyChallengeResponseInput, DailyChallengeUncheckedUpdateWithoutDailyChallengeResponseInput>
  }

  export type DailyStatUnitUpdateManyWithoutDailyChallengeResponseNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDailyChallengeResponseInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutDailyChallengeResponseInput>
    createMany?: DailyStatUnitCreateManyDailyChallengeResponseInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutDailyChallengeResponseInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutDailyChallengeResponseInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type DailyChallengeResponseLikesUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput = {
    create?: XOR<Enumerable<DailyChallengeResponseLikesCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyChallengeResponseLikesUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyChallengeResponseLikesCreateOrConnectWithoutDailyChallengeResponseInput>
    upsert?: Enumerable<DailyChallengeResponseLikesUpsertWithWhereUniqueWithoutDailyChallengeResponseInput>
    createMany?: DailyChallengeResponseLikesCreateManyDailyChallengeResponseInputEnvelope
    set?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    disconnect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    delete?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    connect?: Enumerable<DailyChallengeResponseLikesWhereUniqueInput>
    update?: Enumerable<DailyChallengeResponseLikesUpdateWithWhereUniqueWithoutDailyChallengeResponseInput>
    updateMany?: Enumerable<DailyChallengeResponseLikesUpdateManyWithWhereWithoutDailyChallengeResponseInput>
    deleteMany?: Enumerable<DailyChallengeResponseLikesScalarWhereInput>
  }

  export type DailyStatUnitUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput = {
    create?: XOR<Enumerable<DailyStatUnitCreateWithoutDailyChallengeResponseInput>, Enumerable<DailyStatUnitUncheckedCreateWithoutDailyChallengeResponseInput>>
    connectOrCreate?: Enumerable<DailyStatUnitCreateOrConnectWithoutDailyChallengeResponseInput>
    upsert?: Enumerable<DailyStatUnitUpsertWithWhereUniqueWithoutDailyChallengeResponseInput>
    createMany?: DailyStatUnitCreateManyDailyChallengeResponseInputEnvelope
    set?: Enumerable<DailyStatUnitWhereUniqueInput>
    disconnect?: Enumerable<DailyStatUnitWhereUniqueInput>
    delete?: Enumerable<DailyStatUnitWhereUniqueInput>
    connect?: Enumerable<DailyStatUnitWhereUniqueInput>
    update?: Enumerable<DailyStatUnitUpdateWithWhereUniqueWithoutDailyChallengeResponseInput>
    updateMany?: Enumerable<DailyStatUnitUpdateManyWithWhereWithoutDailyChallengeResponseInput>
    deleteMany?: Enumerable<DailyStatUnitScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutDailyChallengePromptSuggestionInput = {
    create?: XOR<UserCreateWithoutDailyChallengePromptSuggestionInput, UserUncheckedCreateWithoutDailyChallengePromptSuggestionInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengePromptSuggestionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyChallengePromptSuggestionNestedInput = {
    create?: XOR<UserCreateWithoutDailyChallengePromptSuggestionInput, UserUncheckedCreateWithoutDailyChallengePromptSuggestionInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyChallengePromptSuggestionInput
    upsert?: UserUpsertWithoutDailyChallengePromptSuggestionInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutDailyChallengePromptSuggestionInput, UserUncheckedUpdateWithoutDailyChallengePromptSuggestionInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }
  export type NestedJsonNullableFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase>, Exclude<keyof Required<NestedJsonNullableFilterBase>, 'path'>>,
        Required<NestedJsonNullableFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase>, 'path'>>

  export type NestedJsonNullableFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedEnumEnhancedDocumentRoleFilter = {
    equals?: EnhancedDocumentRole
    in?: Enumerable<EnhancedDocumentRole>
    notIn?: Enumerable<EnhancedDocumentRole>
    not?: NestedEnumEnhancedDocumentRoleFilter | EnhancedDocumentRole
  }

  export type NestedEnumEnhancedDocumentRoleWithAggregatesFilter = {
    equals?: EnhancedDocumentRole
    in?: Enumerable<EnhancedDocumentRole>
    notIn?: Enumerable<EnhancedDocumentRole>
    not?: NestedEnumEnhancedDocumentRoleWithAggregatesFilter | EnhancedDocumentRole
    _count?: NestedIntFilter
    _min?: NestedEnumEnhancedDocumentRoleFilter
    _max?: NestedEnumEnhancedDocumentRoleFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: string[]
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedEnumChatMessageAuthorFilter = {
    equals?: ChatMessageAuthor
    in?: Enumerable<ChatMessageAuthor>
    notIn?: Enumerable<ChatMessageAuthor>
    not?: NestedEnumChatMessageAuthorFilter | ChatMessageAuthor
  }

  export type NestedEnumChatMessageAuthorWithAggregatesFilter = {
    equals?: ChatMessageAuthor
    in?: Enumerable<ChatMessageAuthor>
    notIn?: Enumerable<ChatMessageAuthor>
    not?: NestedEnumChatMessageAuthorWithAggregatesFilter | ChatMessageAuthor
    _count?: NestedIntFilter
    _min?: NestedEnumChatMessageAuthorFilter
    _max?: NestedEnumChatMessageAuthorFilter
  }

  export type NestedEnumRoleFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleFilter | Role
  }

  export type NestedEnumRoleWithAggregatesFilter = {
    equals?: Role
    in?: Enumerable<Role>
    notIn?: Enumerable<Role>
    not?: NestedEnumRoleWithAggregatesFilter | Role
    _count?: NestedIntFilter
    _min?: NestedEnumRoleFilter
    _max?: NestedEnumRoleFilter
  }

  export type NestedEnumNoteRoleFilter = {
    equals?: NoteRole
    in?: Enumerable<NoteRole>
    notIn?: Enumerable<NoteRole>
    not?: NestedEnumNoteRoleFilter | NoteRole
  }

  export type NestedEnumNoteRoleWithAggregatesFilter = {
    equals?: NoteRole
    in?: Enumerable<NoteRole>
    notIn?: Enumerable<NoteRole>
    not?: NestedEnumNoteRoleWithAggregatesFilter | NoteRole
    _count?: NestedIntFilter
    _min?: NestedEnumNoteRoleFilter
    _max?: NestedEnumNoteRoleFilter
  }

  export type CommentCreateWithoutAuthorInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
    documentVersion: DocumentVersionCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    documentVersionID: string
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: Enumerable<CommentCreateManyAuthorInput>
    skipDuplicates?: boolean
  }

  export type UserDocumentPermissionCreateWithoutUserInput = {
    userDocumentPermissionID?: string
    role: Role
    documentVersion?: DocumentVersionCreateNestedOneWithoutUserDocumentPermissionsInput
    document?: DocumentCreateNestedOneWithoutUserDocumentPermissionsInput
  }

  export type UserDocumentPermissionUncheckedCreateWithoutUserInput = {
    userDocumentPermissionID?: string
    documentVersionID?: string | null
    role: Role
    documentID?: string | null
  }

  export type UserDocumentPermissionCreateOrConnectWithoutUserInput = {
    where: UserDocumentPermissionWhereUniqueInput
    create: XOR<UserDocumentPermissionCreateWithoutUserInput, UserDocumentPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentPermissionCreateManyUserInputEnvelope = {
    data: Enumerable<UserDocumentPermissionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserNotePermissionCreateWithoutUserInput = {
    userNotePermissionID?: string
    role: NoteRole
    note: NoteCreateNestedOneWithoutUserNotePermissionsInput
  }

  export type UserNotePermissionUncheckedCreateWithoutUserInput = {
    userNotePermissionID?: string
    role: NoteRole
    noteID: string
  }

  export type UserNotePermissionCreateOrConnectWithoutUserInput = {
    where: UserNotePermissionWhereUniqueInput
    create: XOR<UserNotePermissionCreateWithoutUserInput, UserNotePermissionUncheckedCreateWithoutUserInput>
  }

  export type UserNotePermissionCreateManyUserInputEnvelope = {
    data: Enumerable<UserNotePermissionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DailyStatUnitCreateWithoutUserInput = {
    dailyStatUnitID?: string
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
    documentVersion?: DocumentVersionCreateNestedOneWithoutStatUnitInput
    document?: DocumentCreateNestedOneWithoutStatUnitInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedOneWithoutDailyStatUnitInput
  }

  export type DailyStatUnitUncheckedCreateWithoutUserInput = {
    dailyStatUnitID?: string
    documentVersionID?: string | null
    documentID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type DailyStatUnitCreateOrConnectWithoutUserInput = {
    where: DailyStatUnitWhereUniqueInput
    create: XOR<DailyStatUnitCreateWithoutUserInput, DailyStatUnitUncheckedCreateWithoutUserInput>
  }

  export type DailyStatUnitCreateManyUserInputEnvelope = {
    data: Enumerable<DailyStatUnitCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ScratchpadEntryCreateWithoutUserInput = {
    scratchpadEntryID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    date: Date | string
  }

  export type ScratchpadEntryUncheckedCreateWithoutUserInput = {
    scratchpadEntryID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    date: Date | string
  }

  export type ScratchpadEntryCreateOrConnectWithoutUserInput = {
    where: ScratchpadEntryWhereUniqueInput
    create: XOR<ScratchpadEntryCreateWithoutUserInput, ScratchpadEntryUncheckedCreateWithoutUserInput>
  }

  export type ScratchpadEntryCreateManyUserInputEnvelope = {
    data: Enumerable<ScratchpadEntryCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type UserDocumentAttributesCreateWithoutUserInput = {
    document: DocumentCreateNestedOneWithoutUserDocumentAttributesInput
    lastOpenedDocumentVersion: DocumentVersionCreateNestedOneWithoutUserDocumentAttributesInput
  }

  export type UserDocumentAttributesUncheckedCreateWithoutUserInput = {
    documentID: string
    lastOpenedDocumentVersionID: string
  }

  export type UserDocumentAttributesCreateOrConnectWithoutUserInput = {
    where: UserDocumentAttributesWhereUniqueInput
    create: XOR<UserDocumentAttributesCreateWithoutUserInput, UserDocumentAttributesUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentAttributesCreateManyUserInputEnvelope = {
    data: Enumerable<UserDocumentAttributesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DailyChallengeResponseCreateWithoutUserInput = {
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    likes?: DailyChallengeResponseLikesCreateNestedManyWithoutDailyChallengeResponseInput
    dailyChallenge: DailyChallengeCreateNestedOneWithoutDailyChallengeResponseInput
    dailyStatUnit?: DailyStatUnitCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseUncheckedCreateWithoutUserInput = {
    dailyChallengeID: number
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    likes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
    dailyStatUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseCreateOrConnectWithoutUserInput = {
    where: DailyChallengeResponseWhereUniqueInput
    create: XOR<DailyChallengeResponseCreateWithoutUserInput, DailyChallengeResponseUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengeResponseCreateManyUserInputEnvelope = {
    data: Enumerable<DailyChallengeResponseCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DailyChallengeResponseLikesCreateWithoutUserInput = {
    likeID?: string
    dailyChallengeResponse: DailyChallengeResponseCreateNestedOneWithoutLikesInput
  }

  export type DailyChallengeResponseLikesUncheckedCreateWithoutUserInput = {
    dailyChallengeResponseID: string
    likeID?: string
  }

  export type DailyChallengeResponseLikesCreateOrConnectWithoutUserInput = {
    where: DailyChallengeResponseLikesWhereUniqueInput
    create: XOR<DailyChallengeResponseLikesCreateWithoutUserInput, DailyChallengeResponseLikesUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengeResponseLikesCreateManyUserInputEnvelope = {
    data: Enumerable<DailyChallengeResponseLikesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type DailyChallengePromptSuggestionCreateWithoutUserInput = {
    promptSuggestionID?: string
    prompt: string
    createdAt?: Date | string
    usedOn?: Date | string | null
  }

  export type DailyChallengePromptSuggestionUncheckedCreateWithoutUserInput = {
    promptSuggestionID?: string
    prompt: string
    createdAt?: Date | string
    usedOn?: Date | string | null
  }

  export type DailyChallengePromptSuggestionCreateOrConnectWithoutUserInput = {
    where: DailyChallengePromptSuggestionWhereUniqueInput
    create: XOR<DailyChallengePromptSuggestionCreateWithoutUserInput, DailyChallengePromptSuggestionUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengePromptSuggestionCreateManyUserInputEnvelope = {
    data: Enumerable<DailyChallengePromptSuggestionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FollowsCreateWithoutFollowingInput = {
    follower: UserCreateNestedOneWithoutFollowingInput
  }

  export type FollowsUncheckedCreateWithoutFollowingInput = {
    followerID: string
  }

  export type FollowsCreateOrConnectWithoutFollowingInput = {
    where: FollowsWhereUniqueInput
    create: XOR<FollowsCreateWithoutFollowingInput, FollowsUncheckedCreateWithoutFollowingInput>
  }

  export type FollowsCreateManyFollowingInputEnvelope = {
    data: Enumerable<FollowsCreateManyFollowingInput>
    skipDuplicates?: boolean
  }

  export type FollowsCreateWithoutFollowerInput = {
    following: UserCreateNestedOneWithoutFollowedByInput
  }

  export type FollowsUncheckedCreateWithoutFollowerInput = {
    followingID: string
  }

  export type FollowsCreateOrConnectWithoutFollowerInput = {
    where: FollowsWhereUniqueInput
    create: XOR<FollowsCreateWithoutFollowerInput, FollowsUncheckedCreateWithoutFollowerInput>
  }

  export type FollowsCreateManyFollowerInputEnvelope = {
    data: Enumerable<FollowsCreateManyFollowerInput>
    skipDuplicates?: boolean
  }

  export type PublishedDocumentCreateWithoutUserInput = {
    publishedDocumentID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
    document: DocumentCreateNestedOneWithoutPublishedDocumentInput
    likingUsers?: UserCreateNestedManyWithoutPublishedDocumentLikesInput
  }

  export type PublishedDocumentUncheckedCreateWithoutUserInput = {
    publishedDocumentID?: string
    documentID: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
    likingUsers?: UserUncheckedCreateNestedManyWithoutPublishedDocumentLikesInput
  }

  export type PublishedDocumentCreateOrConnectWithoutUserInput = {
    where: PublishedDocumentWhereUniqueInput
    create: XOR<PublishedDocumentCreateWithoutUserInput, PublishedDocumentUncheckedCreateWithoutUserInput>
  }

  export type PublishedDocumentCreateManyUserInputEnvelope = {
    data: Enumerable<PublishedDocumentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PublishedDocumentCreateWithoutLikingUsersInput = {
    publishedDocumentID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
    document: DocumentCreateNestedOneWithoutPublishedDocumentInput
    user: UserCreateNestedOneWithoutPublishedDocumentInput
  }

  export type PublishedDocumentUncheckedCreateWithoutLikingUsersInput = {
    publishedDocumentID?: string
    documentID: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    userID: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
  }

  export type PublishedDocumentCreateOrConnectWithoutLikingUsersInput = {
    where: PublishedDocumentWhereUniqueInput
    create: XOR<PublishedDocumentCreateWithoutLikingUsersInput, PublishedDocumentUncheckedCreateWithoutLikingUsersInput>
  }

  export type WritingSessionCreateWithoutUserInput = {
    writingSessionID?: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    inProgress?: boolean
    updatedAt?: Date | string
    document?: DocumentCreateNestedOneWithoutWritingSessionInput
    likes?: UserCreateNestedManyWithoutWritingSessionLikesInput
  }

  export type WritingSessionUncheckedCreateWithoutUserInput = {
    writingSessionID?: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    documentID?: string | null
    inProgress?: boolean
    updatedAt?: Date | string
    likes?: UserUncheckedCreateNestedManyWithoutWritingSessionLikesInput
  }

  export type WritingSessionCreateOrConnectWithoutUserInput = {
    where: WritingSessionWhereUniqueInput
    create: XOR<WritingSessionCreateWithoutUserInput, WritingSessionUncheckedCreateWithoutUserInput>
  }

  export type WritingSessionCreateManyUserInputEnvelope = {
    data: Enumerable<WritingSessionCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WritingSessionCreateWithoutLikesInput = {
    writingSessionID?: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    inProgress?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWritingSessionsInput
    document?: DocumentCreateNestedOneWithoutWritingSessionInput
  }

  export type WritingSessionUncheckedCreateWithoutLikesInput = {
    writingSessionID?: string
    userID: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    documentID?: string | null
    inProgress?: boolean
    updatedAt?: Date | string
  }

  export type WritingSessionCreateOrConnectWithoutLikesInput = {
    where: WritingSessionWhereUniqueInput
    create: XOR<WritingSessionCreateWithoutLikesInput, WritingSessionUncheckedCreateWithoutLikesInput>
  }

  export type UserEnhancedDocumentPermissionsCreateWithoutUserInput = {
    role: EnhancedDocumentRole
    enhancedDocument: EnhancedDocumentCreateNestedOneWithoutUserEnhancedDocumentPermissionsInput
  }

  export type UserEnhancedDocumentPermissionsUncheckedCreateWithoutUserInput = {
    enhancedDocumentID: string
    role: EnhancedDocumentRole
  }

  export type UserEnhancedDocumentPermissionsCreateOrConnectWithoutUserInput = {
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
    create: XOR<UserEnhancedDocumentPermissionsCreateWithoutUserInput, UserEnhancedDocumentPermissionsUncheckedCreateWithoutUserInput>
  }

  export type UserEnhancedDocumentPermissionsCreateManyUserInputEnvelope = {
    data: Enumerable<UserEnhancedDocumentPermissionsCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ThreadAttributesCreateWithoutUserInput = {
    threadID?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    document: EnhancedDocumentCreateNestedOneWithoutThreadAttributesInput
    chatMessage?: ChatMessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadAttributesUncheckedCreateWithoutUserInput = {
    threadID?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    enhancedDocumentID: string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    chatMessage?: ChatMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadAttributesCreateOrConnectWithoutUserInput = {
    where: ThreadAttributesWhereUniqueInput
    create: XOR<ThreadAttributesCreateWithoutUserInput, ThreadAttributesUncheckedCreateWithoutUserInput>
  }

  export type ThreadAttributesCreateManyUserInputEnvelope = {
    data: Enumerable<ThreadAttributesCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type CommentScalarWhereInput = {
    AND?: Enumerable<CommentScalarWhereInput>
    OR?: Enumerable<CommentScalarWhereInput>
    NOT?: Enumerable<CommentScalarWhereInput>
    commentID?: StringFilter | string
    commentData?: JsonFilter
    authorID?: StringFilter | string
    documentVersionID?: StringFilter | string
    updatedAt?: DateTimeFilter | Date | string
    private?: BoolFilter | boolean
    resolved?: BoolFilter | boolean
    selectedText?: StringFilter | string
  }

  export type UserDocumentPermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDocumentPermissionWhereUniqueInput
    update: XOR<UserDocumentPermissionUpdateWithoutUserInput, UserDocumentPermissionUncheckedUpdateWithoutUserInput>
    create: XOR<UserDocumentPermissionCreateWithoutUserInput, UserDocumentPermissionUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentPermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDocumentPermissionWhereUniqueInput
    data: XOR<UserDocumentPermissionUpdateWithoutUserInput, UserDocumentPermissionUncheckedUpdateWithoutUserInput>
  }

  export type UserDocumentPermissionUpdateManyWithWhereWithoutUserInput = {
    where: UserDocumentPermissionScalarWhereInput
    data: XOR<UserDocumentPermissionUpdateManyMutationInput, UserDocumentPermissionUncheckedUpdateManyWithoutUserDocumentPermissionsInput>
  }

  export type UserDocumentPermissionScalarWhereInput = {
    AND?: Enumerable<UserDocumentPermissionScalarWhereInput>
    OR?: Enumerable<UserDocumentPermissionScalarWhereInput>
    NOT?: Enumerable<UserDocumentPermissionScalarWhereInput>
    userDocumentPermissionID?: StringFilter | string
    userID?: StringFilter | string
    documentVersionID?: StringNullableFilter | string | null
    role?: EnumRoleFilter | Role
    documentID?: StringNullableFilter | string | null
  }

  export type UserNotePermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNotePermissionWhereUniqueInput
    update: XOR<UserNotePermissionUpdateWithoutUserInput, UserNotePermissionUncheckedUpdateWithoutUserInput>
    create: XOR<UserNotePermissionCreateWithoutUserInput, UserNotePermissionUncheckedCreateWithoutUserInput>
  }

  export type UserNotePermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNotePermissionWhereUniqueInput
    data: XOR<UserNotePermissionUpdateWithoutUserInput, UserNotePermissionUncheckedUpdateWithoutUserInput>
  }

  export type UserNotePermissionUpdateManyWithWhereWithoutUserInput = {
    where: UserNotePermissionScalarWhereInput
    data: XOR<UserNotePermissionUpdateManyMutationInput, UserNotePermissionUncheckedUpdateManyWithoutUserNotePermissionInput>
  }

  export type UserNotePermissionScalarWhereInput = {
    AND?: Enumerable<UserNotePermissionScalarWhereInput>
    OR?: Enumerable<UserNotePermissionScalarWhereInput>
    NOT?: Enumerable<UserNotePermissionScalarWhereInput>
    userNotePermissionID?: StringFilter | string
    userID?: StringFilter | string
    role?: EnumNoteRoleFilter | NoteRole
    noteID?: StringFilter | string
  }

  export type DailyStatUnitUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyStatUnitWhereUniqueInput
    update: XOR<DailyStatUnitUpdateWithoutUserInput, DailyStatUnitUncheckedUpdateWithoutUserInput>
    create: XOR<DailyStatUnitCreateWithoutUserInput, DailyStatUnitUncheckedCreateWithoutUserInput>
  }

  export type DailyStatUnitUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyStatUnitWhereUniqueInput
    data: XOR<DailyStatUnitUpdateWithoutUserInput, DailyStatUnitUncheckedUpdateWithoutUserInput>
  }

  export type DailyStatUnitUpdateManyWithWhereWithoutUserInput = {
    where: DailyStatUnitScalarWhereInput
    data: XOR<DailyStatUnitUpdateManyMutationInput, DailyStatUnitUncheckedUpdateManyWithoutStatUnitInput>
  }

  export type DailyStatUnitScalarWhereInput = {
    AND?: Enumerable<DailyStatUnitScalarWhereInput>
    OR?: Enumerable<DailyStatUnitScalarWhereInput>
    NOT?: Enumerable<DailyStatUnitScalarWhereInput>
    dailyStatUnitID?: StringFilter | string
    userID?: StringFilter | string
    documentVersionID?: StringNullableFilter | string | null
    documentID?: StringNullableFilter | string | null
    dailyChallengeResponseID?: StringNullableFilter | string | null
    date?: DateTimeFilter | Date | string
    timeSpentSeconds?: IntFilter | number
    wordsAdded?: IntFilter | number
    wordsRemoved?: IntFilter | number
  }

  export type ScratchpadEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: ScratchpadEntryWhereUniqueInput
    update: XOR<ScratchpadEntryUpdateWithoutUserInput, ScratchpadEntryUncheckedUpdateWithoutUserInput>
    create: XOR<ScratchpadEntryCreateWithoutUserInput, ScratchpadEntryUncheckedCreateWithoutUserInput>
  }

  export type ScratchpadEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: ScratchpadEntryWhereUniqueInput
    data: XOR<ScratchpadEntryUpdateWithoutUserInput, ScratchpadEntryUncheckedUpdateWithoutUserInput>
  }

  export type ScratchpadEntryUpdateManyWithWhereWithoutUserInput = {
    where: ScratchpadEntryScalarWhereInput
    data: XOR<ScratchpadEntryUpdateManyMutationInput, ScratchpadEntryUncheckedUpdateManyWithoutScratchpadEntryInput>
  }

  export type ScratchpadEntryScalarWhereInput = {
    AND?: Enumerable<ScratchpadEntryScalarWhereInput>
    OR?: Enumerable<ScratchpadEntryScalarWhereInput>
    NOT?: Enumerable<ScratchpadEntryScalarWhereInput>
    scratchpadEntryID?: StringFilter | string
    content?: JsonNullableFilter
    date?: DateTimeFilter | Date | string
    userID?: StringFilter | string
  }

  export type UserDocumentAttributesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDocumentAttributesWhereUniqueInput
    update: XOR<UserDocumentAttributesUpdateWithoutUserInput, UserDocumentAttributesUncheckedUpdateWithoutUserInput>
    create: XOR<UserDocumentAttributesCreateWithoutUserInput, UserDocumentAttributesUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentAttributesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDocumentAttributesWhereUniqueInput
    data: XOR<UserDocumentAttributesUpdateWithoutUserInput, UserDocumentAttributesUncheckedUpdateWithoutUserInput>
  }

  export type UserDocumentAttributesUpdateManyWithWhereWithoutUserInput = {
    where: UserDocumentAttributesScalarWhereInput
    data: XOR<UserDocumentAttributesUpdateManyMutationInput, UserDocumentAttributesUncheckedUpdateManyWithoutUserDocumentAttributesInput>
  }

  export type UserDocumentAttributesScalarWhereInput = {
    AND?: Enumerable<UserDocumentAttributesScalarWhereInput>
    OR?: Enumerable<UserDocumentAttributesScalarWhereInput>
    NOT?: Enumerable<UserDocumentAttributesScalarWhereInput>
    documentID?: StringFilter | string
    userID?: StringFilter | string
    lastOpenedDocumentVersionID?: StringFilter | string
  }

  export type DailyChallengeResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyChallengeResponseWhereUniqueInput
    update: XOR<DailyChallengeResponseUpdateWithoutUserInput, DailyChallengeResponseUncheckedUpdateWithoutUserInput>
    create: XOR<DailyChallengeResponseCreateWithoutUserInput, DailyChallengeResponseUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengeResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyChallengeResponseWhereUniqueInput
    data: XOR<DailyChallengeResponseUpdateWithoutUserInput, DailyChallengeResponseUncheckedUpdateWithoutUserInput>
  }

  export type DailyChallengeResponseUpdateManyWithWhereWithoutUserInput = {
    where: DailyChallengeResponseScalarWhereInput
    data: XOR<DailyChallengeResponseUpdateManyMutationInput, DailyChallengeResponseUncheckedUpdateManyWithoutDailyChallengeResponseInput>
  }

  export type DailyChallengeResponseScalarWhereInput = {
    AND?: Enumerable<DailyChallengeResponseScalarWhereInput>
    OR?: Enumerable<DailyChallengeResponseScalarWhereInput>
    NOT?: Enumerable<DailyChallengeResponseScalarWhereInput>
    userID?: StringNullableFilter | string | null
    dailyChallengeID?: IntFilter | number
    dailyChallengeResponseID?: StringFilter | string
    content?: JsonNullableFilter
    postedOn?: DateTimeNullableFilter | Date | string | null
    wordCount?: IntFilter | number
    completedOnTime?: BoolFilter | boolean
  }

  export type DailyChallengeResponseLikesUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyChallengeResponseLikesWhereUniqueInput
    update: XOR<DailyChallengeResponseLikesUpdateWithoutUserInput, DailyChallengeResponseLikesUncheckedUpdateWithoutUserInput>
    create: XOR<DailyChallengeResponseLikesCreateWithoutUserInput, DailyChallengeResponseLikesUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengeResponseLikesUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyChallengeResponseLikesWhereUniqueInput
    data: XOR<DailyChallengeResponseLikesUpdateWithoutUserInput, DailyChallengeResponseLikesUncheckedUpdateWithoutUserInput>
  }

  export type DailyChallengeResponseLikesUpdateManyWithWhereWithoutUserInput = {
    where: DailyChallengeResponseLikesScalarWhereInput
    data: XOR<DailyChallengeResponseLikesUpdateManyMutationInput, DailyChallengeResponseLikesUncheckedUpdateManyWithoutDailyChallengeResponseLikesInput>
  }

  export type DailyChallengeResponseLikesScalarWhereInput = {
    AND?: Enumerable<DailyChallengeResponseLikesScalarWhereInput>
    OR?: Enumerable<DailyChallengeResponseLikesScalarWhereInput>
    NOT?: Enumerable<DailyChallengeResponseLikesScalarWhereInput>
    userID?: StringFilter | string
    dailyChallengeResponseID?: StringFilter | string
    likeID?: StringFilter | string
  }

  export type DailyChallengePromptSuggestionUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyChallengePromptSuggestionWhereUniqueInput
    update: XOR<DailyChallengePromptSuggestionUpdateWithoutUserInput, DailyChallengePromptSuggestionUncheckedUpdateWithoutUserInput>
    create: XOR<DailyChallengePromptSuggestionCreateWithoutUserInput, DailyChallengePromptSuggestionUncheckedCreateWithoutUserInput>
  }

  export type DailyChallengePromptSuggestionUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyChallengePromptSuggestionWhereUniqueInput
    data: XOR<DailyChallengePromptSuggestionUpdateWithoutUserInput, DailyChallengePromptSuggestionUncheckedUpdateWithoutUserInput>
  }

  export type DailyChallengePromptSuggestionUpdateManyWithWhereWithoutUserInput = {
    where: DailyChallengePromptSuggestionScalarWhereInput
    data: XOR<DailyChallengePromptSuggestionUpdateManyMutationInput, DailyChallengePromptSuggestionUncheckedUpdateManyWithoutDailyChallengePromptSuggestionInput>
  }

  export type DailyChallengePromptSuggestionScalarWhereInput = {
    AND?: Enumerable<DailyChallengePromptSuggestionScalarWhereInput>
    OR?: Enumerable<DailyChallengePromptSuggestionScalarWhereInput>
    NOT?: Enumerable<DailyChallengePromptSuggestionScalarWhereInput>
    promptSuggestionID?: StringFilter | string
    prompt?: StringFilter | string
    userID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    usedOn?: DateTimeNullableFilter | Date | string | null
  }

  export type FollowsUpsertWithWhereUniqueWithoutFollowingInput = {
    where: FollowsWhereUniqueInput
    update: XOR<FollowsUpdateWithoutFollowingInput, FollowsUncheckedUpdateWithoutFollowingInput>
    create: XOR<FollowsCreateWithoutFollowingInput, FollowsUncheckedCreateWithoutFollowingInput>
  }

  export type FollowsUpdateWithWhereUniqueWithoutFollowingInput = {
    where: FollowsWhereUniqueInput
    data: XOR<FollowsUpdateWithoutFollowingInput, FollowsUncheckedUpdateWithoutFollowingInput>
  }

  export type FollowsUpdateManyWithWhereWithoutFollowingInput = {
    where: FollowsScalarWhereInput
    data: XOR<FollowsUpdateManyMutationInput, FollowsUncheckedUpdateManyWithoutFollowedByInput>
  }

  export type FollowsScalarWhereInput = {
    AND?: Enumerable<FollowsScalarWhereInput>
    OR?: Enumerable<FollowsScalarWhereInput>
    NOT?: Enumerable<FollowsScalarWhereInput>
    followerID?: StringFilter | string
    followingID?: StringFilter | string
  }

  export type FollowsUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowsWhereUniqueInput
    update: XOR<FollowsUpdateWithoutFollowerInput, FollowsUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowsCreateWithoutFollowerInput, FollowsUncheckedCreateWithoutFollowerInput>
  }

  export type FollowsUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowsWhereUniqueInput
    data: XOR<FollowsUpdateWithoutFollowerInput, FollowsUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowsUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowsScalarWhereInput
    data: XOR<FollowsUpdateManyMutationInput, FollowsUncheckedUpdateManyWithoutFollowingInput>
  }

  export type PublishedDocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: PublishedDocumentWhereUniqueInput
    update: XOR<PublishedDocumentUpdateWithoutUserInput, PublishedDocumentUncheckedUpdateWithoutUserInput>
    create: XOR<PublishedDocumentCreateWithoutUserInput, PublishedDocumentUncheckedCreateWithoutUserInput>
  }

  export type PublishedDocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: PublishedDocumentWhereUniqueInput
    data: XOR<PublishedDocumentUpdateWithoutUserInput, PublishedDocumentUncheckedUpdateWithoutUserInput>
  }

  export type PublishedDocumentUpdateManyWithWhereWithoutUserInput = {
    where: PublishedDocumentScalarWhereInput
    data: XOR<PublishedDocumentUpdateManyMutationInput, PublishedDocumentUncheckedUpdateManyWithoutPublishedDocumentInput>
  }

  export type PublishedDocumentScalarWhereInput = {
    AND?: Enumerable<PublishedDocumentScalarWhereInput>
    OR?: Enumerable<PublishedDocumentScalarWhereInput>
    NOT?: Enumerable<PublishedDocumentScalarWhereInput>
    publishedDocumentID?: StringFilter | string
    documentID?: StringFilter | string
    content?: JsonNullableFilter
    url?: StringFilter | string
    userID?: StringFilter | string
    publishedAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    title?: StringFilter | string
    subtitle?: StringNullableFilter | string | null
  }

  export type PublishedDocumentUpsertWithWhereUniqueWithoutLikingUsersInput = {
    where: PublishedDocumentWhereUniqueInput
    update: XOR<PublishedDocumentUpdateWithoutLikingUsersInput, PublishedDocumentUncheckedUpdateWithoutLikingUsersInput>
    create: XOR<PublishedDocumentCreateWithoutLikingUsersInput, PublishedDocumentUncheckedCreateWithoutLikingUsersInput>
  }

  export type PublishedDocumentUpdateWithWhereUniqueWithoutLikingUsersInput = {
    where: PublishedDocumentWhereUniqueInput
    data: XOR<PublishedDocumentUpdateWithoutLikingUsersInput, PublishedDocumentUncheckedUpdateWithoutLikingUsersInput>
  }

  export type PublishedDocumentUpdateManyWithWhereWithoutLikingUsersInput = {
    where: PublishedDocumentScalarWhereInput
    data: XOR<PublishedDocumentUpdateManyMutationInput, PublishedDocumentUncheckedUpdateManyWithoutPublishedDocumentLikesInput>
  }

  export type WritingSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: WritingSessionWhereUniqueInput
    update: XOR<WritingSessionUpdateWithoutUserInput, WritingSessionUncheckedUpdateWithoutUserInput>
    create: XOR<WritingSessionCreateWithoutUserInput, WritingSessionUncheckedCreateWithoutUserInput>
  }

  export type WritingSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: WritingSessionWhereUniqueInput
    data: XOR<WritingSessionUpdateWithoutUserInput, WritingSessionUncheckedUpdateWithoutUserInput>
  }

  export type WritingSessionUpdateManyWithWhereWithoutUserInput = {
    where: WritingSessionScalarWhereInput
    data: XOR<WritingSessionUpdateManyMutationInput, WritingSessionUncheckedUpdateManyWithoutWritingSessionsInput>
  }

  export type WritingSessionScalarWhereInput = {
    AND?: Enumerable<WritingSessionScalarWhereInput>
    OR?: Enumerable<WritingSessionScalarWhereInput>
    NOT?: Enumerable<WritingSessionScalarWhereInput>
    writingSessionID?: StringFilter | string
    userID?: StringFilter | string
    segmentTime?: IntNullableListFilter
    wordsAdded?: IntFilter | number
    wordsRemoved?: IntFilter | number
    timeSpentSeconds?: IntFilter | number
    startDateTime?: DateTimeFilter | Date | string
    title?: StringFilter | string
    documentID?: StringNullableFilter | string | null
    inProgress?: BoolFilter | boolean
    updatedAt?: DateTimeFilter | Date | string
  }

  export type WritingSessionUpsertWithWhereUniqueWithoutLikesInput = {
    where: WritingSessionWhereUniqueInput
    update: XOR<WritingSessionUpdateWithoutLikesInput, WritingSessionUncheckedUpdateWithoutLikesInput>
    create: XOR<WritingSessionCreateWithoutLikesInput, WritingSessionUncheckedCreateWithoutLikesInput>
  }

  export type WritingSessionUpdateWithWhereUniqueWithoutLikesInput = {
    where: WritingSessionWhereUniqueInput
    data: XOR<WritingSessionUpdateWithoutLikesInput, WritingSessionUncheckedUpdateWithoutLikesInput>
  }

  export type WritingSessionUpdateManyWithWhereWithoutLikesInput = {
    where: WritingSessionScalarWhereInput
    data: XOR<WritingSessionUpdateManyMutationInput, WritingSessionUncheckedUpdateManyWithoutWritingSessionLikesInput>
  }

  export type UserEnhancedDocumentPermissionsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
    update: XOR<UserEnhancedDocumentPermissionsUpdateWithoutUserInput, UserEnhancedDocumentPermissionsUncheckedUpdateWithoutUserInput>
    create: XOR<UserEnhancedDocumentPermissionsCreateWithoutUserInput, UserEnhancedDocumentPermissionsUncheckedCreateWithoutUserInput>
  }

  export type UserEnhancedDocumentPermissionsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
    data: XOR<UserEnhancedDocumentPermissionsUpdateWithoutUserInput, UserEnhancedDocumentPermissionsUncheckedUpdateWithoutUserInput>
  }

  export type UserEnhancedDocumentPermissionsUpdateManyWithWhereWithoutUserInput = {
    where: UserEnhancedDocumentPermissionsScalarWhereInput
    data: XOR<UserEnhancedDocumentPermissionsUpdateManyMutationInput, UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type UserEnhancedDocumentPermissionsScalarWhereInput = {
    AND?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereInput>
    OR?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereInput>
    NOT?: Enumerable<UserEnhancedDocumentPermissionsScalarWhereInput>
    userID?: StringFilter | string
    enhancedDocumentID?: StringFilter | string
    role?: EnumEnhancedDocumentRoleFilter | EnhancedDocumentRole
  }

  export type ThreadAttributesUpsertWithWhereUniqueWithoutUserInput = {
    where: ThreadAttributesWhereUniqueInput
    update: XOR<ThreadAttributesUpdateWithoutUserInput, ThreadAttributesUncheckedUpdateWithoutUserInput>
    create: XOR<ThreadAttributesCreateWithoutUserInput, ThreadAttributesUncheckedCreateWithoutUserInput>
  }

  export type ThreadAttributesUpdateWithWhereUniqueWithoutUserInput = {
    where: ThreadAttributesWhereUniqueInput
    data: XOR<ThreadAttributesUpdateWithoutUserInput, ThreadAttributesUncheckedUpdateWithoutUserInput>
  }

  export type ThreadAttributesUpdateManyWithWhereWithoutUserInput = {
    where: ThreadAttributesScalarWhereInput
    data: XOR<ThreadAttributesUpdateManyMutationInput, ThreadAttributesUncheckedUpdateManyWithoutThreadAttributesInput>
  }

  export type ThreadAttributesScalarWhereInput = {
    AND?: Enumerable<ThreadAttributesScalarWhereInput>
    OR?: Enumerable<ThreadAttributesScalarWhereInput>
    NOT?: Enumerable<ThreadAttributesScalarWhereInput>
    threadID?: StringFilter | string
    userID?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    archivedAt?: DateTimeNullableFilter | Date | string | null
    enhancedDocumentID?: StringFilter | string
    sectionData?: JsonNullableFilter
  }

  export type UserCreateWithoutFollowingInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowingInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserCreateWithoutFollowedByInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowedByInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type UserUpsertWithoutFollowingInput = {
    update: XOR<UserUpdateWithoutFollowingInput, UserUncheckedUpdateWithoutFollowingInput>
    create: XOR<UserCreateWithoutFollowingInput, UserUncheckedCreateWithoutFollowingInput>
  }

  export type UserUpdateWithoutFollowingInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowingInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFollowedByInput = {
    update: XOR<UserUpdateWithoutFollowedByInput, UserUncheckedUpdateWithoutFollowedByInput>
    create: XOR<UserCreateWithoutFollowedByInput, UserUncheckedCreateWithoutFollowedByInput>
  }

  export type UserUpdateWithoutFollowedByInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowedByInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserNotePermissionCreateWithoutNoteInput = {
    userNotePermissionID?: string
    role: NoteRole
    user: UserCreateNestedOneWithoutUserNotePermissionInput
  }

  export type UserNotePermissionUncheckedCreateWithoutNoteInput = {
    userNotePermissionID?: string
    userID: string
    role: NoteRole
  }

  export type UserNotePermissionCreateOrConnectWithoutNoteInput = {
    where: UserNotePermissionWhereUniqueInput
    create: XOR<UserNotePermissionCreateWithoutNoteInput, UserNotePermissionUncheckedCreateWithoutNoteInput>
  }

  export type UserNotePermissionCreateManyNoteInputEnvelope = {
    data: Enumerable<UserNotePermissionCreateManyNoteInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutNotesInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutNotesInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutNotesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutNotesInput, DocumentUncheckedCreateWithoutNotesInput>
  }

  export type UserNotePermissionUpsertWithWhereUniqueWithoutNoteInput = {
    where: UserNotePermissionWhereUniqueInput
    update: XOR<UserNotePermissionUpdateWithoutNoteInput, UserNotePermissionUncheckedUpdateWithoutNoteInput>
    create: XOR<UserNotePermissionCreateWithoutNoteInput, UserNotePermissionUncheckedCreateWithoutNoteInput>
  }

  export type UserNotePermissionUpdateWithWhereUniqueWithoutNoteInput = {
    where: UserNotePermissionWhereUniqueInput
    data: XOR<UserNotePermissionUpdateWithoutNoteInput, UserNotePermissionUncheckedUpdateWithoutNoteInput>
  }

  export type UserNotePermissionUpdateManyWithWhereWithoutNoteInput = {
    where: UserNotePermissionScalarWhereInput
    data: XOR<UserNotePermissionUpdateManyMutationInput, UserNotePermissionUncheckedUpdateManyWithoutUserNotePermissionsInput>
  }

  export type DocumentUpsertWithoutNotesInput = {
    update: XOR<DocumentUpdateWithoutNotesInput, DocumentUncheckedUpdateWithoutNotesInput>
    create: XOR<DocumentCreateWithoutNotesInput, DocumentUncheckedCreateWithoutNotesInput>
  }

  export type DocumentUpdateWithoutNotesInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutNotesInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type CommentCreateWithoutDocumentVersionInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
    author: UserCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutDocumentVersionInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    authorID: string
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
  }

  export type CommentCreateOrConnectWithoutDocumentVersionInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutDocumentVersionInput, CommentUncheckedCreateWithoutDocumentVersionInput>
  }

  export type CommentCreateManyDocumentVersionInputEnvelope = {
    data: Enumerable<CommentCreateManyDocumentVersionInput>
    skipDuplicates?: boolean
  }

  export type UserDocumentPermissionCreateWithoutDocumentVersionInput = {
    userDocumentPermissionID?: string
    role: Role
    user: UserCreateNestedOneWithoutUserDocumentPermissionsInput
    document?: DocumentCreateNestedOneWithoutUserDocumentPermissionsInput
  }

  export type UserDocumentPermissionUncheckedCreateWithoutDocumentVersionInput = {
    userDocumentPermissionID?: string
    userID: string
    role: Role
    documentID?: string | null
  }

  export type UserDocumentPermissionCreateOrConnectWithoutDocumentVersionInput = {
    where: UserDocumentPermissionWhereUniqueInput
    create: XOR<UserDocumentPermissionCreateWithoutDocumentVersionInput, UserDocumentPermissionUncheckedCreateWithoutDocumentVersionInput>
  }

  export type UserDocumentPermissionCreateManyDocumentVersionInputEnvelope = {
    data: Enumerable<UserDocumentPermissionCreateManyDocumentVersionInput>
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutDocumentVersionsInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentInput
    notes?: NoteCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutDocumentVersionsInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
    notes?: NoteUncheckedCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutDocumentVersionsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutDocumentVersionsInput, DocumentUncheckedCreateWithoutDocumentVersionsInput>
  }

  export type DailyStatUnitCreateWithoutDocumentVersionInput = {
    dailyStatUnitID?: string
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
    user: UserCreateNestedOneWithoutStatUnitInput
    document?: DocumentCreateNestedOneWithoutStatUnitInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedOneWithoutDailyStatUnitInput
  }

  export type DailyStatUnitUncheckedCreateWithoutDocumentVersionInput = {
    dailyStatUnitID?: string
    userID: string
    documentID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type DailyStatUnitCreateOrConnectWithoutDocumentVersionInput = {
    where: DailyStatUnitWhereUniqueInput
    create: XOR<DailyStatUnitCreateWithoutDocumentVersionInput, DailyStatUnitUncheckedCreateWithoutDocumentVersionInput>
  }

  export type DailyStatUnitCreateManyDocumentVersionInputEnvelope = {
    data: Enumerable<DailyStatUnitCreateManyDocumentVersionInput>
    skipDuplicates?: boolean
  }

  export type UserDocumentAttributesCreateWithoutLastOpenedDocumentVersionInput = {
    document: DocumentCreateNestedOneWithoutUserDocumentAttributesInput
    user: UserCreateNestedOneWithoutUserDocumentAttributesInput
  }

  export type UserDocumentAttributesUncheckedCreateWithoutLastOpenedDocumentVersionInput = {
    documentID: string
    userID: string
  }

  export type UserDocumentAttributesCreateOrConnectWithoutLastOpenedDocumentVersionInput = {
    where: UserDocumentAttributesWhereUniqueInput
    create: XOR<UserDocumentAttributesCreateWithoutLastOpenedDocumentVersionInput, UserDocumentAttributesUncheckedCreateWithoutLastOpenedDocumentVersionInput>
  }

  export type UserDocumentAttributesCreateManyLastOpenedDocumentVersionInputEnvelope = {
    data: Enumerable<UserDocumentAttributesCreateManyLastOpenedDocumentVersionInput>
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutDocumentVersionInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutDocumentVersionInput, CommentUncheckedUpdateWithoutDocumentVersionInput>
    create: XOR<CommentCreateWithoutDocumentVersionInput, CommentUncheckedCreateWithoutDocumentVersionInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutDocumentVersionInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutDocumentVersionInput, CommentUncheckedUpdateWithoutDocumentVersionInput>
  }

  export type CommentUpdateManyWithWhereWithoutDocumentVersionInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentsInput>
  }

  export type UserDocumentPermissionUpsertWithWhereUniqueWithoutDocumentVersionInput = {
    where: UserDocumentPermissionWhereUniqueInput
    update: XOR<UserDocumentPermissionUpdateWithoutDocumentVersionInput, UserDocumentPermissionUncheckedUpdateWithoutDocumentVersionInput>
    create: XOR<UserDocumentPermissionCreateWithoutDocumentVersionInput, UserDocumentPermissionUncheckedCreateWithoutDocumentVersionInput>
  }

  export type UserDocumentPermissionUpdateWithWhereUniqueWithoutDocumentVersionInput = {
    where: UserDocumentPermissionWhereUniqueInput
    data: XOR<UserDocumentPermissionUpdateWithoutDocumentVersionInput, UserDocumentPermissionUncheckedUpdateWithoutDocumentVersionInput>
  }

  export type UserDocumentPermissionUpdateManyWithWhereWithoutDocumentVersionInput = {
    where: UserDocumentPermissionScalarWhereInput
    data: XOR<UserDocumentPermissionUpdateManyMutationInput, UserDocumentPermissionUncheckedUpdateManyWithoutUserDocumentPermissionsInput>
  }

  export type DocumentUpsertWithoutDocumentVersionsInput = {
    update: XOR<DocumentUpdateWithoutDocumentVersionsInput, DocumentUncheckedUpdateWithoutDocumentVersionsInput>
    create: XOR<DocumentCreateWithoutDocumentVersionsInput, DocumentUncheckedCreateWithoutDocumentVersionsInput>
  }

  export type DocumentUpdateWithoutDocumentVersionsInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentNestedInput
    notes?: NoteUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutDocumentVersionsInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DailyStatUnitUpsertWithWhereUniqueWithoutDocumentVersionInput = {
    where: DailyStatUnitWhereUniqueInput
    update: XOR<DailyStatUnitUpdateWithoutDocumentVersionInput, DailyStatUnitUncheckedUpdateWithoutDocumentVersionInput>
    create: XOR<DailyStatUnitCreateWithoutDocumentVersionInput, DailyStatUnitUncheckedCreateWithoutDocumentVersionInput>
  }

  export type DailyStatUnitUpdateWithWhereUniqueWithoutDocumentVersionInput = {
    where: DailyStatUnitWhereUniqueInput
    data: XOR<DailyStatUnitUpdateWithoutDocumentVersionInput, DailyStatUnitUncheckedUpdateWithoutDocumentVersionInput>
  }

  export type DailyStatUnitUpdateManyWithWhereWithoutDocumentVersionInput = {
    where: DailyStatUnitScalarWhereInput
    data: XOR<DailyStatUnitUpdateManyMutationInput, DailyStatUnitUncheckedUpdateManyWithoutStatUnitInput>
  }

  export type UserDocumentAttributesUpsertWithWhereUniqueWithoutLastOpenedDocumentVersionInput = {
    where: UserDocumentAttributesWhereUniqueInput
    update: XOR<UserDocumentAttributesUpdateWithoutLastOpenedDocumentVersionInput, UserDocumentAttributesUncheckedUpdateWithoutLastOpenedDocumentVersionInput>
    create: XOR<UserDocumentAttributesCreateWithoutLastOpenedDocumentVersionInput, UserDocumentAttributesUncheckedCreateWithoutLastOpenedDocumentVersionInput>
  }

  export type UserDocumentAttributesUpdateWithWhereUniqueWithoutLastOpenedDocumentVersionInput = {
    where: UserDocumentAttributesWhereUniqueInput
    data: XOR<UserDocumentAttributesUpdateWithoutLastOpenedDocumentVersionInput, UserDocumentAttributesUncheckedUpdateWithoutLastOpenedDocumentVersionInput>
  }

  export type UserDocumentAttributesUpdateManyWithWhereWithoutLastOpenedDocumentVersionInput = {
    where: UserDocumentAttributesScalarWhereInput
    data: XOR<UserDocumentAttributesUpdateManyMutationInput, UserDocumentAttributesUncheckedUpdateManyWithoutUserDocumentAttributesInput>
  }

  export type DocumentVersionCreateWithoutDocumentInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
    comments?: CommentCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentVersionInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateWithoutDocumentInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
    comments?: CommentUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentVersionInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionCreateOrConnectWithoutDocumentInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentVersionCreateManyDocumentInputEnvelope = {
    data: Enumerable<DocumentVersionCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type UserDocumentPermissionCreateWithoutDocumentInput = {
    userDocumentPermissionID?: string
    role: Role
    user: UserCreateNestedOneWithoutUserDocumentPermissionsInput
    documentVersion?: DocumentVersionCreateNestedOneWithoutUserDocumentPermissionsInput
  }

  export type UserDocumentPermissionUncheckedCreateWithoutDocumentInput = {
    userDocumentPermissionID?: string
    userID: string
    documentVersionID?: string | null
    role: Role
  }

  export type UserDocumentPermissionCreateOrConnectWithoutDocumentInput = {
    where: UserDocumentPermissionWhereUniqueInput
    create: XOR<UserDocumentPermissionCreateWithoutDocumentInput, UserDocumentPermissionUncheckedCreateWithoutDocumentInput>
  }

  export type UserDocumentPermissionCreateManyDocumentInputEnvelope = {
    data: Enumerable<UserDocumentPermissionCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type NoteCreateWithoutDocumentInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    personal?: boolean
    userNotePermissions?: UserNotePermissionCreateNestedManyWithoutNoteInput
  }

  export type NoteUncheckedCreateWithoutDocumentInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    personal?: boolean
    userNotePermissions?: UserNotePermissionUncheckedCreateNestedManyWithoutNoteInput
  }

  export type NoteCreateOrConnectWithoutDocumentInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutDocumentInput, NoteUncheckedCreateWithoutDocumentInput>
  }

  export type NoteCreateManyDocumentInputEnvelope = {
    data: Enumerable<NoteCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type DailyStatUnitCreateWithoutDocumentInput = {
    dailyStatUnitID?: string
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
    user: UserCreateNestedOneWithoutStatUnitInput
    documentVersion?: DocumentVersionCreateNestedOneWithoutStatUnitInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedOneWithoutDailyStatUnitInput
  }

  export type DailyStatUnitUncheckedCreateWithoutDocumentInput = {
    dailyStatUnitID?: string
    userID: string
    documentVersionID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type DailyStatUnitCreateOrConnectWithoutDocumentInput = {
    where: DailyStatUnitWhereUniqueInput
    create: XOR<DailyStatUnitCreateWithoutDocumentInput, DailyStatUnitUncheckedCreateWithoutDocumentInput>
  }

  export type DailyStatUnitCreateManyDocumentInputEnvelope = {
    data: Enumerable<DailyStatUnitCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type UserDocumentAttributesCreateWithoutDocumentInput = {
    user: UserCreateNestedOneWithoutUserDocumentAttributesInput
    lastOpenedDocumentVersion: DocumentVersionCreateNestedOneWithoutUserDocumentAttributesInput
  }

  export type UserDocumentAttributesUncheckedCreateWithoutDocumentInput = {
    userID: string
    lastOpenedDocumentVersionID: string
  }

  export type UserDocumentAttributesCreateOrConnectWithoutDocumentInput = {
    where: UserDocumentAttributesWhereUniqueInput
    create: XOR<UserDocumentAttributesCreateWithoutDocumentInput, UserDocumentAttributesUncheckedCreateWithoutDocumentInput>
  }

  export type UserDocumentAttributesCreateManyDocumentInputEnvelope = {
    data: Enumerable<UserDocumentAttributesCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type PublishedDocumentCreateWithoutDocumentInput = {
    publishedDocumentID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
    user: UserCreateNestedOneWithoutPublishedDocumentInput
    likingUsers?: UserCreateNestedManyWithoutPublishedDocumentLikesInput
  }

  export type PublishedDocumentUncheckedCreateWithoutDocumentInput = {
    publishedDocumentID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    userID: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
    likingUsers?: UserUncheckedCreateNestedManyWithoutPublishedDocumentLikesInput
  }

  export type PublishedDocumentCreateOrConnectWithoutDocumentInput = {
    where: PublishedDocumentWhereUniqueInput
    create: XOR<PublishedDocumentCreateWithoutDocumentInput, PublishedDocumentUncheckedCreateWithoutDocumentInput>
  }

  export type PublishedDocumentCreateManyDocumentInputEnvelope = {
    data: Enumerable<PublishedDocumentCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type WritingSessionCreateWithoutDocumentInput = {
    writingSessionID?: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    inProgress?: boolean
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWritingSessionsInput
    likes?: UserCreateNestedManyWithoutWritingSessionLikesInput
  }

  export type WritingSessionUncheckedCreateWithoutDocumentInput = {
    writingSessionID?: string
    userID: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    inProgress?: boolean
    updatedAt?: Date | string
    likes?: UserUncheckedCreateNestedManyWithoutWritingSessionLikesInput
  }

  export type WritingSessionCreateOrConnectWithoutDocumentInput = {
    where: WritingSessionWhereUniqueInput
    create: XOR<WritingSessionCreateWithoutDocumentInput, WritingSessionUncheckedCreateWithoutDocumentInput>
  }

  export type WritingSessionCreateManyDocumentInputEnvelope = {
    data: Enumerable<WritingSessionCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type DocumentVersionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentVersionWhereUniqueInput
    update: XOR<DocumentVersionUpdateWithoutDocumentInput, DocumentVersionUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentVersionCreateWithoutDocumentInput, DocumentVersionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentVersionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentVersionWhereUniqueInput
    data: XOR<DocumentVersionUpdateWithoutDocumentInput, DocumentVersionUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentVersionUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentVersionScalarWhereInput
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyWithoutDocumentVersionsInput>
  }

  export type DocumentVersionScalarWhereInput = {
    AND?: Enumerable<DocumentVersionScalarWhereInput>
    OR?: Enumerable<DocumentVersionScalarWhereInput>
    NOT?: Enumerable<DocumentVersionScalarWhereInput>
    documentVersionID?: StringFilter | string
    content?: JsonNullableFilter
    updatedAt?: DateTimeFilter | Date | string
    createdAt?: DateTimeFilter | Date | string
    documentID?: StringFilter | string
    versionName?: StringFilter | string
    wordCount?: IntFilter | number
  }

  export type UserDocumentPermissionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: UserDocumentPermissionWhereUniqueInput
    update: XOR<UserDocumentPermissionUpdateWithoutDocumentInput, UserDocumentPermissionUncheckedUpdateWithoutDocumentInput>
    create: XOR<UserDocumentPermissionCreateWithoutDocumentInput, UserDocumentPermissionUncheckedCreateWithoutDocumentInput>
  }

  export type UserDocumentPermissionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: UserDocumentPermissionWhereUniqueInput
    data: XOR<UserDocumentPermissionUpdateWithoutDocumentInput, UserDocumentPermissionUncheckedUpdateWithoutDocumentInput>
  }

  export type UserDocumentPermissionUpdateManyWithWhereWithoutDocumentInput = {
    where: UserDocumentPermissionScalarWhereInput
    data: XOR<UserDocumentPermissionUpdateManyMutationInput, UserDocumentPermissionUncheckedUpdateManyWithoutUserDocumentPermissionsInput>
  }

  export type NoteUpsertWithWhereUniqueWithoutDocumentInput = {
    where: NoteWhereUniqueInput
    update: XOR<NoteUpdateWithoutDocumentInput, NoteUncheckedUpdateWithoutDocumentInput>
    create: XOR<NoteCreateWithoutDocumentInput, NoteUncheckedCreateWithoutDocumentInput>
  }

  export type NoteUpdateWithWhereUniqueWithoutDocumentInput = {
    where: NoteWhereUniqueInput
    data: XOR<NoteUpdateWithoutDocumentInput, NoteUncheckedUpdateWithoutDocumentInput>
  }

  export type NoteUpdateManyWithWhereWithoutDocumentInput = {
    where: NoteScalarWhereInput
    data: XOR<NoteUpdateManyMutationInput, NoteUncheckedUpdateManyWithoutNotesInput>
  }

  export type NoteScalarWhereInput = {
    AND?: Enumerable<NoteScalarWhereInput>
    OR?: Enumerable<NoteScalarWhereInput>
    NOT?: Enumerable<NoteScalarWhereInput>
    noteID?: StringFilter | string
    title?: StringNullableFilter | string | null
    content?: JsonNullableFilter
    icon?: StringNullableFilter | string | null
    updatedAt?: DateTimeFilter | Date | string
    documentID?: StringFilter | string
    personal?: BoolFilter | boolean
  }

  export type DailyStatUnitUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DailyStatUnitWhereUniqueInput
    update: XOR<DailyStatUnitUpdateWithoutDocumentInput, DailyStatUnitUncheckedUpdateWithoutDocumentInput>
    create: XOR<DailyStatUnitCreateWithoutDocumentInput, DailyStatUnitUncheckedCreateWithoutDocumentInput>
  }

  export type DailyStatUnitUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DailyStatUnitWhereUniqueInput
    data: XOR<DailyStatUnitUpdateWithoutDocumentInput, DailyStatUnitUncheckedUpdateWithoutDocumentInput>
  }

  export type DailyStatUnitUpdateManyWithWhereWithoutDocumentInput = {
    where: DailyStatUnitScalarWhereInput
    data: XOR<DailyStatUnitUpdateManyMutationInput, DailyStatUnitUncheckedUpdateManyWithoutStatUnitInput>
  }

  export type UserDocumentAttributesUpsertWithWhereUniqueWithoutDocumentInput = {
    where: UserDocumentAttributesWhereUniqueInput
    update: XOR<UserDocumentAttributesUpdateWithoutDocumentInput, UserDocumentAttributesUncheckedUpdateWithoutDocumentInput>
    create: XOR<UserDocumentAttributesCreateWithoutDocumentInput, UserDocumentAttributesUncheckedCreateWithoutDocumentInput>
  }

  export type UserDocumentAttributesUpdateWithWhereUniqueWithoutDocumentInput = {
    where: UserDocumentAttributesWhereUniqueInput
    data: XOR<UserDocumentAttributesUpdateWithoutDocumentInput, UserDocumentAttributesUncheckedUpdateWithoutDocumentInput>
  }

  export type UserDocumentAttributesUpdateManyWithWhereWithoutDocumentInput = {
    where: UserDocumentAttributesScalarWhereInput
    data: XOR<UserDocumentAttributesUpdateManyMutationInput, UserDocumentAttributesUncheckedUpdateManyWithoutUserDocumentAttributesInput>
  }

  export type PublishedDocumentUpsertWithWhereUniqueWithoutDocumentInput = {
    where: PublishedDocumentWhereUniqueInput
    update: XOR<PublishedDocumentUpdateWithoutDocumentInput, PublishedDocumentUncheckedUpdateWithoutDocumentInput>
    create: XOR<PublishedDocumentCreateWithoutDocumentInput, PublishedDocumentUncheckedCreateWithoutDocumentInput>
  }

  export type PublishedDocumentUpdateWithWhereUniqueWithoutDocumentInput = {
    where: PublishedDocumentWhereUniqueInput
    data: XOR<PublishedDocumentUpdateWithoutDocumentInput, PublishedDocumentUncheckedUpdateWithoutDocumentInput>
  }

  export type PublishedDocumentUpdateManyWithWhereWithoutDocumentInput = {
    where: PublishedDocumentScalarWhereInput
    data: XOR<PublishedDocumentUpdateManyMutationInput, PublishedDocumentUncheckedUpdateManyWithoutPublishedDocumentInput>
  }

  export type WritingSessionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: WritingSessionWhereUniqueInput
    update: XOR<WritingSessionUpdateWithoutDocumentInput, WritingSessionUncheckedUpdateWithoutDocumentInput>
    create: XOR<WritingSessionCreateWithoutDocumentInput, WritingSessionUncheckedCreateWithoutDocumentInput>
  }

  export type WritingSessionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: WritingSessionWhereUniqueInput
    data: XOR<WritingSessionUpdateWithoutDocumentInput, WritingSessionUncheckedUpdateWithoutDocumentInput>
  }

  export type WritingSessionUpdateManyWithWhereWithoutDocumentInput = {
    where: WritingSessionScalarWhereInput
    data: XOR<WritingSessionUpdateManyMutationInput, WritingSessionUncheckedUpdateManyWithoutWritingSessionInput>
  }

  export type UserCreateWithoutUserEnhancedDocumentPermissionsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserEnhancedDocumentPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserEnhancedDocumentPermissionsInput, UserUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type EnhancedDocumentCreateWithoutUserEnhancedDocumentPermissionsInput = {
    enhancedDocumentID?: string
    notesContent: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title: string
    updatedAt?: Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: boolean
    ideas?: EnhancedDocumentCreateideasInput | Enumerable<string>
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutDocumentInput
  }

  export type EnhancedDocumentUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput = {
    enhancedDocumentID?: string
    notesContent: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title: string
    updatedAt?: Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: boolean
    ideas?: EnhancedDocumentCreateideasInput | Enumerable<string>
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type EnhancedDocumentCreateOrConnectWithoutUserEnhancedDocumentPermissionsInput = {
    where: EnhancedDocumentWhereUniqueInput
    create: XOR<EnhancedDocumentCreateWithoutUserEnhancedDocumentPermissionsInput, EnhancedDocumentUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type UserUpsertWithoutUserEnhancedDocumentPermissionsInput = {
    update: XOR<UserUpdateWithoutUserEnhancedDocumentPermissionsInput, UserUncheckedUpdateWithoutUserEnhancedDocumentPermissionsInput>
    create: XOR<UserCreateWithoutUserEnhancedDocumentPermissionsInput, UserUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type UserUpdateWithoutUserEnhancedDocumentPermissionsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserEnhancedDocumentPermissionsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EnhancedDocumentUpsertWithoutUserEnhancedDocumentPermissionsInput = {
    update: XOR<EnhancedDocumentUpdateWithoutUserEnhancedDocumentPermissionsInput, EnhancedDocumentUncheckedUpdateWithoutUserEnhancedDocumentPermissionsInput>
    create: XOR<EnhancedDocumentCreateWithoutUserEnhancedDocumentPermissionsInput, EnhancedDocumentUncheckedCreateWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type EnhancedDocumentUpdateWithoutUserEnhancedDocumentPermissionsInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
    threadAttributes?: ThreadAttributesUpdateManyWithoutDocumentNestedInput
  }

  export type EnhancedDocumentUncheckedUpdateWithoutUserEnhancedDocumentPermissionsInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserEnhancedDocumentPermissionsCreateWithoutEnhancedDocumentInput = {
    role: EnhancedDocumentRole
    user: UserCreateNestedOneWithoutUserEnhancedDocumentPermissionsInput
  }

  export type UserEnhancedDocumentPermissionsUncheckedCreateWithoutEnhancedDocumentInput = {
    userID: string
    role: EnhancedDocumentRole
  }

  export type UserEnhancedDocumentPermissionsCreateOrConnectWithoutEnhancedDocumentInput = {
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
    create: XOR<UserEnhancedDocumentPermissionsCreateWithoutEnhancedDocumentInput, UserEnhancedDocumentPermissionsUncheckedCreateWithoutEnhancedDocumentInput>
  }

  export type UserEnhancedDocumentPermissionsCreateManyEnhancedDocumentInputEnvelope = {
    data: Enumerable<UserEnhancedDocumentPermissionsCreateManyEnhancedDocumentInput>
    skipDuplicates?: boolean
  }

  export type ThreadAttributesCreateWithoutDocumentInput = {
    threadID?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutThreadAttributesInput
    chatMessage?: ChatMessageCreateNestedManyWithoutThreadInput
  }

  export type ThreadAttributesUncheckedCreateWithoutDocumentInput = {
    threadID?: string
    userID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    chatMessage?: ChatMessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type ThreadAttributesCreateOrConnectWithoutDocumentInput = {
    where: ThreadAttributesWhereUniqueInput
    create: XOR<ThreadAttributesCreateWithoutDocumentInput, ThreadAttributesUncheckedCreateWithoutDocumentInput>
  }

  export type ThreadAttributesCreateManyDocumentInputEnvelope = {
    data: Enumerable<ThreadAttributesCreateManyDocumentInput>
    skipDuplicates?: boolean
  }

  export type UserEnhancedDocumentPermissionsUpsertWithWhereUniqueWithoutEnhancedDocumentInput = {
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
    update: XOR<UserEnhancedDocumentPermissionsUpdateWithoutEnhancedDocumentInput, UserEnhancedDocumentPermissionsUncheckedUpdateWithoutEnhancedDocumentInput>
    create: XOR<UserEnhancedDocumentPermissionsCreateWithoutEnhancedDocumentInput, UserEnhancedDocumentPermissionsUncheckedCreateWithoutEnhancedDocumentInput>
  }

  export type UserEnhancedDocumentPermissionsUpdateWithWhereUniqueWithoutEnhancedDocumentInput = {
    where: UserEnhancedDocumentPermissionsWhereUniqueInput
    data: XOR<UserEnhancedDocumentPermissionsUpdateWithoutEnhancedDocumentInput, UserEnhancedDocumentPermissionsUncheckedUpdateWithoutEnhancedDocumentInput>
  }

  export type UserEnhancedDocumentPermissionsUpdateManyWithWhereWithoutEnhancedDocumentInput = {
    where: UserEnhancedDocumentPermissionsScalarWhereInput
    data: XOR<UserEnhancedDocumentPermissionsUpdateManyMutationInput, UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserEnhancedDocumentPermissionsInput>
  }

  export type ThreadAttributesUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ThreadAttributesWhereUniqueInput
    update: XOR<ThreadAttributesUpdateWithoutDocumentInput, ThreadAttributesUncheckedUpdateWithoutDocumentInput>
    create: XOR<ThreadAttributesCreateWithoutDocumentInput, ThreadAttributesUncheckedCreateWithoutDocumentInput>
  }

  export type ThreadAttributesUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ThreadAttributesWhereUniqueInput
    data: XOR<ThreadAttributesUpdateWithoutDocumentInput, ThreadAttributesUncheckedUpdateWithoutDocumentInput>
  }

  export type ThreadAttributesUpdateManyWithWhereWithoutDocumentInput = {
    where: ThreadAttributesScalarWhereInput
    data: XOR<ThreadAttributesUpdateManyMutationInput, ThreadAttributesUncheckedUpdateManyWithoutThreadAttributesInput>
  }

  export type UserCreateWithoutThreadAttributesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutThreadAttributesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutThreadAttributesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutThreadAttributesInput, UserUncheckedCreateWithoutThreadAttributesInput>
  }

  export type EnhancedDocumentCreateWithoutThreadAttributesInput = {
    enhancedDocumentID?: string
    notesContent: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title: string
    updatedAt?: Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: boolean
    ideas?: EnhancedDocumentCreateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutEnhancedDocumentInput
  }

  export type EnhancedDocumentUncheckedCreateWithoutThreadAttributesInput = {
    enhancedDocumentID?: string
    notesContent: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title: string
    updatedAt?: Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: boolean
    ideas?: EnhancedDocumentCreateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutEnhancedDocumentInput
  }

  export type EnhancedDocumentCreateOrConnectWithoutThreadAttributesInput = {
    where: EnhancedDocumentWhereUniqueInput
    create: XOR<EnhancedDocumentCreateWithoutThreadAttributesInput, EnhancedDocumentUncheckedCreateWithoutThreadAttributesInput>
  }

  export type ChatMessageCreateWithoutThreadInput = {
    chatMessageID?: string
    content: string
    author: ChatMessageAuthor
    createdAt?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutThreadInput = {
    chatMessageID?: string
    content: string
    author: ChatMessageAuthor
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutThreadInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutThreadInput, ChatMessageUncheckedCreateWithoutThreadInput>
  }

  export type ChatMessageCreateManyThreadInputEnvelope = {
    data: Enumerable<ChatMessageCreateManyThreadInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutThreadAttributesInput = {
    update: XOR<UserUpdateWithoutThreadAttributesInput, UserUncheckedUpdateWithoutThreadAttributesInput>
    create: XOR<UserCreateWithoutThreadAttributesInput, UserUncheckedCreateWithoutThreadAttributesInput>
  }

  export type UserUpdateWithoutThreadAttributesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutThreadAttributesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EnhancedDocumentUpsertWithoutThreadAttributesInput = {
    update: XOR<EnhancedDocumentUpdateWithoutThreadAttributesInput, EnhancedDocumentUncheckedUpdateWithoutThreadAttributesInput>
    create: XOR<EnhancedDocumentCreateWithoutThreadAttributesInput, EnhancedDocumentUncheckedCreateWithoutThreadAttributesInput>
  }

  export type EnhancedDocumentUpdateWithoutThreadAttributesInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutEnhancedDocumentNestedInput
  }

  export type EnhancedDocumentUncheckedUpdateWithoutThreadAttributesInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    notesContent?: JsonNullValueInput | InputJsonValue
    embeddingsByNodeID?: NullableJsonNullValueInput | InputJsonValue
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    draftContent?: NullableJsonNullValueInput | InputJsonValue
    draftCollapsed?: BoolFieldUpdateOperationsInput | boolean
    ideas?: EnhancedDocumentUpdateideasInput | Enumerable<string>
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutEnhancedDocumentNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutThreadInput, ChatMessageUncheckedUpdateWithoutThreadInput>
    create: XOR<ChatMessageCreateWithoutThreadInput, ChatMessageUncheckedCreateWithoutThreadInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutThreadInput, ChatMessageUncheckedUpdateWithoutThreadInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutThreadInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutChatMessageInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: Enumerable<ChatMessageScalarWhereInput>
    OR?: Enumerable<ChatMessageScalarWhereInput>
    NOT?: Enumerable<ChatMessageScalarWhereInput>
    chatMessageID?: StringFilter | string
    content?: StringFilter | string
    author?: EnumChatMessageAuthorFilter | ChatMessageAuthor
    createdAt?: DateTimeFilter | Date | string
    threadID?: StringFilter | string
  }

  export type ThreadAttributesCreateWithoutChatMessageInput = {
    threadID?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutThreadAttributesInput
    document: EnhancedDocumentCreateNestedOneWithoutThreadAttributesInput
  }

  export type ThreadAttributesUncheckedCreateWithoutChatMessageInput = {
    threadID?: string
    userID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    enhancedDocumentID: string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ThreadAttributesCreateOrConnectWithoutChatMessageInput = {
    where: ThreadAttributesWhereUniqueInput
    create: XOR<ThreadAttributesCreateWithoutChatMessageInput, ThreadAttributesUncheckedCreateWithoutChatMessageInput>
  }

  export type ThreadAttributesUpsertWithoutChatMessageInput = {
    update: XOR<ThreadAttributesUpdateWithoutChatMessageInput, ThreadAttributesUncheckedUpdateWithoutChatMessageInput>
    create: XOR<ThreadAttributesCreateWithoutChatMessageInput, ThreadAttributesUncheckedCreateWithoutChatMessageInput>
  }

  export type ThreadAttributesUpdateWithoutChatMessageInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutThreadAttributesNestedInput
    document?: EnhancedDocumentUpdateOneRequiredWithoutThreadAttributesNestedInput
  }

  export type ThreadAttributesUncheckedUpdateWithoutChatMessageInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DocumentCreateWithoutPublishedDocumentInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentInput
    notes?: NoteCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutPublishedDocumentInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
    notes?: NoteUncheckedCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutPublishedDocumentInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutPublishedDocumentInput, DocumentUncheckedCreateWithoutPublishedDocumentInput>
  }

  export type UserCreateWithoutPublishedDocumentInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPublishedDocumentInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPublishedDocumentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublishedDocumentInput, UserUncheckedCreateWithoutPublishedDocumentInput>
  }

  export type UserCreateWithoutPublishedDocumentLikesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPublishedDocumentLikesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPublishedDocumentLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublishedDocumentLikesInput, UserUncheckedCreateWithoutPublishedDocumentLikesInput>
  }

  export type DocumentUpsertWithoutPublishedDocumentInput = {
    update: XOR<DocumentUpdateWithoutPublishedDocumentInput, DocumentUncheckedUpdateWithoutPublishedDocumentInput>
    create: XOR<DocumentCreateWithoutPublishedDocumentInput, DocumentUncheckedCreateWithoutPublishedDocumentInput>
  }

  export type DocumentUpdateWithoutPublishedDocumentInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentNestedInput
    notes?: NoteUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutPublishedDocumentInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserUpsertWithoutPublishedDocumentInput = {
    update: XOR<UserUpdateWithoutPublishedDocumentInput, UserUncheckedUpdateWithoutPublishedDocumentInput>
    create: XOR<UserCreateWithoutPublishedDocumentInput, UserUncheckedCreateWithoutPublishedDocumentInput>
  }

  export type UserUpdateWithoutPublishedDocumentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPublishedDocumentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutPublishedDocumentLikesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutPublishedDocumentLikesInput, UserUncheckedUpdateWithoutPublishedDocumentLikesInput>
    create: XOR<UserCreateWithoutPublishedDocumentLikesInput, UserUncheckedCreateWithoutPublishedDocumentLikesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutPublishedDocumentLikesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutPublishedDocumentLikesInput, UserUncheckedUpdateWithoutPublishedDocumentLikesInput>
  }

  export type UserUpdateManyWithWhereWithoutPublishedDocumentLikesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLikingUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    userID?: StringFilter | string
    username?: StringNullableFilter | string | null
    appDrawerNoteIDs?: StringNullableListFilter
    firstName?: StringNullableFilter | string | null
    lastName?: StringNullableFilter | string | null
    email?: StringFilter | string
    longestStreak?: IntFilter | number
    bio?: StringNullableFilter | string | null
    city?: StringNullableFilter | string | null
    country?: StringNullableFilter | string | null
    website?: StringNullableFilter | string | null
    twitter?: StringNullableFilter | string | null
    instagram?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    openAIAPICalls?: IntFilter | number
  }

  export type UserCreateWithoutScratchpadEntryInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutScratchpadEntryInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutScratchpadEntryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutScratchpadEntryInput, UserUncheckedCreateWithoutScratchpadEntryInput>
  }

  export type UserUpsertWithoutScratchpadEntryInput = {
    update: XOR<UserUpdateWithoutScratchpadEntryInput, UserUncheckedUpdateWithoutScratchpadEntryInput>
    create: XOR<UserCreateWithoutScratchpadEntryInput, UserUncheckedCreateWithoutScratchpadEntryInput>
  }

  export type UserUpdateWithoutScratchpadEntryInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutScratchpadEntryInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type DocumentVersionCreateWithoutCommentsInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentVersionInput
    document: DocumentCreateNestedOneWithoutDocumentVersionsInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateWithoutCommentsInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    documentID: string
    versionName: string
    wordCount?: number
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentVersionInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionCreateOrConnectWithoutCommentsInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutCommentsInput, DocumentVersionUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentVersionUpsertWithoutCommentsInput = {
    update: XOR<DocumentVersionUpdateWithoutCommentsInput, DocumentVersionUncheckedUpdateWithoutCommentsInput>
    create: XOR<DocumentVersionCreateWithoutCommentsInput, DocumentVersionUncheckedCreateWithoutCommentsInput>
  }

  export type DocumentVersionUpdateWithoutCommentsInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentVersionNestedInput
    document?: DocumentUpdateOneRequiredWithoutDocumentVersionsNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutCommentsInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentVersionNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type UserCreateWithoutUserDocumentPermissionsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserDocumentPermissionsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserDocumentPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDocumentPermissionsInput, UserUncheckedCreateWithoutUserDocumentPermissionsInput>
  }

  export type DocumentVersionCreateWithoutUserDocumentPermissionsInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
    comments?: CommentCreateNestedManyWithoutDocumentVersionInput
    document: DocumentCreateNestedOneWithoutDocumentVersionsInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateWithoutUserDocumentPermissionsInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    documentID: string
    versionName: string
    wordCount?: number
    comments?: CommentUncheckedCreateNestedManyWithoutDocumentVersionInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionCreateOrConnectWithoutUserDocumentPermissionsInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutUserDocumentPermissionsInput, DocumentVersionUncheckedCreateWithoutUserDocumentPermissionsInput>
  }

  export type DocumentCreateWithoutUserDocumentPermissionsInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    notes?: NoteCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUserDocumentPermissionsInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    notes?: NoteUncheckedCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUserDocumentPermissionsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserDocumentPermissionsInput, DocumentUncheckedCreateWithoutUserDocumentPermissionsInput>
  }

  export type UserUpsertWithoutUserDocumentPermissionsInput = {
    update: XOR<UserUpdateWithoutUserDocumentPermissionsInput, UserUncheckedUpdateWithoutUserDocumentPermissionsInput>
    create: XOR<UserCreateWithoutUserDocumentPermissionsInput, UserUncheckedCreateWithoutUserDocumentPermissionsInput>
  }

  export type UserUpdateWithoutUserDocumentPermissionsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserDocumentPermissionsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentVersionUpsertWithoutUserDocumentPermissionsInput = {
    update: XOR<DocumentVersionUpdateWithoutUserDocumentPermissionsInput, DocumentVersionUncheckedUpdateWithoutUserDocumentPermissionsInput>
    create: XOR<DocumentVersionCreateWithoutUserDocumentPermissionsInput, DocumentVersionUncheckedCreateWithoutUserDocumentPermissionsInput>
  }

  export type DocumentVersionUpdateWithoutUserDocumentPermissionsInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutDocumentVersionNestedInput
    document?: DocumentUpdateOneRequiredWithoutDocumentVersionsNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutUserDocumentPermissionsInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutDocumentVersionNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentUpsertWithoutUserDocumentPermissionsInput = {
    update: XOR<DocumentUpdateWithoutUserDocumentPermissionsInput, DocumentUncheckedUpdateWithoutUserDocumentPermissionsInput>
    create: XOR<DocumentCreateWithoutUserDocumentPermissionsInput, DocumentUncheckedCreateWithoutUserDocumentPermissionsInput>
  }

  export type DocumentUpdateWithoutUserDocumentPermissionsInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    notes?: NoteUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUserDocumentPermissionsInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserCreateWithoutUserNotePermissionInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserNotePermissionInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserNotePermissionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserNotePermissionInput, UserUncheckedCreateWithoutUserNotePermissionInput>
  }

  export type NoteCreateWithoutUserNotePermissionsInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    personal?: boolean
    document: DocumentCreateNestedOneWithoutNotesInput
  }

  export type NoteUncheckedCreateWithoutUserNotePermissionsInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    documentID: string
    personal?: boolean
  }

  export type NoteCreateOrConnectWithoutUserNotePermissionsInput = {
    where: NoteWhereUniqueInput
    create: XOR<NoteCreateWithoutUserNotePermissionsInput, NoteUncheckedCreateWithoutUserNotePermissionsInput>
  }

  export type UserUpsertWithoutUserNotePermissionInput = {
    update: XOR<UserUpdateWithoutUserNotePermissionInput, UserUncheckedUpdateWithoutUserNotePermissionInput>
    create: XOR<UserCreateWithoutUserNotePermissionInput, UserUncheckedCreateWithoutUserNotePermissionInput>
  }

  export type UserUpdateWithoutUserNotePermissionInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserNotePermissionInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NoteUpsertWithoutUserNotePermissionsInput = {
    update: XOR<NoteUpdateWithoutUserNotePermissionsInput, NoteUncheckedUpdateWithoutUserNotePermissionsInput>
    create: XOR<NoteCreateWithoutUserNotePermissionsInput, NoteUncheckedCreateWithoutUserNotePermissionsInput>
  }

  export type NoteUpdateWithoutUserNotePermissionsInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: BoolFieldUpdateOperationsInput | boolean
    document?: DocumentUpdateOneRequiredWithoutNotesNestedInput
  }

  export type NoteUncheckedUpdateWithoutUserNotePermissionsInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    personal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DocumentCreateWithoutUserDocumentAttributesInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentInput
    notes?: NoteCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUserDocumentAttributesInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
    notes?: NoteUncheckedCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUserDocumentAttributesInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserDocumentAttributesInput, DocumentUncheckedCreateWithoutUserDocumentAttributesInput>
  }

  export type UserCreateWithoutUserDocumentAttributesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserDocumentAttributesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserDocumentAttributesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserDocumentAttributesInput, UserUncheckedCreateWithoutUserDocumentAttributesInput>
  }

  export type DocumentVersionCreateWithoutUserDocumentAttributesInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
    comments?: CommentCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentVersionInput
    document: DocumentCreateNestedOneWithoutDocumentVersionsInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateWithoutUserDocumentAttributesInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    documentID: string
    versionName: string
    wordCount?: number
    comments?: CommentUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentVersionInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentVersionInput
  }

  export type DocumentVersionCreateOrConnectWithoutUserDocumentAttributesInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutUserDocumentAttributesInput, DocumentVersionUncheckedCreateWithoutUserDocumentAttributesInput>
  }

  export type DocumentUpsertWithoutUserDocumentAttributesInput = {
    update: XOR<DocumentUpdateWithoutUserDocumentAttributesInput, DocumentUncheckedUpdateWithoutUserDocumentAttributesInput>
    create: XOR<DocumentCreateWithoutUserDocumentAttributesInput, DocumentUncheckedCreateWithoutUserDocumentAttributesInput>
  }

  export type DocumentUpdateWithoutUserDocumentAttributesInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentNestedInput
    notes?: NoteUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUserDocumentAttributesInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserUpsertWithoutUserDocumentAttributesInput = {
    update: XOR<UserUpdateWithoutUserDocumentAttributesInput, UserUncheckedUpdateWithoutUserDocumentAttributesInput>
    create: XOR<UserCreateWithoutUserDocumentAttributesInput, UserUncheckedCreateWithoutUserDocumentAttributesInput>
  }

  export type UserUpdateWithoutUserDocumentAttributesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserDocumentAttributesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentVersionUpsertWithoutUserDocumentAttributesInput = {
    update: XOR<DocumentVersionUpdateWithoutUserDocumentAttributesInput, DocumentVersionUncheckedUpdateWithoutUserDocumentAttributesInput>
    create: XOR<DocumentVersionCreateWithoutUserDocumentAttributesInput, DocumentVersionUncheckedCreateWithoutUserDocumentAttributesInput>
  }

  export type DocumentVersionUpdateWithoutUserDocumentAttributesInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentVersionNestedInput
    document?: DocumentUpdateOneRequiredWithoutDocumentVersionsNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutUserDocumentAttributesInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentVersionNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentVersionNestedInput
  }

  export type UserCreateWithoutStatUnitInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStatUnitInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStatUnitInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStatUnitInput, UserUncheckedCreateWithoutStatUnitInput>
  }

  export type DocumentVersionCreateWithoutStatUnitInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
    comments?: CommentCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentVersionInput
    document: DocumentCreateNestedOneWithoutDocumentVersionsInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateWithoutStatUnitInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    documentID: string
    versionName: string
    wordCount?: number
    comments?: CommentUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentVersionInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutLastOpenedDocumentVersionInput
  }

  export type DocumentVersionCreateOrConnectWithoutStatUnitInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutStatUnitInput, DocumentVersionUncheckedCreateWithoutStatUnitInput>
  }

  export type DocumentCreateWithoutStatUnitInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentInput
    notes?: NoteCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutStatUnitInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
    notes?: NoteUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput
    WritingSession?: WritingSessionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutStatUnitInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutStatUnitInput, DocumentUncheckedCreateWithoutStatUnitInput>
  }

  export type DailyChallengeResponseCreateWithoutDailyStatUnitInput = {
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    user?: UserCreateNestedOneWithoutDailyChallengeResponseInput
    likes?: DailyChallengeResponseLikesCreateNestedManyWithoutDailyChallengeResponseInput
    dailyChallenge: DailyChallengeCreateNestedOneWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseUncheckedCreateWithoutDailyStatUnitInput = {
    userID?: string | null
    dailyChallengeID: number
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    likes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseCreateOrConnectWithoutDailyStatUnitInput = {
    where: DailyChallengeResponseWhereUniqueInput
    create: XOR<DailyChallengeResponseCreateWithoutDailyStatUnitInput, DailyChallengeResponseUncheckedCreateWithoutDailyStatUnitInput>
  }

  export type UserUpsertWithoutStatUnitInput = {
    update: XOR<UserUpdateWithoutStatUnitInput, UserUncheckedUpdateWithoutStatUnitInput>
    create: XOR<UserCreateWithoutStatUnitInput, UserUncheckedCreateWithoutStatUnitInput>
  }

  export type UserUpdateWithoutStatUnitInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStatUnitInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentVersionUpsertWithoutStatUnitInput = {
    update: XOR<DocumentVersionUpdateWithoutStatUnitInput, DocumentVersionUncheckedUpdateWithoutStatUnitInput>
    create: XOR<DocumentVersionCreateWithoutStatUnitInput, DocumentVersionUncheckedCreateWithoutStatUnitInput>
  }

  export type DocumentVersionUpdateWithoutStatUnitInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentVersionNestedInput
    document?: DocumentUpdateOneRequiredWithoutDocumentVersionsNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutStatUnitInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentID?: StringFieldUpdateOperationsInput | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentUpsertWithoutStatUnitInput = {
    update: XOR<DocumentUpdateWithoutStatUnitInput, DocumentUncheckedUpdateWithoutStatUnitInput>
    create: XOR<DocumentCreateWithoutStatUnitInput, DocumentUncheckedCreateWithoutStatUnitInput>
  }

  export type DocumentUpdateWithoutStatUnitInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentNestedInput
    notes?: NoteUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutStatUnitInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput
    WritingSession?: WritingSessionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DailyChallengeResponseUpsertWithoutDailyStatUnitInput = {
    update: XOR<DailyChallengeResponseUpdateWithoutDailyStatUnitInput, DailyChallengeResponseUncheckedUpdateWithoutDailyStatUnitInput>
    create: XOR<DailyChallengeResponseCreateWithoutDailyStatUnitInput, DailyChallengeResponseUncheckedCreateWithoutDailyStatUnitInput>
  }

  export type DailyChallengeResponseUpdateWithoutDailyStatUnitInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutDailyChallengeResponseNestedInput
    likes?: DailyChallengeResponseLikesUpdateManyWithoutDailyChallengeResponseNestedInput
    dailyChallenge?: DailyChallengeUpdateOneRequiredWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseUncheckedUpdateWithoutDailyStatUnitInput = {
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeID?: IntFieldUpdateOperationsInput | number
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    likes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type UserCreateWithoutWritingSessionsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWritingSessionsInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWritingSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWritingSessionsInput, UserUncheckedCreateWithoutWritingSessionsInput>
  }

  export type DocumentCreateWithoutWritingSessionInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutDocumentInput
    notes?: NoteCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutWritingSessionInput = {
    documentID?: string
    title: string
    updatedAt?: Date | string
    documentVersions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutDocumentInput
    notes?: NoteUncheckedCreateNestedManyWithoutDocumentInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDocumentInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutDocumentInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutWritingSessionInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutWritingSessionInput, DocumentUncheckedCreateWithoutWritingSessionInput>
  }

  export type UserCreateWithoutWritingSessionLikesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWritingSessionLikesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWritingSessionLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWritingSessionLikesInput, UserUncheckedCreateWithoutWritingSessionLikesInput>
  }

  export type UserUpsertWithoutWritingSessionsInput = {
    update: XOR<UserUpdateWithoutWritingSessionsInput, UserUncheckedUpdateWithoutWritingSessionsInput>
    create: XOR<UserCreateWithoutWritingSessionsInput, UserUncheckedCreateWithoutWritingSessionsInput>
  }

  export type UserUpdateWithoutWritingSessionsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWritingSessionsInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentUpsertWithoutWritingSessionInput = {
    update: XOR<DocumentUpdateWithoutWritingSessionInput, DocumentUncheckedUpdateWithoutWritingSessionInput>
    create: XOR<DocumentCreateWithoutWritingSessionInput, DocumentUncheckedCreateWithoutWritingSessionInput>
  }

  export type DocumentUpdateWithoutWritingSessionInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentNestedInput
    notes?: NoteUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutWritingSessionInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentVersions?: DocumentVersionUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentNestedInput
    notes?: NoteUncheckedUpdateManyWithoutDocumentNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutDocumentNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutWritingSessionLikesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutWritingSessionLikesInput, UserUncheckedUpdateWithoutWritingSessionLikesInput>
    create: XOR<UserCreateWithoutWritingSessionLikesInput, UserUncheckedCreateWithoutWritingSessionLikesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutWritingSessionLikesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutWritingSessionLikesInput, UserUncheckedUpdateWithoutWritingSessionLikesInput>
  }

  export type UserUpdateManyWithWhereWithoutWritingSessionLikesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLikesInput>
  }

  export type DailyChallengeResponseCreateWithoutDailyChallengeInput = {
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    user?: UserCreateNestedOneWithoutDailyChallengeResponseInput
    likes?: DailyChallengeResponseLikesCreateNestedManyWithoutDailyChallengeResponseInput
    dailyStatUnit?: DailyStatUnitCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseUncheckedCreateWithoutDailyChallengeInput = {
    userID?: string | null
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    likes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
    dailyStatUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseCreateOrConnectWithoutDailyChallengeInput = {
    where: DailyChallengeResponseWhereUniqueInput
    create: XOR<DailyChallengeResponseCreateWithoutDailyChallengeInput, DailyChallengeResponseUncheckedCreateWithoutDailyChallengeInput>
  }

  export type DailyChallengeResponseCreateManyDailyChallengeInputEnvelope = {
    data: Enumerable<DailyChallengeResponseCreateManyDailyChallengeInput>
    skipDuplicates?: boolean
  }

  export type DailyChallengeResponseUpsertWithWhereUniqueWithoutDailyChallengeInput = {
    where: DailyChallengeResponseWhereUniqueInput
    update: XOR<DailyChallengeResponseUpdateWithoutDailyChallengeInput, DailyChallengeResponseUncheckedUpdateWithoutDailyChallengeInput>
    create: XOR<DailyChallengeResponseCreateWithoutDailyChallengeInput, DailyChallengeResponseUncheckedCreateWithoutDailyChallengeInput>
  }

  export type DailyChallengeResponseUpdateWithWhereUniqueWithoutDailyChallengeInput = {
    where: DailyChallengeResponseWhereUniqueInput
    data: XOR<DailyChallengeResponseUpdateWithoutDailyChallengeInput, DailyChallengeResponseUncheckedUpdateWithoutDailyChallengeInput>
  }

  export type DailyChallengeResponseUpdateManyWithWhereWithoutDailyChallengeInput = {
    where: DailyChallengeResponseScalarWhereInput
    data: XOR<DailyChallengeResponseUpdateManyMutationInput, DailyChallengeResponseUncheckedUpdateManyWithoutDailyChallengeResponseInput>
  }

  export type UserCreateWithoutDailyChallengeResponseLikesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyChallengeResponseLikesInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyChallengeResponseLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyChallengeResponseLikesInput, UserUncheckedCreateWithoutDailyChallengeResponseLikesInput>
  }

  export type DailyChallengeResponseCreateWithoutLikesInput = {
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    user?: UserCreateNestedOneWithoutDailyChallengeResponseInput
    dailyChallenge: DailyChallengeCreateNestedOneWithoutDailyChallengeResponseInput
    dailyStatUnit?: DailyStatUnitCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseUncheckedCreateWithoutLikesInput = {
    userID?: string | null
    dailyChallengeID: number
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
    dailyStatUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutDailyChallengeResponseInput
  }

  export type DailyChallengeResponseCreateOrConnectWithoutLikesInput = {
    where: DailyChallengeResponseWhereUniqueInput
    create: XOR<DailyChallengeResponseCreateWithoutLikesInput, DailyChallengeResponseUncheckedCreateWithoutLikesInput>
  }

  export type UserUpsertWithoutDailyChallengeResponseLikesInput = {
    update: XOR<UserUpdateWithoutDailyChallengeResponseLikesInput, UserUncheckedUpdateWithoutDailyChallengeResponseLikesInput>
    create: XOR<UserCreateWithoutDailyChallengeResponseLikesInput, UserUncheckedCreateWithoutDailyChallengeResponseLikesInput>
  }

  export type UserUpdateWithoutDailyChallengeResponseLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyChallengeResponseLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DailyChallengeResponseUpsertWithoutLikesInput = {
    update: XOR<DailyChallengeResponseUpdateWithoutLikesInput, DailyChallengeResponseUncheckedUpdateWithoutLikesInput>
    create: XOR<DailyChallengeResponseCreateWithoutLikesInput, DailyChallengeResponseUncheckedCreateWithoutLikesInput>
  }

  export type DailyChallengeResponseUpdateWithoutLikesInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutDailyChallengeResponseNestedInput
    dailyChallenge?: DailyChallengeUpdateOneRequiredWithoutDailyChallengeResponseNestedInput
    dailyStatUnit?: DailyStatUnitUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseUncheckedUpdateWithoutLikesInput = {
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeID?: IntFieldUpdateOperationsInput | number
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    dailyStatUnit?: DailyStatUnitUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type UserCreateWithoutDailyChallengeResponseInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyChallengeResponseInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyChallengeResponseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyChallengeResponseInput, UserUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type DailyChallengeResponseLikesCreateWithoutDailyChallengeResponseInput = {
    likeID?: string
    user: UserCreateNestedOneWithoutDailyChallengeResponseLikesInput
  }

  export type DailyChallengeResponseLikesUncheckedCreateWithoutDailyChallengeResponseInput = {
    userID: string
    likeID?: string
  }

  export type DailyChallengeResponseLikesCreateOrConnectWithoutDailyChallengeResponseInput = {
    where: DailyChallengeResponseLikesWhereUniqueInput
    create: XOR<DailyChallengeResponseLikesCreateWithoutDailyChallengeResponseInput, DailyChallengeResponseLikesUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type DailyChallengeResponseLikesCreateManyDailyChallengeResponseInputEnvelope = {
    data: Enumerable<DailyChallengeResponseLikesCreateManyDailyChallengeResponseInput>
    skipDuplicates?: boolean
  }

  export type DailyChallengeCreateWithoutDailyChallengeResponseInput = {
    prompt: string
    date?: Date | string
  }

  export type DailyChallengeUncheckedCreateWithoutDailyChallengeResponseInput = {
    prompt: string
    date?: Date | string
    id?: number
  }

  export type DailyChallengeCreateOrConnectWithoutDailyChallengeResponseInput = {
    where: DailyChallengeWhereUniqueInput
    create: XOR<DailyChallengeCreateWithoutDailyChallengeResponseInput, DailyChallengeUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type DailyStatUnitCreateWithoutDailyChallengeResponseInput = {
    dailyStatUnitID?: string
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
    user: UserCreateNestedOneWithoutStatUnitInput
    documentVersion?: DocumentVersionCreateNestedOneWithoutStatUnitInput
    document?: DocumentCreateNestedOneWithoutStatUnitInput
  }

  export type DailyStatUnitUncheckedCreateWithoutDailyChallengeResponseInput = {
    dailyStatUnitID?: string
    userID: string
    documentVersionID?: string | null
    documentID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type DailyStatUnitCreateOrConnectWithoutDailyChallengeResponseInput = {
    where: DailyStatUnitWhereUniqueInput
    create: XOR<DailyStatUnitCreateWithoutDailyChallengeResponseInput, DailyStatUnitUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type DailyStatUnitCreateManyDailyChallengeResponseInputEnvelope = {
    data: Enumerable<DailyStatUnitCreateManyDailyChallengeResponseInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDailyChallengeResponseInput = {
    update: XOR<UserUpdateWithoutDailyChallengeResponseInput, UserUncheckedUpdateWithoutDailyChallengeResponseInput>
    create: XOR<UserCreateWithoutDailyChallengeResponseInput, UserUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type UserUpdateWithoutDailyChallengeResponseInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyChallengeResponseInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DailyChallengeResponseLikesUpsertWithWhereUniqueWithoutDailyChallengeResponseInput = {
    where: DailyChallengeResponseLikesWhereUniqueInput
    update: XOR<DailyChallengeResponseLikesUpdateWithoutDailyChallengeResponseInput, DailyChallengeResponseLikesUncheckedUpdateWithoutDailyChallengeResponseInput>
    create: XOR<DailyChallengeResponseLikesCreateWithoutDailyChallengeResponseInput, DailyChallengeResponseLikesUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type DailyChallengeResponseLikesUpdateWithWhereUniqueWithoutDailyChallengeResponseInput = {
    where: DailyChallengeResponseLikesWhereUniqueInput
    data: XOR<DailyChallengeResponseLikesUpdateWithoutDailyChallengeResponseInput, DailyChallengeResponseLikesUncheckedUpdateWithoutDailyChallengeResponseInput>
  }

  export type DailyChallengeResponseLikesUpdateManyWithWhereWithoutDailyChallengeResponseInput = {
    where: DailyChallengeResponseLikesScalarWhereInput
    data: XOR<DailyChallengeResponseLikesUpdateManyMutationInput, DailyChallengeResponseLikesUncheckedUpdateManyWithoutLikesInput>
  }

  export type DailyChallengeUpsertWithoutDailyChallengeResponseInput = {
    update: XOR<DailyChallengeUpdateWithoutDailyChallengeResponseInput, DailyChallengeUncheckedUpdateWithoutDailyChallengeResponseInput>
    create: XOR<DailyChallengeCreateWithoutDailyChallengeResponseInput, DailyChallengeUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type DailyChallengeUpdateWithoutDailyChallengeResponseInput = {
    prompt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyChallengeUncheckedUpdateWithoutDailyChallengeResponseInput = {
    prompt?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: IntFieldUpdateOperationsInput | number
  }

  export type DailyStatUnitUpsertWithWhereUniqueWithoutDailyChallengeResponseInput = {
    where: DailyStatUnitWhereUniqueInput
    update: XOR<DailyStatUnitUpdateWithoutDailyChallengeResponseInput, DailyStatUnitUncheckedUpdateWithoutDailyChallengeResponseInput>
    create: XOR<DailyStatUnitCreateWithoutDailyChallengeResponseInput, DailyStatUnitUncheckedCreateWithoutDailyChallengeResponseInput>
  }

  export type DailyStatUnitUpdateWithWhereUniqueWithoutDailyChallengeResponseInput = {
    where: DailyStatUnitWhereUniqueInput
    data: XOR<DailyStatUnitUpdateWithoutDailyChallengeResponseInput, DailyStatUnitUncheckedUpdateWithoutDailyChallengeResponseInput>
  }

  export type DailyStatUnitUpdateManyWithWhereWithoutDailyChallengeResponseInput = {
    where: DailyStatUnitScalarWhereInput
    data: XOR<DailyStatUnitUpdateManyMutationInput, DailyStatUnitUncheckedUpdateManyWithoutDailyStatUnitInput>
  }

  export type UserCreateWithoutDailyChallengePromptSuggestionInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesCreateNestedManyWithoutUserInput
    followedBy?: FollowsCreateNestedManyWithoutFollowingInput
    following?: FollowsCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDailyChallengePromptSuggestionInput = {
    userID?: string
    username?: string | null
    appDrawerNoteIDs?: UserCreateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: string | null
    lastName?: string | null
    email: string
    longestStreak?: number
    bio?: string | null
    city?: string | null
    country?: string | null
    website?: string | null
    twitter?: string | null
    instagram?: string | null
    createdAt?: Date | string
    openAIAPICalls?: number
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedCreateNestedManyWithoutUserInput
    userNotePermission?: UserNotePermissionUncheckedCreateNestedManyWithoutUserInput
    statUnit?: DailyStatUnitUncheckedCreateNestedManyWithoutUserInput
    scratchpadEntry?: ScratchpadEntryUncheckedCreateNestedManyWithoutUserInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedCreateNestedManyWithoutUserInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedCreateNestedManyWithoutUserInput
    followedBy?: FollowsUncheckedCreateNestedManyWithoutFollowingInput
    following?: FollowsUncheckedCreateNestedManyWithoutFollowerInput
    PublishedDocument?: PublishedDocumentUncheckedCreateNestedManyWithoutUserInput
    publishedDocumentLikes?: PublishedDocumentUncheckedCreateNestedManyWithoutLikingUsersInput
    writingSessions?: WritingSessionUncheckedCreateNestedManyWithoutUserInput
    writingSessionLikes?: WritingSessionUncheckedCreateNestedManyWithoutLikesInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedCreateNestedManyWithoutUserInput
    threadAttributes?: ThreadAttributesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDailyChallengePromptSuggestionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyChallengePromptSuggestionInput, UserUncheckedCreateWithoutDailyChallengePromptSuggestionInput>
  }

  export type UserUpsertWithoutDailyChallengePromptSuggestionInput = {
    update: XOR<UserUpdateWithoutDailyChallengePromptSuggestionInput, UserUncheckedUpdateWithoutDailyChallengePromptSuggestionInput>
    create: XOR<UserCreateWithoutDailyChallengePromptSuggestionInput, UserUncheckedCreateWithoutDailyChallengePromptSuggestionInput>
  }

  export type UserUpdateWithoutDailyChallengePromptSuggestionInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyChallengePromptSuggestionInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateManyAuthorInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    documentVersionID: string
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
  }

  export type UserDocumentPermissionCreateManyUserInput = {
    userDocumentPermissionID?: string
    documentVersionID?: string | null
    role: Role
    documentID?: string | null
  }

  export type UserNotePermissionCreateManyUserInput = {
    userNotePermissionID?: string
    role: NoteRole
    noteID: string
  }

  export type DailyStatUnitCreateManyUserInput = {
    dailyStatUnitID?: string
    documentVersionID?: string | null
    documentID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type ScratchpadEntryCreateManyUserInput = {
    scratchpadEntryID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    date: Date | string
  }

  export type UserDocumentAttributesCreateManyUserInput = {
    documentID: string
    lastOpenedDocumentVersionID: string
  }

  export type DailyChallengeResponseCreateManyUserInput = {
    dailyChallengeID: number
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
  }

  export type DailyChallengeResponseLikesCreateManyUserInput = {
    dailyChallengeResponseID: string
    likeID?: string
  }

  export type DailyChallengePromptSuggestionCreateManyUserInput = {
    promptSuggestionID?: string
    prompt: string
    createdAt?: Date | string
    usedOn?: Date | string | null
  }

  export type FollowsCreateManyFollowingInput = {
    followerID: string
  }

  export type FollowsCreateManyFollowerInput = {
    followingID: string
  }

  export type PublishedDocumentCreateManyUserInput = {
    publishedDocumentID?: string
    documentID: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
  }

  export type WritingSessionCreateManyUserInput = {
    writingSessionID?: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    documentID?: string | null
    inProgress?: boolean
    updatedAt?: Date | string
  }

  export type UserEnhancedDocumentPermissionsCreateManyUserInput = {
    enhancedDocumentID: string
    role: EnhancedDocumentRole
  }

  export type ThreadAttributesCreateManyUserInput = {
    threadID?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    enhancedDocumentID: string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutAuthorInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
    documentVersion?: DocumentVersionUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    documentVersionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutCommentsInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    documentVersionID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
  }

  export type UserDocumentPermissionUpdateWithoutUserInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    documentVersion?: DocumentVersionUpdateOneWithoutUserDocumentPermissionsNestedInput
    document?: DocumentUpdateOneWithoutUserDocumentPermissionsNestedInput
  }

  export type UserDocumentPermissionUncheckedUpdateWithoutUserInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserDocumentPermissionUncheckedUpdateManyWithoutUserDocumentPermissionsInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserNotePermissionUpdateWithoutUserInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
    note?: NoteUpdateOneRequiredWithoutUserNotePermissionsNestedInput
  }

  export type UserNotePermissionUncheckedUpdateWithoutUserInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
    noteID?: StringFieldUpdateOperationsInput | string
  }

  export type UserNotePermissionUncheckedUpdateManyWithoutUserNotePermissionInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
    noteID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyStatUnitUpdateWithoutUserInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    documentVersion?: DocumentVersionUpdateOneWithoutStatUnitNestedInput
    document?: DocumentUpdateOneWithoutStatUnitNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateOneWithoutDailyStatUnitNestedInput
  }

  export type DailyStatUnitUncheckedUpdateWithoutUserInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeResponseID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type DailyStatUnitUncheckedUpdateManyWithoutStatUnitInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeResponseID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type ScratchpadEntryUpdateWithoutUserInput = {
    scratchpadEntryID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScratchpadEntryUncheckedUpdateWithoutUserInput = {
    scratchpadEntryID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScratchpadEntryUncheckedUpdateManyWithoutScratchpadEntryInput = {
    scratchpadEntryID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentAttributesUpdateWithoutUserInput = {
    document?: DocumentUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
    lastOpenedDocumentVersion?: DocumentVersionUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
  }

  export type UserDocumentAttributesUncheckedUpdateWithoutUserInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    lastOpenedDocumentVersionID?: StringFieldUpdateOperationsInput | string
  }

  export type UserDocumentAttributesUncheckedUpdateManyWithoutUserDocumentAttributesInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    lastOpenedDocumentVersionID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengeResponseUpdateWithoutUserInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    likes?: DailyChallengeResponseLikesUpdateManyWithoutDailyChallengeResponseNestedInput
    dailyChallenge?: DailyChallengeUpdateOneRequiredWithoutDailyChallengeResponseNestedInput
    dailyStatUnit?: DailyStatUnitUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseUncheckedUpdateWithoutUserInput = {
    dailyChallengeID?: IntFieldUpdateOperationsInput | number
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    likes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
    dailyStatUnit?: DailyStatUnitUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseUncheckedUpdateManyWithoutDailyChallengeResponseInput = {
    dailyChallengeID?: IntFieldUpdateOperationsInput | number
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyChallengeResponseLikesUpdateWithoutUserInput = {
    likeID?: StringFieldUpdateOperationsInput | string
    dailyChallengeResponse?: DailyChallengeResponseUpdateOneRequiredWithoutLikesNestedInput
  }

  export type DailyChallengeResponseLikesUncheckedUpdateWithoutUserInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    likeID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengeResponseLikesUncheckedUpdateManyWithoutDailyChallengeResponseLikesInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    likeID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengePromptSuggestionUpdateWithoutUserInput = {
    promptSuggestionID?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengePromptSuggestionUncheckedUpdateWithoutUserInput = {
    promptSuggestionID?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DailyChallengePromptSuggestionUncheckedUpdateManyWithoutDailyChallengePromptSuggestionInput = {
    promptSuggestionID?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FollowsUpdateWithoutFollowingInput = {
    follower?: UserUpdateOneRequiredWithoutFollowingNestedInput
  }

  export type FollowsUncheckedUpdateWithoutFollowingInput = {
    followerID?: StringFieldUpdateOperationsInput | string
  }

  export type FollowsUncheckedUpdateManyWithoutFollowedByInput = {
    followerID?: StringFieldUpdateOperationsInput | string
  }

  export type FollowsUpdateWithoutFollowerInput = {
    following?: UserUpdateOneRequiredWithoutFollowedByNestedInput
  }

  export type FollowsUncheckedUpdateWithoutFollowerInput = {
    followingID?: StringFieldUpdateOperationsInput | string
  }

  export type FollowsUncheckedUpdateManyWithoutFollowingInput = {
    followingID?: StringFieldUpdateOperationsInput | string
  }

  export type PublishedDocumentUpdateWithoutUserInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentUpdateOneRequiredWithoutPublishedDocumentNestedInput
    likingUsers?: UserUpdateManyWithoutPublishedDocumentLikesNestedInput
  }

  export type PublishedDocumentUncheckedUpdateWithoutUserInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    documentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    likingUsers?: UserUncheckedUpdateManyWithoutPublishedDocumentLikesNestedInput
  }

  export type PublishedDocumentUncheckedUpdateManyWithoutPublishedDocumentInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    documentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublishedDocumentUpdateWithoutLikingUsersInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    document?: DocumentUpdateOneRequiredWithoutPublishedDocumentNestedInput
    user?: UserUpdateOneRequiredWithoutPublishedDocumentNestedInput
  }

  export type PublishedDocumentUncheckedUpdateWithoutLikingUsersInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    documentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublishedDocumentUncheckedUpdateManyWithoutPublishedDocumentLikesInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    documentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WritingSessionUpdateWithoutUserInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneWithoutWritingSessionNestedInput
    likes?: UserUpdateManyWithoutWritingSessionLikesNestedInput
  }

  export type WritingSessionUncheckedUpdateWithoutUserInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserUncheckedUpdateManyWithoutWritingSessionLikesNestedInput
  }

  export type WritingSessionUncheckedUpdateManyWithoutWritingSessionsInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WritingSessionUpdateWithoutLikesInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWritingSessionsNestedInput
    document?: DocumentUpdateOneWithoutWritingSessionNestedInput
  }

  export type WritingSessionUncheckedUpdateWithoutLikesInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WritingSessionUncheckedUpdateManyWithoutWritingSessionLikesInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEnhancedDocumentPermissionsUpdateWithoutUserInput = {
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
    enhancedDocument?: EnhancedDocumentUpdateOneRequiredWithoutUserEnhancedDocumentPermissionsNestedInput
  }

  export type UserEnhancedDocumentPermissionsUncheckedUpdateWithoutUserInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
  }

  export type UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserEnhancedDocumentPermissionsInput = {
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
  }

  export type ThreadAttributesUpdateWithoutUserInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    document?: EnhancedDocumentUpdateOneRequiredWithoutThreadAttributesNestedInput
    chatMessage?: ChatMessageUpdateManyWithoutThreadNestedInput
  }

  export type ThreadAttributesUncheckedUpdateWithoutUserInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    chatMessage?: ChatMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ThreadAttributesUncheckedUpdateManyWithoutThreadAttributesInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enhancedDocumentID?: StringFieldUpdateOperationsInput | string
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserNotePermissionCreateManyNoteInput = {
    userNotePermissionID?: string
    userID: string
    role: NoteRole
  }

  export type UserNotePermissionUpdateWithoutNoteInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
    user?: UserUpdateOneRequiredWithoutUserNotePermissionNestedInput
  }

  export type UserNotePermissionUncheckedUpdateWithoutNoteInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
  }

  export type UserNotePermissionUncheckedUpdateManyWithoutUserNotePermissionsInput = {
    userNotePermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    role?: EnumNoteRoleFieldUpdateOperationsInput | NoteRole
  }

  export type CommentCreateManyDocumentVersionInput = {
    commentID?: string
    commentData: JsonNullValueInput | InputJsonValue
    authorID: string
    updatedAt?: Date | string
    private: boolean
    resolved?: boolean
    selectedText: string
  }

  export type UserDocumentPermissionCreateManyDocumentVersionInput = {
    userDocumentPermissionID?: string
    userID: string
    role: Role
    documentID?: string | null
  }

  export type DailyStatUnitCreateManyDocumentVersionInput = {
    dailyStatUnitID?: string
    userID: string
    documentID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type UserDocumentAttributesCreateManyLastOpenedDocumentVersionInput = {
    documentID: string
    userID: string
  }

  export type CommentUpdateWithoutDocumentVersionInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutDocumentVersionInput = {
    commentID?: StringFieldUpdateOperationsInput | string
    commentData?: JsonNullValueInput | InputJsonValue
    authorID?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    private?: BoolFieldUpdateOperationsInput | boolean
    resolved?: BoolFieldUpdateOperationsInput | boolean
    selectedText?: StringFieldUpdateOperationsInput | string
  }

  export type UserDocumentPermissionUpdateWithoutDocumentVersionInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    user?: UserUpdateOneRequiredWithoutUserDocumentPermissionsNestedInput
    document?: DocumentUpdateOneWithoutUserDocumentPermissionsNestedInput
  }

  export type UserDocumentPermissionUncheckedUpdateWithoutDocumentVersionInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DailyStatUnitUpdateWithoutDocumentVersionInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStatUnitNestedInput
    document?: DocumentUpdateOneWithoutStatUnitNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateOneWithoutDailyStatUnitNestedInput
  }

  export type DailyStatUnitUncheckedUpdateWithoutDocumentVersionInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeResponseID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type UserDocumentAttributesUpdateWithoutLastOpenedDocumentVersionInput = {
    document?: DocumentUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
    user?: UserUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
  }

  export type UserDocumentAttributesUncheckedUpdateWithoutLastOpenedDocumentVersionInput = {
    documentID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentVersionCreateManyDocumentInput = {
    documentVersionID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: Date | string
    createdAt?: Date | string
    versionName: string
    wordCount?: number
  }

  export type UserDocumentPermissionCreateManyDocumentInput = {
    userDocumentPermissionID?: string
    userID: string
    documentVersionID?: string | null
    role: Role
  }

  export type NoteCreateManyDocumentInput = {
    noteID?: string
    title?: string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: string | null
    updatedAt?: Date | string
    personal?: boolean
  }

  export type DailyStatUnitCreateManyDocumentInput = {
    dailyStatUnitID?: string
    userID: string
    documentVersionID?: string | null
    dailyChallengeResponseID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type UserDocumentAttributesCreateManyDocumentInput = {
    userID: string
    lastOpenedDocumentVersionID: string
  }

  export type PublishedDocumentCreateManyDocumentInput = {
    publishedDocumentID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    url: string
    userID: string
    publishedAt?: Date | string
    updatedAt?: Date | string
    title: string
    subtitle?: string | null
  }

  export type WritingSessionCreateManyDocumentInput = {
    writingSessionID?: string
    userID: string
    segmentTime?: WritingSessionCreatesegmentTimeInput | Enumerable<number>
    wordsAdded?: number
    wordsRemoved?: number
    timeSpentSeconds?: number
    startDateTime?: Date | string
    title: string
    inProgress?: boolean
    updatedAt?: Date | string
  }

  export type DocumentVersionUpdateWithoutDocumentInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutDocumentVersionNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutDocumentInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutDocumentVersionNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutDocumentVersionNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutLastOpenedDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateManyWithoutDocumentVersionsInput = {
    documentVersionID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versionName?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserDocumentPermissionUpdateWithoutDocumentInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | Role
    user?: UserUpdateOneRequiredWithoutUserDocumentPermissionsNestedInput
    documentVersion?: DocumentVersionUpdateOneWithoutUserDocumentPermissionsNestedInput
  }

  export type UserDocumentPermissionUncheckedUpdateWithoutDocumentInput = {
    userDocumentPermissionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | Role
  }

  export type NoteUpdateWithoutDocumentInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: BoolFieldUpdateOperationsInput | boolean
    userNotePermissions?: UserNotePermissionUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateWithoutDocumentInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: BoolFieldUpdateOperationsInput | boolean
    userNotePermissions?: UserNotePermissionUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type NoteUncheckedUpdateManyWithoutNotesInput = {
    noteID?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableJsonNullValueInput | InputJsonValue
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    personal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type DailyStatUnitUpdateWithoutDocumentInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStatUnitNestedInput
    documentVersion?: DocumentVersionUpdateOneWithoutStatUnitNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateOneWithoutDailyStatUnitNestedInput
  }

  export type DailyStatUnitUncheckedUpdateWithoutDocumentInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeResponseID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type UserDocumentAttributesUpdateWithoutDocumentInput = {
    user?: UserUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
    lastOpenedDocumentVersion?: DocumentVersionUpdateOneRequiredWithoutUserDocumentAttributesNestedInput
  }

  export type UserDocumentAttributesUncheckedUpdateWithoutDocumentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    lastOpenedDocumentVersionID?: StringFieldUpdateOperationsInput | string
  }

  export type PublishedDocumentUpdateWithoutDocumentInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutPublishedDocumentNestedInput
    likingUsers?: UserUpdateManyWithoutPublishedDocumentLikesNestedInput
  }

  export type PublishedDocumentUncheckedUpdateWithoutDocumentInput = {
    publishedDocumentID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    url?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    likingUsers?: UserUncheckedUpdateManyWithoutPublishedDocumentLikesNestedInput
  }

  export type WritingSessionUpdateWithoutDocumentInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWritingSessionsNestedInput
    likes?: UserUpdateManyWithoutWritingSessionLikesNestedInput
  }

  export type WritingSessionUncheckedUpdateWithoutDocumentInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: UserUncheckedUpdateManyWithoutWritingSessionLikesNestedInput
  }

  export type WritingSessionUncheckedUpdateManyWithoutWritingSessionInput = {
    writingSessionID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    segmentTime?: WritingSessionUpdatesegmentTimeInput | Enumerable<number>
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    startDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    inProgress?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserEnhancedDocumentPermissionsCreateManyEnhancedDocumentInput = {
    userID: string
    role: EnhancedDocumentRole
  }

  export type ThreadAttributesCreateManyDocumentInput = {
    threadID?: string
    userID: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserEnhancedDocumentPermissionsUpdateWithoutEnhancedDocumentInput = {
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
    user?: UserUpdateOneRequiredWithoutUserEnhancedDocumentPermissionsNestedInput
  }

  export type UserEnhancedDocumentPermissionsUncheckedUpdateWithoutEnhancedDocumentInput = {
    userID?: StringFieldUpdateOperationsInput | string
    role?: EnumEnhancedDocumentRoleFieldUpdateOperationsInput | EnhancedDocumentRole
  }

  export type ThreadAttributesUpdateWithoutDocumentInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutThreadAttributesNestedInput
    chatMessage?: ChatMessageUpdateManyWithoutThreadNestedInput
  }

  export type ThreadAttributesUncheckedUpdateWithoutDocumentInput = {
    threadID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sectionData?: NullableJsonNullValueInput | InputJsonValue
    chatMessage?: ChatMessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ChatMessageCreateManyThreadInput = {
    chatMessageID?: string
    content: string
    author: ChatMessageAuthor
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutThreadInput = {
    chatMessageID?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: EnumChatMessageAuthorFieldUpdateOperationsInput | ChatMessageAuthor
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutThreadInput = {
    chatMessageID?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: EnumChatMessageAuthorFieldUpdateOperationsInput | ChatMessageAuthor
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatMessageInput = {
    chatMessageID?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    author?: EnumChatMessageAuthorFieldUpdateOperationsInput | ChatMessageAuthor
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutPublishedDocumentLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPublishedDocumentLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    writingSessionLikes?: WritingSessionUncheckedUpdateManyWithoutLikesNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLikingUsersInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutWritingSessionLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUpdateManyWithoutFollowingNestedInput
    following?: FollowsUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUpdateManyWithoutUserNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWritingSessionLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    userDocumentPermissions?: UserDocumentPermissionUncheckedUpdateManyWithoutUserNestedInput
    userNotePermission?: UserNotePermissionUncheckedUpdateManyWithoutUserNestedInput
    statUnit?: DailyStatUnitUncheckedUpdateManyWithoutUserNestedInput
    scratchpadEntry?: ScratchpadEntryUncheckedUpdateManyWithoutUserNestedInput
    userDocumentAttributes?: UserDocumentAttributesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponse?: DailyChallengeResponseUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengeResponseLikes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutUserNestedInput
    dailyChallengePromptSuggestion?: DailyChallengePromptSuggestionUncheckedUpdateManyWithoutUserNestedInput
    followedBy?: FollowsUncheckedUpdateManyWithoutFollowingNestedInput
    following?: FollowsUncheckedUpdateManyWithoutFollowerNestedInput
    PublishedDocument?: PublishedDocumentUncheckedUpdateManyWithoutUserNestedInput
    publishedDocumentLikes?: PublishedDocumentUncheckedUpdateManyWithoutLikingUsersNestedInput
    writingSessions?: WritingSessionUncheckedUpdateManyWithoutUserNestedInput
    userEnhancedDocumentPermissions?: UserEnhancedDocumentPermissionsUncheckedUpdateManyWithoutUserNestedInput
    threadAttributes?: ThreadAttributesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    appDrawerNoteIDs?: UserUpdateappDrawerNoteIDsInput | Enumerable<string>
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    longestStreak?: IntFieldUpdateOperationsInput | number
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    twitter?: NullableStringFieldUpdateOperationsInput | string | null
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    openAIAPICalls?: IntFieldUpdateOperationsInput | number
  }

  export type DailyChallengeResponseCreateManyDailyChallengeInput = {
    userID?: string | null
    dailyChallengeResponseID?: string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: Date | string | null
    wordCount?: number
    completedOnTime?: boolean
  }

  export type DailyChallengeResponseUpdateWithoutDailyChallengeInput = {
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutDailyChallengeResponseNestedInput
    likes?: DailyChallengeResponseLikesUpdateManyWithoutDailyChallengeResponseNestedInput
    dailyStatUnit?: DailyStatUnitUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseUncheckedUpdateWithoutDailyChallengeInput = {
    userID?: NullableStringFieldUpdateOperationsInput | string | null
    dailyChallengeResponseID?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    postedOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    wordCount?: IntFieldUpdateOperationsInput | number
    completedOnTime?: BoolFieldUpdateOperationsInput | boolean
    likes?: DailyChallengeResponseLikesUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
    dailyStatUnit?: DailyStatUnitUncheckedUpdateManyWithoutDailyChallengeResponseNestedInput
  }

  export type DailyChallengeResponseLikesCreateManyDailyChallengeResponseInput = {
    userID: string
    likeID?: string
  }

  export type DailyStatUnitCreateManyDailyChallengeResponseInput = {
    dailyStatUnitID?: string
    userID: string
    documentVersionID?: string | null
    documentID?: string | null
    date?: Date | string
    timeSpentSeconds?: number
    wordsAdded?: number
    wordsRemoved?: number
  }

  export type DailyChallengeResponseLikesUpdateWithoutDailyChallengeResponseInput = {
    likeID?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutDailyChallengeResponseLikesNestedInput
  }

  export type DailyChallengeResponseLikesUncheckedUpdateWithoutDailyChallengeResponseInput = {
    userID?: StringFieldUpdateOperationsInput | string
    likeID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyChallengeResponseLikesUncheckedUpdateManyWithoutLikesInput = {
    userID?: StringFieldUpdateOperationsInput | string
    likeID?: StringFieldUpdateOperationsInput | string
  }

  export type DailyStatUnitUpdateWithoutDailyChallengeResponseInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutStatUnitNestedInput
    documentVersion?: DocumentVersionUpdateOneWithoutStatUnitNestedInput
    document?: DocumentUpdateOneWithoutStatUnitNestedInput
  }

  export type DailyStatUnitUncheckedUpdateWithoutDailyChallengeResponseInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }

  export type DailyStatUnitUncheckedUpdateManyWithoutDailyStatUnitInput = {
    dailyStatUnitID?: StringFieldUpdateOperationsInput | string
    userID?: StringFieldUpdateOperationsInput | string
    documentVersionID?: NullableStringFieldUpdateOperationsInput | string | null
    documentID?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    timeSpentSeconds?: IntFieldUpdateOperationsInput | number
    wordsAdded?: IntFieldUpdateOperationsInput | number
    wordsRemoved?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}